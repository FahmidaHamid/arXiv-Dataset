Optimality of the Neighbor Joining Algorithm
and Faces of the Balanced Minimum Evolution
Polytope
David C. Haws1 , Terrell L. Hodge2 , and Ruriko Yoshida1

arXiv:1004.2073v2 [q-bio.PE] 3 Feb 2011

1

2

University of Kentucky, Lexington, KY, 40502-00227
Western Michigan University, Kalamazoo, MI, 49008-5248

Abstract. Balanced minimum evolution (BME) is a statistically consistent distance-based method to reconstruct a phylogenetic tree from
an alignment of molecular data. In 2000, Pauplin showed that the BME
method is equivalent to optimizing a linear functional over the BME
polytope, the convex hull of the BME vectors obtained from Pauplin’s
formula applied to all binary trees. The BME method is related to the
Neighbor Joining (NJ) algorithm, now known to be a greedy optimization of the BME principle. Further, the NJ and BME algorithms have
been studied previously to understand when the NJ Algorithm returns
a BME tree for small numbers of taxa. In this paper we aim to elucidate
the structure of the BME polytope and strengthen knowledge of the connection between the BME method and NJ Algorithm. We first prove that
any subtree-prune-regraft move from a binary tree to another binary tree
corresponds to an edge of the BME polytope. Moreover, we describe an
entire family of faces parametrized by disjoint clades. We show that these
clade-faces are smaller dimensional BME polytopes themselves. Finally,
we show that for any order of joining nodes to form a tree, there exists
an associated distance matrix (i.e., dissimilarity map) for which the NJ
Algorithm returns the BME tree. More strongly, we show that the BME
cone and every NJ cone associated to a tree T have an intersection of
positive measure.

Keywords: Phylogentic Analysis, Balanced Minimum Evolution, Neighbor
Joining, Polyhedral Geometry, Combinatorics.

1

Introduction

Current efforts to reconstruct the tree of life for different organisms demand the
inference of phylogenies from thousands of DNA sequences (see http://tolweb.org/tree/
[1] and [7] for more details). Large scale projects include the investigation of the
tree of life for flies, by researchers at North Carolina State University
(http://www.inhs.illinois.edu/research/FLYTREE/), the tree of life for fungi,
at Duke University (http://aftol.org/), and at the University of Kentucky,
the tree of life for the insect order Hymenoptera (http://www.hymatol.org/).
To appear in Bulletin of Mathematical Biology

The most established approach to tree reconstruction is the maximum likelihood (ML) method. In this method, evolution is described in terms of a discretestate continuous-time Markov process on a phylogenetic tree. Unfortunately, an
exhaustive search for the ML phylogenetic tree is computationally prohibitive for
large data sets [20]. However, one can efficiently compute a pairwise distance, a
distance between a pair of leaves, using the ML method. The pairwise distances
can then be used, together with a distanced-based tree reconstruction method,
to recover the phylogenetic tree that relates the sequences [17], albeit at a loss
of accuracy. To date, distance-based methods for phylogeny reconstruction have
been seen to be the best hope for accurately building phylogenies on very large
sets of taxa such as the data sets for tree of life for Hymenoptera [13, 23]. More
precisely, distance-based methods have been shown to be statistically consistent
in all settings ( such as the long branch attraction) in contrast with parsimony
methods [4, 10, 11, 16]. Distance-based methods also have a huge speed advantage over parsimony and likelihood methods, and hence enable the reconstruction
of trees on greater numbers of taxa.
In 2002, Desper and Gascuel introduced a balanced minimum evolution
(BME) principle, based on a branch length estimation scheme of Pauplin [19].
The guiding principle of minimum evolution tree reconstruction methods is to
return a tree whose total length (sum of branch lengths) is minimal, given an
input dissimilarity map. The BME method is a special case of these distancebased methods wherein branch lengths are estimated by a weighted least-squares
method (in terms of the input dissimilarity map and the tree in question) that
puts more emphasis on shorter distances than longer ones. Each labeled tree
topology gives rise to a vector, called herein the BME vector, which is obtained
from Pauplin’s formula.
Implementing, exploring, and better understanding the BME method have
been focal points of several recent works. The software FastME, developed by
Desper and Gascuel, heuristically optimizes the BME principle using nearestneighbor interchanges (NNI) [12]. In simulations, FastME gives superior trees
compared to other distance-based methods, including one of biologists’ most
popular distance-based methods, the Neighbor Joining (NJ) Algorithm, developed by Saitou and Nei [21]. In 2000, Pauplin showed that the BME method is
equivalent to optimizing a linear function, the dissimilarity map, over the BME
representations of binary trees, given by the BME vectors [19]. Eickmeyer et.
al. defined the nth BME polytope as the convex hull of the BME vectors for all
binary trees on a fixed number n of taxa. Hence the BME method is equivalent
to optimizing a linear function, namely, the input dissimilarity map, over a BME
polytope. In 2010, Matsen and Cueto [8] studied how the BME method works
when the addition of an extra taxon to a data set alters the structure of the
optimal phylogenetic tree. They characterized the behavior of the BME phylogenetics on such data sets, using the BME polytopes and the BME cones, i.e.,
the normal cones of the BME polytope.
2

Eickmeyer et. al. studied the BME polytopes computationally, for unrooted
phylogenetic trees with eight or fewer taxa. In addition to this computational
study of the BME polytopes, they showed the following general lemma:
Lemma 1 (Lemma 3.1 in [14]). For any number of taxa n, the vertices of the
nth BME polytope are exactly the BME vectors of all unrooted binary trees with
n leaves. The BME vector of the star phylogeny lies in the interior of the BME
polytope, and all other BME vectors lie on the boundary of the BME polytope.
In particular, Eickmeyer et. al. studied edges of the BME polytopes computationally. They found that the edge graph of the nth BME polytope is the

Fig. 1. The non-edges on the nth BME polytope for n = 7. Two trees will form
a non-edge if and only if they are trees that have three cherries, and differ by
the pair of leaf exchanges shown in the figure.

complete graph T2 with the same number (≤ 6) of leaves, there is a dissimilarity
map for which T1 and T2 are (the only) co-optimal BME trees. However, for
n = 7, the BME polytope has one combinatorial type of non-edge, i.e., the BME
vectors of two bifurcating trees with seven leaves and three cherries (two leaves
adjacent to the unique internal node in the tree) fail to be joined by an edge if
and only if their trees are related by two leaf exchanges as depicted in Figure 1.
This completely characterizes the non-edges for n = 7.
Characterizing the edges of the nth BME polytope for n > 7 remains an
open problem that motivated this work. Understanding the structure of the
BME polytope through its edges and faces may help with the development of
new optimization strategies to find an optimal BME tree. For example, one such
approach could entail employing an edge-walking method over the edges of the
BME polytope, since the BME method is a linear programming problem over
the BME polytope. However, until now, not much was known about the faces of
the BME polytopes besides vertices (which are trivial to characterize).
This paper makes contributions towards understanding both edges and higherdimensional faces of the BME polytope. First, we prove that any subtree-pruneregraft (SPR) move from a binary tree to another binary tree corresponds to an
edge of the BME polytope. This implies that any NNI move from a binary tree to
another binary tree corresponds to an edge of the BME polytope. Consequently,
3

the method implemented in the software FastME is an edge-walking method over
the edges of the BME polytope using NNI moves. Moreover, we define and describe an entire family of faces of the BME polytope that are parametrized by
disjoint clades. We show that these clade-faces are smaller dimensional BME
polytopes themselves.
The study of related geometric structures, the BME cones, further clarifies
the nature of the link between phylogenetic tree reconstruction using the BME
criterion and using the Neighbor Joining (NJ) Algorithm. In 2006, Gascuel and
Steel showed that the NJ Algorithm, one of the most popular phylogenetic tree
reconstruction algorithms, is a greedy algorithm for finding the BME tree associated to a dissimilarity map [18]. The Neighbor Joining Algorithm relies on
a particular criterion for iteratively selecting cherries; details on cherry-picking
and the NJ Algorithm are recalled later in the paper. In 2008, based on the
fact that the selection criterion for cherry-picking is linear in the dissimilarity
map [5], Eickmeyer et. al. showed that the NJ Algorithm will pick cherries to
merge in a particular order and output a particular tree topology T if and only if
the pairwise distances satisfy a system of linear inequalities, whose solution set
n
forms a polyhedral cone in R( 2 ) [14]. They defined such a cone as an NJ cone.
In general, the sequence of cherries chosen by the NJ Algorithm is not unique,
hence multiple dissimilarity maps will be assigned by the NJ Algorithm to a
single fixed tree topology T. The set of all dissimilarity maps for which the NJ
Algorithm returns a fixed tree topology T is a union of NJ cones, however this
union is not convex in general. Eickmeyer et. al. [14] characterized those dissimilarity maps for which the NJ Algorithm returns the BME tree, by comparing
the NJ cones with the BME cones, for eight or fewer taxa.
Yet, before this paper, it was unclear whether, given a tree topology T with an
arbitrary number of taxa, and any particular order of picking cherries allowed by
the NJ Algorithm, there existed a dissimilarity map such that the NJ Algorithm
would return the BME tree T . We prove this in fact is so, despite the fact that
greedy algorithms do not generally construct the globally optimal structure for
the condition which they locally optimize. Interpreted in terms of phylogenetics,
this is particularly important, as it shows that there is no order of picking cherries
for which the NJ Algorithm will fail to return the BME tree. Geometrically this
means that for any NJ cone associated with the tree topology T and a particular
choice of cherry-picking order, there exists a non-empty intersection with the
BME cone associated with T. Consequently, given any tree topology T , there
exists a dissimilarity map such that NJ and BME both return the tree topology
T . More strongly, we show that the BME cone and every NJ cone associated to
a tree T have an intersection of positive measure.
This paper is organized as follows: Definitions and notation are covered in
Section 2. Subsection 2.4 treats clade-faces of the BME polytope and contains
a useful proposition concerning objective criteria for greedy linear optimization.
Section 3 contains the proof that two trees adjacent by an SPR move form an
edge of the BME polytope. In Section 4 we present the Cherry Forcing Algorithm
and show that it also provides proof for the existence of clade-faces. Finally,
4

using the Cherry Forcing Algorithm, in Section 5 we prove that every NJ cone
associated with a tree T has a non-empty intersection of positive measure with
the BME cone associated with T . That is, given a tree T and a sequence of
cherries chosen by the NJ Algorithm, there is a dissimilarity map such that NJ
and BME return T . We finish with a discussion in Section 6.

2
2.1

Notation, Definitions and Further Preliminaries
Phylogenetic X-trees, Cherries, and Clades

Let X be a set of leaves, which we also may call taxa; when |X| = n, we will
often conveniently identify X with {1, 2, . . . n}. A dissimilarity map (or distance
matrix) is a function d : X × X → R with d(x, x) = 0 and d(x, y) = d(y, x) for all
n
x, y ∈ X. It is convenient to represent a dissimilarity map by a vector d ∈ R( 2 ) .
n
In general, we index entries of any c ∈ R( 2 ) by pairs {i, j} ⊂ X with i < j in
n
lexicographic order, i.e. c = (c12 , c13 , . . . , c1n , c23 , . . . , c2,n , . . . , cn−1,n ) ∈ R( 2 ) .
n
We may also index a set of vectors in R( 2 ) by superscript when necessary, e.g.,
n
n
ck ∈ R( 2 ) with ijth coordinate ckij . Define eij ∈ R( 2 ) to be the vector with 1 at
n
(n)
the ijth entry and 0 else. Let R 2 = {x ∈ R( 2 ) | x ≥ 0 for all 1 ≤ i < j ≤ n}.
ij

+

Mathematically, a tree is an undirected graph in which any two vertices are
connected by exactly one simple path; the number of edges incident to any vertex
(i.e., node) x of the tree is the degree deg(x) of x. If the graph consists of more
than a single vertex, a node x with deg(x) = 1 is external, or a leaf; all other
nodes are internal. A phylogenetic X-tree is a tree T with set of leaves X and all
internal vertices of degree at least three. Those for which the internal vertices are
all of degree three are here called binary X-trees (or just binary trees, when the
context is clear). For n = |X| ≥ 3 the binary X-trees are necessarily unrooted
trees, and for n ≥ 4, correspond in phylogenetics to unrooted cladograms with
no polytomy. Let Tn be the set of all binary trees with n leaves; we will assume
throughout n ≥ 3. Write E(T ) for the set of edges (i.e., branches) of T ∈ Tn .
An edge e ∈ E(T ) is internal (resp., external) if it does not (resp., does) touch
a leaf. A cherry of T ∈ Tn is a pair of leaves {i, j} such that the path between
them consists of just two (necessarily external) edges. An edge-weighting (or
branch length assignment) ω of T is a function ω : E(T ) → R with ω(e) ≥ 0
for everyPe ∈ E(T ). Given an edge weighting ω, define the total tree length
ω(T ) := e∈E(T ) ω(e).
An X-split is a partition A | B of X into two subsets (blocks) A, B ⊂ X.
Any edge e ∈ E(T ) of T ∈ Tn induces an X-split A1 | A2 by deleting e from
T and letting Ai be the subset of leaves associated to the resulting connected
component Ci , i = 1, 2, of T. Conversely any X-split A1 | A2 corresponds to the
edge that when deleted gives the split. When e ∈ E(T ) is internal, we will call
Ci a clade, and Ai the support supp(Ci ) of Ci . When the context is clear, we
may identify a clade C with its support supp(C). By allowing for the case of
choosing no edge e, that is, the trivial X-split ∅ | X, we obtain T itself as a clade.
5

Further, we simply say a clade C is in Tn (and write C ∈ Tn ) if C is a clade for
some tree in Tn .
For example, leaves {1, 2} define a clade of T1 of Figure 3(a) whereas {2, 3}
is not a clade of T1 since there is no subgraph containing {2, 3} attainable by
removing an internal edge of T1 . We say two clades C1 , C2 ∈ Tn are disjoint if
supp(C1 ) ∩ supp(C2 ) = ∅. If C1 , C2 are disjoint clades both contained in a tree
T ∈ Tn , then we define the distance between clades dT (C1 , C2 ) as the number of
edges between clades C1 and C2 in T .
Finally, given T ∈ Tn , let Σ(T ) denote the set of X-splits defined by removal
of an edge of T. It is well-known [6] that phylogenetic X-trees T1 , T2 ∈ Tn are
determined up to equivalence (as graphs) exactly when Σ(T1 ) = Σ(T2 ). If ω :
E(T ) → R is an edge-weighting, and A | B is a split in Σ(T ) with corresponding
n
edge e ∈ E(T ), set ω(A | B) := ω(e). A distance matrix c ∈ R( 2 ) is called an
additive metric or tree metric if c is a metric, and there exists a tree T ∈ Tn and
an edge-weighting ω on T s.t.
(a) ω(e) > 0 for all e ∈ E(T ).
P
(b) For every pair of leaves {i, j}, cij = e ω(e), summing over edges e along
the path from leaf i to leaf j.
Clearly, given T ∈ Tn and an edge-weighting ω on T, setting DT,ω (i, j) =
P
(n2 )
ω(e),
for
the
sum
as
in
(b)
above,
yields
a
tree
metric
D
∈
R
T,ω
+ . Given a
e
tree T ∈ Tn and any split A | B in T , where A, B ⊆ {1, 2, . . . , n}, the split metric
A|B
A|B
is defined as DA | B = (dij ) where dij = 1 if i 6= j and |{i, j} ∩ A| = 1, and
A|B

dij = 0 else. Thus each split A | B defines a metric DA | B from T for which all
branch lengths equal to zero, except for the branch e corresponding to A | B. For
any edge-weighting ω of T, the split metrics for T and the natural tree metric
DT,ω are related as below (see, e.g., [2]):
X
DT,ω =
ω(A | B)DA | B .
(1)
A | B∈Σ(T )

2.2

Amalgamation of Cherries

The amalgamation of T ∈ Tn by cherry {i, j} is the subtree Te on n − 1 leaves
obtained by amalgamating the vertices in cherry {i, j} to their common internal
parent node. In the more formal mathematical language of relations on the set
of leaves X = {x1 , . . . , xn }, the amalgamation of a cherry {xi , xj } ∈ X × X to
its common internal parent node vi,j corresponds to a two-step merge obtained
(without loss of generality) by first merging the nodes xi , vi,j to a new (internal)
0
0
node vi,j
, and then merging xj , vi,j
to a new (external) node [xi , xj ], resulting
e = X − {xi , xj } ∪ {[xi , xj ]}.
in the new tree Te on the leaf set X
For example, in Figure 2, amalgamating cherry {1, 2} of T1 gives T2 with the
new leaf labeled [1, 2]. Next, amalgamating cherry {[1, 2], 3} in T2 produces T3 .
If T 0 is obtained from T by successive amalgamations of cherries (including the
6

possibility that no cherries are amalgamated, so T 0 = T ), then any leaf i0 of T 0
is either present in T as a single leaf, or the result of the amalgamation of leaves
i1 , . . . , it of T . Hence, leaf i0 of T 0 induces the clade C of T with supp(C) = {i0 },
in the first case, or supp(C) = {i1 , . . . , it }, in the second case. For example, leaf
[[[1, 2], 3, 4]] of T4 in Figure 2 defines a clade in T1 given by the leaves 1,2,3, and
4 of T1 . We will call the clade of T obtained from any leaf i0 of T 0 the subgraph
of T given by i0 .

Fig. 2. Cherry {1, 2} of tree T1 is amalgamated yielding tree T2 , where the
new leaf is labeled [1, 2]. Cherry {[1, 2], 3} of T2 is amalgamated yielding tree
T3 , where the new leaf is labeled [[1, 2], 3]. Similarly, the leaves {[[1, 2], 3], 4},
{[[[1, 2], 3], 4], 5} are amalgamated in trees T3 and T4 , respectively.

2.3

Balanced Minimum Evolution: Method, Vectors, and Polytopes

(n)
For a phylogenetic X-tree T ∈ Tn and a dissimilarity map d ∈ R+2 , there are
different biologically relevant methods to assign branch lengths (i.e., an edgeweighting) to T ; in this context, the entry di,j of d is most often regarded as
the distance between any pair of taxa i and j. The balanced minimum evolution (BME) method employs a weighted least squares approach for assigning
branch lengths l : E(T ) → R+ given the dissimilarity map d. Defined by Pauplin [19], the definition of the edge-weights l(e) (i.e., [13, Equations (2), (3),
equiv., (7), (8)]) utilizes average distances between clades whence consequently
the l(e) are, moreover, linear in the input dissimilarity map d (e.g., see Equation (1) in [13]).
PHowever, for the BME method, the calculation of the total tree
length l(T ) = e∈E(T ) l(e) can be easily stated and quickly computed without
resorting to computing individual branch lengths l(e), by the means we now
T
describe. For any pair {i, j} of leaves of T, define yij
:= #{ edges between
T

T
leaves i and j }, the topological distance between i and j. Set wij
:= 21−yij , so
n
T
T
T
wT := (w12
, w13
, . . . , wn−1,n
) ∈ R( 2 ) is a vector depending only on the topology

7

of T. Pauplin’s [19] formula for the balanced tree length estimation (or estimated
BME length) l(T ) is given by
l(T ) =

X

T
wi,j
di,j = wT · d.

(2)

i,j:i<j

When necessary for clarity, we will also indicate the dependence on d of the
estimated BME length wT · d by writing l(T, d). Since wT depends only on
the topology of T , but determines l(T, d) given any input dissimilarity map
(n)
d ∈ R+2 , we call wT the BME vector for T .
T
In [25], the authors in fact defined terms wi,j
for any phylogenetic X-tree
T (not necessarily binary) in terms of certain cyclic permutations of (“circular
orderings”) of X that respect the structure of T as measured through its set
of splits Σ(T ). In the case of edge-weighted binary X-trees, one recovers the
T
expression for wi,j
in the BME vector and Pauplin’s formula. [25] used this
perspective to establish the consistency of the balanced tree length estimation.
That is, if T ∈ Tn has branch lengths ω and one takes d = DT,ω in Equation 2,
one obtains l(T ) = ω(T ).
The BME method for phylogenetic tree reconstruction (or BME principle)
can be succinctly stated: find a T ∈ Tn such that Equation 2 is minimized, given
n
the dissimilarity map d ∈ R( 2 ) .
Note that one can efficiently compute the input for the BME method, i.e.,
pairwise distances d(i, j), from any given sequence alignment using the maximum
likelihood estimators (MLEs) under an evolutionary model. The BME method
for tree reconstruction was shown to be consistent in [13].
We recall some necessary definition from polyhedral geometry [22]. The convex hull of {a1 , . . . , am } ⊂ Rn is defined as
(
)
m
m
X
X
n
conv{a1 , . . . , am } := x ∈ R | x =
λi ai ,
λi = 1, λi ≥ 0 .
i=1

i=1

A polytope P is the convex hull of finitely many points. We say F ⊆ P is a face
of the polytope P if there exists a vector c such that F = argmaxx∈P c · x. Every
face F of P is also a polytope. If the dimension of P is d, a face F is a facet
if it is of dimension d − 1. A face is an edge if it is of dimension two. Denote
the vertex set of a polytope P by vert(P), where a vertex of a d-dimensional
polytope is the intersection point of d or more edges, faces or facets.
With the background on BME above in hand, we now recall the definition
of the central object of study in this paper, the BME polytope, as it arises from
the BME vectors.
Definition 1 (BME polytope). The balanced minimum evolution (BME) polytope Pn on n leaves is defined as

	
Pn := conv wT | T ∈ Tn .
8

If F is a face of Pn , then its vertex set is given by vert(F ) = {wT1 , . . . , wTm | wTi ∈
F }, which we may identify with the set of trees {T1 , . . . , Tm }. With this definition we can see that minimizing Equation 2 is equivalent to minimizing the
n
linear objective d ∈ R( 2 ) over Pn . Using Day’s results it can be shown that
choosing a minimizing tree for (2) from among the (2n − 5)!! unrooted binary
trees is an NP-hard problem [9, 14]. Thus it is NP-hard to optimize linearly over
Pn [14].

(a) For |X| = 4, there are the 3 binary trees and the star-shaped tree.

w T1

wT4
wT3

wT2

(b) BME polytope on four
taxa.

Fig. 3. All X-trees on four taxa and the BME polytope P4

Example 1 ([14]). For n = 4, there are the 3 binary trees and the star-shaped
tree as in Figure 3(a). For this case the BME polytope is the convex hull of the
vectors:




1 1 1 1 1 1
1 1 1 1 1 1
T1
T2
w =
, , , , ,
, w =
, , , , ,
,
2 4 4 4 4 2
4 2 4 4 2 4




1 1 1 1 1 1
1 1 1 1 1 1
wT3 =
, , , , ,
, w T4 =
, , , , ,
4 4 2 2 4 4
3 3 3 3 3 3
Thus the BME polytope Pn for n = 4 is a triangle in R6 . Note that the starshaped tree is in the interior of Pn .
n

Remark
1 ([14]). The nth BME polytope Pn lies in R( 2 ) and has dimension

n
2 − n.
9

2.4

Clade Faces

With minor modifications of the proof of BME consistency in [13] we will show
that any collection of disjoint clades defines a face of the BME polytope. This will
also be proved independently and constructively in Section 5 using the Cherry
Forcing Algorithm.
Lemma 2. Let C1 , . . . , Cp ∈ Tn be a pairwise disjoint collection of clades. There
n
exists a c ∈ R( 2 ) such that argmax wT · c = { T ∈ Tn | C1 , . . . , Cp ∈ T }.
T ∈Tn

See the appendix for a proof of Lemma 2.
Lemma 2 proves that every disjoint set of clades corresponds to a face of
Pn which we define as follows: Given a set of disjoint clades {C1 , . . . , Cp | Ci ∈
Tn , ∀ 1 ≤ i ≤ p}, we define a clade-face of the BME polytope Pn by FC1 ,...,Cp :=
{ T ∈ Tn | C1 , . . . , Cp ∈ T }. Moreover, the face FC1 ,...,Cp is the
Pp image of an
affine transformation of the BME polytope Pl , where l := n − i=1 (|Ci | − 1).
This follows since every tree in FC1 ,...,Cp can be constructed by starting with a
binary tree on l leaves and attaching the clades {C1 , . . . , Cp } to p of the l leaves.
Looking ahead to Section 3, one can see that the three trees corresponding
to a nearest neighbor interchange (explained therein) form a clade-face, as an
immediate consequence of Lemma 2. This suggests that NNI and SPR moves
yield edges of the BME polytope Pn , but this fact will require additional proof.
Leading into this, we provide a proposition which holds for any polytope in
general, and will be key to our further arguments. Roughly speaking it states
that if the entries of c1 are significantly larger than the entries of c2 , then
when linearly optimizing c1 + c2 over a polytope P then c1 must be maximized
foremost.
Proposition 1. Let P ⊆ Rm be a polytope and c1 , c2 ∈ Rm . If
min
x,y∈vert(P)
x∈argmaxz∈P c1 ·z
c1 ·x6=c1 ·y

c1 · x − c1 · y >

max
x,y∈vert(P)

|c2 · x − c2 · y|

(3)

then
argmax (c1 + c2 ) · z ⊆ argmax c1 · z.
z∈vert(P)

z∈vert(P)

See the appendix for a proof of Proposition 1.
Consider two clade-faces FC1 ,...,Ck and FC10 ,...,Ck0 0 where |FC1 ,...,Ck | > 1. Then,
0
FC1 ,...,Ck0 0 ⊆ FC1 ,...,Ck if and only if for every 1 ≤ i ≤ k, clade Ci is contained in,
or equal to, clade Cj0 for some 1 ≤ j ≤ k 0 . If FC1 ,...,Ck = {T }, then FC10 ,...,Ck0 0 ⊆
FC1 ,...,Ck if FC10 ,...,Ck0 0 = {T }. We note that this induces a partial order on the
clade-faces of Tn , and gives a lattice if one also considers Pn and the empty set
as clade-faces.
10

3

SPR Adjacency Implies BME Adjacency

A subtree-prune-regraft (SPR) move on a tree T ∈ Tn is determined by choosing
a clade of C of T , pruning it from T , and amalgamating the two internal edges
originally connecting C to T to one edge. Finally an internal edge of T is chosen,
a node is inserted, and C is attached to this node. For an example, see Figure 4.
Thus, T is changed to another binary tree on n leaves and we say the two trees
are adjacent by an SPR move.
A nearest neighbor interchange (NNI) move on a tree T ∈ Tn is determined
by choosing an internal edge e ∈ E(T ), , and rearranging the four subgraphs
(clades) that e induces. It is not difficult to see then that an NNI move is also
an SPR move. The following lemma is an application of Proposition 1 applied
to a face of the BME polytope, and two clades contained in the face.
Lemma 3. Let F be a face of the BME polytope Pn , where C1 , C2 are disjoint
n
clades with C1 , C2 ∈ T, ∀ T ∈ vert(F ). There exists an objective c ∈ R( 2 ) such
that
argmax wT · c = { T ∈ vert(F ) | dT (C1 , C2 ) ≥ dT 0 (C1 , C2 ), ∀ T 0 ∈ vert(F ) }.
T ∈Tn
n

Similarly there exists an objective d ∈ R( 2 ) such that
argmax wT · d = { T ∈ vert(F ) | dT (C1 , C2 ) ≤ dT 0 (C1 , C2 ), ∀ T 0 ∈ vert(F ) }.
T ∈Tn

For a proof of Lemma 3 see the appendix.
Corollary 1. Every NNI move corresponds to an edge of the BME polytope.
Proof. Simply take the objective c given by Lemma 2 which yields the face of
the three trees corresponding to an NNI, then add the extra criteria that either
two of the clades are as close or as far as possible, and apply Lemma 3.

We now present our result that any pair of two trees adjacent by an SPR
move yields an edge of the BME polytope.
Theorem 1. If T1 , T2 ∈ Tn are adjacent by an SPR move, then there exists
n
c ∈ R( 2 ) such that wT1 · c = wT2 · c > wT · c for all T ∈ Tn \{T1 , T2 }.
Proof. Let T1 , T2 ∈ Tn be adjacent by an SPR move. Any such move can be
described by Figure 4, where C1 , . . . , Cp (labeled 1, . . . , p in Figure 4) are clades
common to T1 and T2 and clade Cp is the subtree that is pruned and regrafted.
n
By Lemma 2 there exists an objective c1 ∈ R( 2 ) for the clade-face FC1 ,...,Cp .
11

(a)

(b)

Fig. 4. Here 1, . . . , p are subgraphs (clades). Two trees, T1 (a) and T2 (b), adjacent by an SPR move where subgraph p and its connecting edge is the subgraph
pruned from T1 and regrafted between subgraph (p − 2) and its internal node.

Note that T1 , T2 ∈ FC1 ,...,Cp , but in general FC1 ,...,Cp will contain more trees,
hence further restrictions need to be placed on the objective. By repeated use of
Lemma 3, and the objective c1 which defines FC1 ,...,Cp , there exists an objective
n
c ∈ R( 2 ) such that in this order of importance,
2

1)
2)
3)
4)

the
the
the
the
..
.

distance
distance
distance
distance

between
between
between
between

clades
clades
clades
clades

Cp−1 and Cp−2 is maximized,
C1 and C2 is minimized,
C2 and C3 is minimized,
C3 and C4 is minimized,

p-4) the distance between clades Cp−4 and Cp−3 is minimized,
for trees in FC1 ,...,Cp . Since T1 and T2 contain the clades C1 , . . . , Cp and the
properties in the previous list are satisfied in the prescribed order, we see that
{T1 , T2 } ⊂ argmaxT ∈Pn wT · c2 , but the latter may also contain the trees with
the clades in the dashed box of Figure 4 inverted vertically.
Select leaves i ∈ Cp−1 and j ∈ C1 such that dT2 (i, j) ≤ dT2 (m, n), ∀(m, n) ∈
Cp−1 × C1 . Similarly, let k ∈ Cp−2 and l ∈ Cp−3 such that dT1 (k, l) ≤ dT1 (m, n),
∀(m, n) ∈ Cp−2 × Cp−3 .
12

T1
T2
T2
T1
T1
T2
and wkl
= 2wkl
. It follows
= wij
ekl . Note that 2wij
Let d = wkl
eij + wij
T1
T2
then that w · d = w · d. There exists ε > 0 small enough such that

min
x,y∈vert(P)
x∈argmaxz∈P c2 ·z
c2 ·x6=c2 ·y

c2 · x − c2 · y >

max

|εd · x − εd · y|.

x,y∈vert(P)

Therefore Proposition 1 holds and the objective εd optimized over argmaxT ∈Tn wT ·
c2 gives trees such that either clades C1 and Cp−1 are as close as possible or
Cp−2 and Cp−2 are as close as possible. Therefore argmaxT ∈Tn wT · (c2 + εd)
contains only T1 and T2 .


4

Cherry Forcing Objectives

(n)
The following lemma is a sufficient condition for vectors c1 , c2 ∈ R+2 to satisfy
Proposition 1 on the BME polytope Pn .
(n)
Lemma 4. Let c1 , c2 ∈ R+2 where for a fixed K > 0, c1ij = K for all {i, j} ∈
supp(c1 ). If
K
1
> c2 · (1, 1, . . . , 1)
(4)
2n−2
2
then
argmax (c1 + c2 ) · wT ⊆ argmax c1 · wT .
T ∈Pn

T ∈Pn

See the appendix for a proof of Lemma 4. If a triple (c1 , c2 , Pn ) satisfies the
assumptions and hypothesis of Lemma 4 and Equation 4 then we say it satisfies
the dominance condition.
Given a clade C in Tn as input, the idea of the Cherry Forcing Algorithm
n
is to iteratively fill in entries in an objective c ∈ R( 2 ) to satisfy the dominance
condition given in Equation 4 in such a fashion that respects C. More precisely,
under the Cherry Forcing Algorithm, (1) a small part of the topology (e.g. cherry)
of C is fixed, and (2) subsequently filled-in entries in c will be sufficiently small
such that no previously fixed structures of C will be broken
P when maximizing
c · wT over Pn . It is proved in Lemma 5 that the sum c = i ci of the outputs
of the Cherry Forcing Algorithm will yield the normal vector to the face of the
BME polytope Pn that consists of all trees that contain C. If C is an entire tree,
then the vector c is in the normal cone of the tree C of Pn . That is, c · wT is
maximal only when C = T .
Algorithm 1 (Cherry Forcing Algorithm)
b of Tb.
1: input Tb ∈ Tn , a clade C
(n)

2: output c1 , c2 , . . . , ct ∈ R+2 .

13

n

3: Initialization: Let T1 := Tb, K1 := 1, t := 1, and ci := 0 ∈ R( 2 ) .
4: repeat
5:
Pick a cherry {k, l} of Tt , s.t. the subgraphs of Tb given by k and l are in
6:
7:
8:
9:
10:
11:
12:
13:
14:

b
clade C.
Let Gk be the nodes of the subgraph of Tb given by k.
Let Gl be the nodes of the subgraph of Tb given by l.
for every pair {p, q} ∈ Gk × Gl do
Let ctp,q := Knt .
(2)
t
.
Let Kt+1 := n K2n−1
(2)
Let t := t + 1.
Let Tt := Tt−1 where cherry {k, l} is amalgamated.
b of Tb or T 0 is
until T 0 has a single leaf corresponding to the entire clade C
the star tree on three leaves.
return c1 , c2 , . . . , ct .

b of Tb be the input of Algorithm 1 with output
Lemma 5. Let Tb ∈ Tn and clade C
1 2
t
c , c , . . . , c . Every triple
{c1 , c2 + · · · + ct , Pn },
{c2 , c3 + · · · + ct , Pn },
{c3 , c4 + · · · + ct , Pn },
..
.
{ct−1 , ct , Pn }
satisfies the dominance condition in Equation 4. Consequently argmaxT ∈Tn (
b is a clade of T }.
wT = { T ∈ Tn | C

Pt

i=1

A proof of Lemma 5 is provided in the appendix.
b of Tb be the input of Algorithm 1 with
Lemma 6.
Let Tb ∈ Tn and clade C
1 2
t
i
output c , c , . . . , c . Then supp(c ) ∩ supp(cj ) = ∅ for all 1 ≤ i < j ≤ t.
A proof of Lemma 6 is provided in the appendix.

5

Non-empty Intersection of NJ and BME Cones

The NJ Algorithm, first presented in [21], is a consistent distance-based method
to reconstruct a phylogenetic tree. Yet, its biological interpretation and what
criteria it optimized have only been established recently. Some initially argued
that NJ optimized an ordinary least-squares criteria at each step, while others
contended that it did not optimize any criteria. See [18] for a short history of
NJ. However in [18], it was shown that in fact, NJ greedily minimizes the BME
criteria at every neighbor joining step. In [14] Eickmeyer et. al. characterized
14

ci )·

those dissimilarity maps for which the output of the NJ Algorithm is in fact the
BME tree, by a comparison of the NJ cones with the BME cones, for eight or
fewer taxa.
Given a tree topology T ∈ Tn with branch lengths ω, it follows from consistency that NJ and BME will return T given the tree metric D(T,ω) defined in
Section 2.1. That is, D(T,ω) will lie in at least one NJ cone of T . The order in
which NJ picks cherries depends on the dissimilarity map, and the dissimilarity
map depends on the branch lengths. Therefore which NJ cone D(T,ω) lies in is
strictly determined by the branch lengths ω. However, if a NJ cone C of T is fixed
it is not clear how branch lengths, call it ω 0 , can be assigned to the tree topology
of T such that D(T,ω0 ) is in C. Thus, it is not clear that consistency directly
implies that the BME cone and every NJ cone have non-trivial intersection.
Our result is that every NJ cone associated to a tree topology T ∈ Tn has an
intersection of positive measure with the BME cone. That is, for any NJ cone
associated with the particular order to pick cherries and the tree T , there is an
intersection of positive measure with the BME cone associated to T , where the
n
BME cone is defined as the set of all dissimilarity maps d ∈ R( 2 ) such that
0
argmaxT 0 ∈Tn d · wT ⊇ {T }.
n
The NJ Algorithm takes as input a dissimilarity map c ∈ R( 2 ) and builds
a tree T ∈ Tn [21]. It involves: 1) picking a cherry {i, j}, 2) creating a node a
joining taxa i and j, 3) computing the distances from other nodes to the new
node a, 4) repeating the procedure until the number of leaves n is 3.
The main problem is picking the cherry. A solution, suggested by Saitou and
Nei [21] and subsequently modified by Studier and Keppler [26], relies on the
Q-criterion in Theorem 2 below.
n
Theorem 2 (Cherry-picking criterion (Q-criteria) [21, 26]). Let c ∈ R( 2 )
be an additive tree metric for a tree T ∈ Tn and define the n × n-matrix Qc with
entries:

Qc (i, j) = (n − 2)ci,j −

n
X

ci,k −

k=1

n
X

ck,j = (n − 4)ci,j −

k=1

X
k6=j

ci,k −

X

ck,j . (5)

k6=i

Then any pair of leaves {i∗ , j ∗ }, for which Qc (i∗ , j ∗ ) is minimal, is a cherry in
the tree T .
If the NJ Algorithm selects taxa {k, l} as a cherry, and a is the new node
n−1
joining {k, l} then the new dissimilarity map c0 ∈ R( 2 ) is defined to be
if i 6= a 6= j
else

c0i,j = ci,j

1
ci,k + ci,l − ck,l .
c0i,a =
2

n
Lemma 7 (Shifting Lemma [15]). Let c, x ∈ R( 2 ) where x = (1, 1, . . . , 1).
Then the Neighbor Joining Algorithm applied to c + kx, for any k ∈ R, returns
the same tree as the Neighbor Joining Algorithm applied to c. Moreover, the

15

linear ordering of the Q-criteria of c is the same as the linear ordering of the
Q-criteria of c + kx, i.e. if Qc (i1 , j1 ) ≤ (<) Qc (i2 , j2 ) then Qc+kx (i1 , j1 ) ≤ (<
) Qc+kx (i2 , j2 ).
(n)
Lemma 8. Let c1 , c2 ∈ R+2 where | supp(c1 )| = 1, and (c1 , c2 , P) satisfies the
dominance condition (Equation 4). Further, let c = c1 +c2 , {{p, q}} = supp(c1 ),
and Q−c be the Q-criteria calculated from the dissimilarity map −c.
If n > 4, Q−c (p, q) < Q−c (i, j) for all {i, j} =
6 {p, q}. If n = 4, and p, q, r, s
are the leaves, then Q−c (p, q) = Q−c (r, s) < Q−c (i, j) where {i, j} 6= {p, q} and
{i, j} =
6 {r, s}.
See the appendix for a proof of Lemma 8.
Theorem 3. Let Tb ∈ Tn be the input for Algorithm 1 with output {c1 , . . . , ct }.
The Neighbor Joining Algorithm with input −(c1 + · · · + ct ) returns Tb.
Proof. We proceed by induction on n. If n = 3 we have the star tree and there is
nothing to be done. If n = 4 then Lemma 5 applies to the output of Algorithm 1
and we are done since NJ will return Tb by Lemma 8. Consider n > 4. Let Tb ∈ Tn
be the input for Algorithm 1 with output {c1 , . . . , ct }. Define c = c1 + · · · + ct .
Note also that by Lemma 6, supp(c1 ), . . . , supp(ct ) are pairwise disjoint. We
know Lemma 5 applies and implies by Lemma 4, argmaxT ∈Tn wT · c = {Tb}. Let
{{p, q}} = supp(c1 ) be the first cherry picked in Algorithm 1 and let Q−c be
the Q-criteria of −c. By Lemma 8, Q−c (p, q) is the minimal element in Q−c .

n
Consider the shifted vector d := 1 − n2 c ∈ R( 2 ) , and note that dp,q = 0.
The Shifting Lemma 7 implies that Qd (p, q) will be the minimal element in Qd .
Thus, the NJ Algorithm will join leaves p and q to the new node a. Consider
n−1
the new dissimilarity map d0 ∈ R( 2 ) given by the NJ Algorithm. If i 6= a and
j 6= a then d0i,j = di,j . For i 6= a, d0i,a = 21 (di,p + di,q − dp,q ) = 12 (di,p + di,q ),
since dp,q = 0. Since the cherry {p, q} was designated first by Algorithm 1, by
construction, for all i 6= p and i 6= q, cli,p = cli,q for all 1 < l ≤ t. This implies
(n−1)
d0i,a = di,p = di,q for i 6= a. Define b
c := 1 − d0 and b
c2 , . . . , b
ct ∈ R+ 2 as follows

b
ci,j if {i, j} ∈ supp(cl )
b
cli,j =
0 else
for 2 ≤ l ≤ t. Observe that | supp(b
c2 )| = 1 since b
c2 corresponds to the cherry
picked in the amalgamated tree T2 in Algorithm 1, and p and q have been
identified with a. Moreover, every triple (b
c2 , b
c3 + · · · + b
ct , Pn−1 ), (b
c3 , b
c4 + · · · +
t
t−1
t
b
c , Pn−1 ), . . ., (b
c ,b
c , Pn−1 ) satisfies the dominance condition of Equation 4.
Thus argmaxT ∈Tn b
c · wT = Tb0 for some Tb0 ∈ Tn . Since b
c is a dissimilarity map
on n − 1 leaves, the induction hypothesis holds, and NJ returns Tb0 . Finally Tb0 is
contained in Tb as a clade, which implies NJ on −c will return Tb, since Tb equals
the tree Tb0 with leaves i and j connected to leaf a by two different edges.

16

Given a fixed tree topology, Algorithm 1 allows for any choice of neighbor
joining pairs (cherries in the NJ Algorithm), and every such choice yields a
different NJ cone. Thus, Theorem 3 implies that every NJ cone and BME cone
have a non-empty intersection.
Corollary 2. Every NJ cone C associated to a fixed T ∈ Tn has an intersection
of positive measure with the BME cone associated to T .
Proof. Let T ∈ Tn be a tree topology and C be a NJ cone associated to T ; recall
C is also dependent upon an order of picking cherries. Now apply Algorithm 1
with T as the input (as both the tree and clade), choosing cherries in step 5 by
the order associated to the NJ cone C, and let {c1 , . . P
. , ct } be the output. By
t
Theorem 3, the BME and NJ algorithm with input − i=1 ci will each return
T . Moreover,
Ptsince the cherries were chosen in step 5 to be consistent with C,
we have − i=1 ci ∈ C.
Since the BME cone associated to
PtT is convex (as a normal cone of the
BME polytope), and argminT 0 ∈Tn (− i=1 ci ) = {T } by Lemma 5, it follows
Pt
that − i=1 ci lies in the interior of the BME cone associated to T .
On the other hand, individual NJ cones are convex (by definition, or see
[14]) and the boundary of the intersection of multiple NJ cones associated to the
same tree topology corresponds to two or more cherries having equal Q-scores
(i.e., Q-criteria entries) at some step in the NJ Algorithm [14]. Lemma 8 implies
that the first cherry chosen by the NJ Algorithm will be supp(c1 ), that is, it has
the smallest Q-score with no ties. Moreover, in
proof of Theorem 3 we see
Pthe
t
that the new dissimilarity map derived from − i=1 ci in the NJ Algorithm also
satisfies the dominance condition. Hence, Lemma 8 holds again, and there are
no ties in the Q-score. Therefore, there will be no ties in the Q-score, except for
the case of four taxa. For four taxa, the only ties present are the trivial ones: If
S is the set of four taxa (|S| = 4) then by definition of the Q-score,
Q(p, q) = Q(r, s)

∀ {p, q} ⊆ S, {r, s} = S \ {p, q}.

WePnote that these trivial ties do not correspond to different NJ cones, and hence
t
− i=1 ci lies in the interior of C.
Pt
In conclusion, we see that − i=1 ci lies in the interiors of both the BME
cone and the NJ cone C. This implies they have an intersection of positive
measure.


6

Discussion

Mathematically, “closeness” between trees is measured via differing distances
(metrics) on tree space Tn , including the popular distance measures dN N I (T, T 0 ),
dSP R (T, T 0 ), and dT BR (T, T 0 ) describing the minimum number of nearest neighbor interchange (NNI) (resp., subtree-prune-regrafting (SPR), tree-bisectionregrafting (TBR)) moves needed to transform T to T 0 for T, T 0 ∈ Tn . Each
17

such metric M yields a notion of adjacency, with T, T 0 ∈ Tn being M adjacent if
dM (T, T 0 ) = 1. The comparisons of two trees T, T 0 as NNI, SPR, or TBR adjacent
confers useful biological information, including providing the basis for multiple
tree reconstruction algorithms [3, 23–25]. For T, T 0 ∈ Tn , set dBM E (T, T 0 ) = 1
0
if wT and wT are two vertices joined by an edge in the BME polytope Pn . This
yields another notion of adjacency in the BME setting.
The point of view of this paper is that knowledge of BME adjacency, and
its relationship to NJ adjacency, has likewise the potential to inform our understanding of tree space Tn , and the gene and/or species trees its elements
represent. We have explored some relationships between adjacency for M =
NNI, SPR, TBR, BME, and NJ. It is well-known that an NNI move is a special
case of an SPR move and an SPR move is a special case of a TBR move. In this
paper, we have shown that SPR adjacency implies BME adjacency. However it
is not known that TBR adjacency implies BME adjacency. We have made some
initial explorations in this regard, including using an additional related notion
of “circular adjacency” predicated upon the circular orderings employed in [25].
However, having seen no examples to show that TBR adjacency fails to imply
BME adjacency, we propose the following conjecture.
Conjecture 1. If T, T 0 ∈ Tn , then dT BR (T, T 0 ) = 1 implies dBM E (T, T 0 ) = 1.
Considering further the potential applications of such adjacency notions in the
context of the BME polytopes and BME cones is a topic we hope to explore in
a future work.

7

Acknowledgments

D. Haws and R. Yoshida are supported by NIH R01 grant 5R01GM086888. T.
Hodge is supported by NSF (DUE) grant 0737467. The authors would like to
thank P. Huggins for all his helpful discussions, C. Segroves for directing us to
a useful reference, and M. Cueto for pointing out a typo in the manuscript. The
authors would also like to thank the referees for detailed critiques and multiple
suggestions for improving the paper.

18

Bibliography

[1] 2010. Tree of Life web project. URL http://tolweb.org/tree/.
[2] Bandelt, H. and Dress, A. W. 1992. A canonical decomposition theory for
metrics on a finite set. Advances in Mathematics 92:47–105.
[3] Bonet, M. L. and St. John, K., 2009. Efficiently calculating evolutionary
tree measures using sat. Twelfth International Conference on Theory and
Applications of Satisfiability Testing (SAT 09).
[4] Bordewich, M., Gascuel, O., Huber, K., and Moulton, V. 2009. Consistency
of topological moves based on the balanced minimum evolution principle of
phylogenetic inference. IEEE/ACM Trans. Comput. Biology Bioinform.
6:110–117.
[5] Bryant, D. 2005. On the uniqueness of the selection criterion in neighborjoining. J. Classif. 22:3–15.
[6] Buneman, P., 1971. The recovery of trees from measures of similarity. Pages
387–395 in F. Hodson, D. Kendall, and P. Tautu, eds. Mathematics of the
Archaeological and Historical Sciences. Edinburgh University Press, Edinburgh.
[7] Ciccarelli, F. D., Doerks, T., von Mering, C., Creevey, C. J., Snel, B., and
Bork, P. 2006. Toward automatic reconstruction of a highly resolved tree
of life. Science 311:1283 – 1287.
[8] Cueto, M. A. and Matsen, F. A., 2010. Polyhedral geometry of phylogenetic
rogue taxa. preprint, arXiv:1001.5241.
[9] Day, W. 1987. Computational complexity of inferring phylogenies from
dissimilarity matrices. Bulletin of Mathematical Biology 49:461–467.
[10] DeBry, R. W. 1992. The consistency of several phylogeny-inference methods
under varying evolutionary rates. Mol Biol Evol 9:537–551.
[11] Denis, F. and Gascuel, O. 2003. On the consistency of the minimum evolution principle of phylogenetic inference. Discrete Applied Mathematics
127:63–77.
[12] Desper, R. and Gascuel, O. 2002. Fast and accurate phylogeny reconstruction algorithms based on the minimum-evolution principle. Journal of
Computational Biology Pages 687–705.
[13] Desper, R. and Gascuel, O. 2004. Theoretical foundation of the balanced
minimum evolution method of phylogenetic inference and its relationship
to weighted least-squares tree fitting. Mol. Biol. Evol. 21:587–598.
[14] Eickmeyer, K., Huggins, P., Pachter, L., and Yoshida, R. 2008. On the optimality of the neighbor-joining algorithm. Algorithms for Molecular Biology
3.
[15] Eickmeyer, K. and Yoshida, R. 2008. The geometry of the neighbor-joining
algorithm for small trees. Lecture Notes in Computer Science 5147:81–95.
[16] Felsenstein, J. 1978. Cases in which parsimony and compatibility methods
will be positively misleading. Syst. Zool. 27:401–410.
[17] Felsenstein, J., 2003. Inferring Phylogenies. Sinauer Associates, Inc.

[18] Gascuel, O. and Steel, M. 2006. Neighbor-joining revealed. Molecular
Biology and Evolution 23:1997–2000.
[19] Pauplin, Y. 2000. Direct calculation of a tree length using a distance matrix.
J. Mol. Evol. 51:41–47.
[20] Roch, S. 2004. A short proof that phylogenetic tree reconstruction by maximum likelihood is hard. IEEE/ACM Trans. Comput. Biology Bioinform.
3:92–94.
[21] Saitou, N. and Nei, M. 1987. The neighbor joining method: a new method
for reconstructing phylogenetic trees. Molecular Biology and Evolution
4:406–425.
[22] Schrijver, A., 1986. Theory of Linear and Integer Programming. John Wiley
& Sons, Inc., New York, NY, USA.
[23] Semple, C. and Steel, M., 2003. Phylogenetics, volume 24 of Oxford Lecture Series in Mathematics and its Applications. Oxford University Press,
Oxford. ISBN 0-19-850942-1.
[24] Steel, M. and Penny, D. 1993. Distributions of tree comparison metrics-some
new results. Syst. Biol. 42:126–141.
[25] Steel, M. and Semple, C. 2004. Cyclic permutations and evolutionary trees.
Advances in Applied Mathematics Pages 669–80.
[26] Studier, J. A. and Keppler, K. J. 1988. A note on the neighbor-joining
method of Saitou and Nei. Molecular Biology and Evolution 5:729–731.

A

Appendix

Proof (Lemma 2).
The proof of the lemma relies almost entirely on the proof in [13] of the consistency of the BME method for phylogenetic tree reconstruction ([13, Theorem
2 and Appendix 3]]). Given T ∈ Tn with edge-weighting ω, recall the notation
of Section 2.1 and 2.3. Furthermore, from Equations (1) and (2), for any tree
T 0 ∈ Tn one can obtain the estimated BME length of T 0 as a linear function of
the metric D := DT,ω as
X
0
l(T 0 , D) = wT · D =
ω(A | B)l(T 0 , DA | B )
(6)
A | B∈Σ(T )

By the consistency of the BME tree length estimation, l(T, D) = l(T ) =
ω(T ). So, for the proof of the consistency of the BME method it sufficed for [13]
to demonstrate that l(W, D) > l(T, D) for all W ∈ Tn with W 6= T. By Equation
(6), it was enough to prove this inequality holds for any split metric DA | B of T
in place of D. Likewise, for our proof of Lemma 2, we consider the tree T ∈ Tn
such that C1 , . . . , Cp ∈ T . Furthermore, we take an edge-weighting ω of T for
which ω(e) = 0 if e ∈
/ Ci , for all 1 ≤ i ≤ p. We will show that if W ∈ Tn contains
C1 , . . . , Cp then l(W, D) = l(T, D). Otherwise if Ci ∈
/ W for some 1 ≤ i ≤ p,
then we show l(W, D) > l(T, D). Both parts proceed by reducing to the case of
split metrics DA | B for T , and drawing upon the results in [13].
20

Consider W ∈ Tn such that C1 , . . . , Cp ∈ W . Since Ci ∈ W, T for all 1 ≤ i ≤
p, Σ(W ) ∩ Σ(T ) contains any split A | B induced by any edge e ∈ C1 , . . . , Cp . As
shown in [13] (by direct calculations using the definition of the BME branch
lengths l), if a split A | B is both in Σ(T ) and Σ(W ) then l(W, DA | B ) =
l(T, DA | B ) = 1. If W 6= T then there exist some split A | B in Σ(T ) but not in
Σ(W ), and ω(A | B) = 0. Thus l(W, D) = l(T, D). Now consider W ∈ Tn such
that Ci ∈
/ W for some 1 ≤ i ≤ p. As above, there exists some split A | B in Σ(T )
and not in Σ(W ), and moreover ω(A | B) > 0. Under these circumstances, the
argument in the (remainder of the) proof of Theorem 2 of [13] applies to show
l(W, DA | B ) > l(T, DA | B ), which suffices to complete the proof of Lemma 2.

Proof (Proposition 1). Let a, b ∈ vert(P) and suppose a ∈ argmax z · c1 63 b.
z∈vert(P)

Thus a · c1 > b · c1 . Then
a · (c1 + c2 ) − b · (c1 + c2 ) = a · c1 − b · c1 + a · c2 − b · c2
≥

min
x,y∈vert(P)
x∈argmaxz∈P c1 ·z
c1 ·x6=c1 ·y

c1 · x − c1 · y + a · c2 − b · c2 > 0,

since
min
x,y∈vert(P)
x∈argmaxz∈P c1 ·z
c1 ·x6=c1 ·y

c1 · x − c1 · y >

max
x,y∈vert(P)

|c2 · x − c2 · y|.

Thus b ∈
/ argmax (c1 + c2 ) · z and therefore
z∈vert(P)

argmax (c1 + c2 ) · z ⊆ argmax c1 · z.
z∈vert(P)

z∈vert(P)


n
2

Proof (Lemma 3). Let d ∈ R( ) be the normal vector of the face F . Let i be a
leaf of clade C1 and j a leaf of clade C2 . Now apply Proposition 1 as follows:
There exists ε > 0 sufficiently small such that
d·x−d·y >

min
x,y∈vert(Pn )
x∈argmaxz∈Pn z·d
d·x6=d·y

max
x,y∈vert(Pn )

|ε(−eij ) · x − ε(−eij ) · y|.

Therefore
argmax wT · (d − εeij ) = argmax wT · (−εeij )
T ∈Tn

T ∈vert(F )

which are precisely all trees contained in vert(F ) such that clades C1 , C2 are
farthest apart. To show there exists an objective corresponding to a face contained in vert(F ) such that clades C1 , C2 are close as possible, simply change
−eij to eij .
21



Proof (Lemma 4). Consider the left-hand side of the inequality in Equation 3
applied to c1 , c2 and Pn :

min

T 00 ,T 0 ∈Pn
T 00 ∈argmaxT ∈Tn c1 ·wT
00

c1 ·wT >c1 ·wT

First note that

1
2n−2

T
≤ wij
≤


00

X

K

0

T
T 
(wij
− wij
) .

(7)

{i,j}∈supp(c1 )

0

1
2

for all T ∈ Tn and all {i, j}. Thus,
00

X

2n−2

0

T
T
(wij
− wij
)

{i,j}∈supp(c1 )

will be integral and greater than 0. This implies that
X

00

0

T
T
(wij
− wij
)≥

{i,j}∈supp(c1 )

1
2n−2

.

Hence the expression in Equation 7 will be greater than or equal to
T
the bounds on wij
for all T and {i, j}, and the triangle inequality,

K
2n−2 .

Using

00
0
1 2
c · (1, 1, . . . , 1) ≥ 0 max
|c2 · wT − c2 · wT |.
T ,T 00 ∈Tn
2

Therefore if Equation 4 holds then Proposition 1 holds, completing the proof of
Lemma 4.



b of Tb be the input of Algorithm 1 with
Proof (Lemma 5). Let Tb ∈ Tn and clade C
output c1 , c2 , . . . , ct . Moreover, let K1 , K2 , . . . , Kt be the ordered list of Ki used.
1 Kr
Let 1 ≤ r < t and from Step 10 in Algorithm 1 we see that Kr+l < 21l 2n−2
(n2 )
for 1 ≤ l ≤ t − r.
22

Then

1 r+1
c
+ cr+2 + · · · + ct · (1, 1, . . . , 1)
2


X
X
X
1
r+1
r+2
ci,j +
ci,j + · · · +
cti,j 
=
2
t
r+1
r+2
{i,j}∈supp(c )
{i,j}∈supp(c
)
{i,j}∈supp(c
)


X
X
X
1
Kr+1
Kr+2
Kt 
 +
 + ··· +

=
n
n
n
2
t
r+2
r+1
2
2
2
{i,j}∈supp(c

)

{i,j}∈supp(c

)

{i,j}∈supp(c )

1
< (Kr+1 + · · · + Kt )
2
!
1 1 Kr
1
1 1 1 Kr
1 Kr
 + 2 n−2 n + · · · + t−r n−2 n
<
2 2 2n−2 n2
2 2
2
2
2
2


crij
1
1
Kr
1 1 Kr 1
+ 2 + · · · + t−r < n n−2 = n−2
= n−2 n
22
2 2
2
2
2
2 2
for {i, j} ∈ supp(cr ). Thus (cr , cr+1 +· · ·+ct , Pn ) satisfies the dominance condition for 1 ≤ r < t and Lemma 4 applies. Therefore argmaxT ∈Tn (cr+1 + · · · + ct ) ·
wT ⊆ argmaxT ∈T cr · wT . Altogether this implies that argmaxT ∈Tn (c1 + · · · +
ct ) · wT is the set of trees where, and in this order, c1 · wT is maximized, c2 · wT
is maximized, . . ., ct · wT is maximized. But this recursive linear optimization
of c1 , . . . , ct over Pn precisely forces the amalgamation of cherries determined
in Algorithm 1.

Proof (Lemma 6).
Suppose not. That is, for some 1 ≤ i < j ≤ t and some 1 ≤ k ≤ l ≤ n, assume
cikl > 0 and cjkl > 0. Since i < j this implies leaves k and l are contained in two
separate leaves of Ti in Algorithm 1. Moreover since cikl > 0, this implies the
leaves of Ti that contained k and l were amalgamated, giving Ti+1 . Thus, leaves
k and l will never appear in separate leaves of Tr for any r > i. But, cjkl > 0,
implying k and l appear in separate leaves of Tj , a contradiction.


n
2

( )
Proof ( Lemma 8). Let c1 , c2 ∈ R+ where | supp(c1 )| = 1, and (c1 , c2 , P) satisfies the dominance condition (Equation 4). Further, let c = c1 + c2 , {p, q} =
supp(c1 ), and Q−c (i, j) be the Q-criteria calculated from the dissimilarity map
−c. If n = 4, and p, q, r, s are the leaves, then we see directly that Q−c (p, q) =
Q−c (r, s). Moreover c1p,q appears in Q−c (p, r), Q−c (q, s), Q−c (p, s), Q−c (q, r), and
not in Q−c (p, q)and Q−c (r, s). The dominance condition implies Q−c (p, q) =
Q−c (r, s) < min Q−c (p, r), Q−c (q, s), Q−c (p, s), Q−c (q, r) .
23

Now consider n > 4. Since (c1 , c2 , P) satisfies the dominance condition, it
follows that




X
c1p,q
cp,q
1 X
1
= n−2 >
c2i,j  = 
ci,j 
⇒
2n−2
2
2
2
1≤i<j≤n

1
cp,q >
2

X

{i,j}6={p,q}

⇔

ci,j

{i,j}6={p,q}

1
− cp,q > −cp,q +
2

X

ci,j .

{i,j}6={p,q}

This implies
Q−c (p, q) = −(n − 4)cp,q +

X

cp,k +

k6=q

X
k6=p

1
ck,q < −(n − 5)cp,q − cp,q .
2

Furthermore, 21 cp,q > ci,j for all {i, j} =
6 {p, q}, since the dominance condition
is satisfied. Finally
1
Q−c (p, q) < −(n − 5)cp,q − cp,q < −(n − 5)ci,j − ci,j = −(n − 4)ci,j ≤ Q−c (i, j).
2


24

