The neural ring: an algebraic tool for analyzing
the intrinsic structure of neural codes
Carina Curto, Vladimir Itskov, Alan Veliz-Cuba, Nora Youngs

arXiv:1212.4201v2 [q-bio.NC] 21 May 2013

Department of Mathematics, University of Nebraska-Lincoln
May 21, 2013

Abstract
Neurons in the brain represent external stimuli via neural codes. These codes often arise from
stereotyped stimulus-response maps, associating to each neuron a convex receptive field. An important problem confronted by the brain is to infer properties of a represented stimulus space
without knowledge of the receptive fields, using only the intrinsic structure of the neural code. How
does the brain do this? To address this question, it is important to determine what stimulus space
features can – in principle – be extracted from neural codes. This motivates us to define the neural
ring and a related neural ideal, algebraic objects that encode the full combinatorial data of a neural
code. Our main finding is that these objects can be expressed in a “canonical form” that directly
translates to a minimal description of the receptive field structure intrinsic to the code. We also
find connections to Stanley-Reisner rings, and use ideas similar to those in the theory of monomial ideals to obtain an algorithm for computing the primary decomposition of pseudo-monomial
ideals. This allows us to algorithmically extract the canonical form associated to any neural code,
providing the groundwork for inferring stimulus space features from neural activity alone.

Contents
1 Introduction

2

2 Background & Motivation
2.1 Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 Receptive field codes (RF codes) . . . . . . . . . . . . . . . . . . . .
2.3 Stimulus space constraints arising from convex RF codes . . . . . . .
2.3.1 Helly’s theorem and the Nerve theorem . . . . . . . . . . . .
2.3.2 Beyond the simplicial complex of the neural code . . . . . . .
2.3.3 The receptive field structure (RF structure) of a neural code

4
4
5
6
7
7
8

1

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

3 Neural rings and ideals
3.1 Basic algebraic geometry background . . . . . . . . .
3.2 Definition of the neural ring . . . . . . . . . . . . . .
3.3 The spectrum of the neural ring . . . . . . . . . . . .
3.4 The neural ideal & an explicit set of relations for the

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

9
9
10
10
10

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

11
11
12
13
15
15
17

5 Primary decomposition
5.1 Primary decomposition of the neural ideal . . . . . . . . . . . . . . . . . . . . . . . . .
5.2 Decomposing the neural code via intervals of the Boolean lattice . . . . . . . . . . . .
5.3 An algorithm for primary decomposition of pseudo-monomial ideals . . . . . . . . . .

18
18
20
21

6 Appendix 1: Proofs
6.1 Proof of Lemmas 3.1 and 3.2
6.2 Proof of Theorem 4.1 . . . . .
6.3 Proof of Theorem 4.3 . . . . .
6.4 Proof of Proposition 4.5 . . .
6.5 Proof of Lemmas 5.8 and 5.9
6.6 Proof of Theorem 5.4 . . . . .

24
24
25
26
28
29
30

. . . .
. . . .
. . . .
neural

. . .
. . .
. . .
ring

4 How to infer RF structure using the neural ideal
4.1 An alternative set of relations for the neural ring . . . . . . . .
4.2 Interpreting neural ring relations as receptive field relationships
4.3 Pseudo-monomials & a canonical form for the neural ideal . . .
4.4 Comparison to the Stanley-Reisner ideal . . . . . . . . . . . . .
4.5 An algorithm for obtaining the canonical form . . . . . . . . .
4.6 An example . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

7 Appendix 2: Neural codes on three neurons

1

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

31

Introduction

Building accurate representations of the world is one of the basic functions of the brain. It is wellknown that when a stimulus is paired with pleasure or pain, an animal quickly learns the association.
Animals also learn, however, the (neutral) relationships between stimuli of the same type. For example,
a bar held at a 45-degree angle appears more similar to one held at 50 degrees than to a perfectly
vertical one. Upon hearing a triple of distinct pure tones, one seems to fall “in between” the other
two. An explored environment is perceived not as a collection of disjoint physical locations, but as a
spatial map. In summary, we do not experience the world as a stream of unrelated stimuli; rather,
our brains organize different types of stimuli into highly structured stimulus spaces.
The relationship between neural activity and stimulus space structure has, nonetheless, received
remarkably little attention. In the field of neural coding, much has been learned about the coding
properties of individual neurons by investigating stimulus-response functions, such as place fields [1, 2],
orientation tuning curves [3, 4], and other examples of “receptive fields” obtained by measuring neural
activity in response to experimentally-controlled stimuli. Moreover, numerous studies have shown that
2

neural activity, together with knowledge of the appropriate stimulus-response functions, can be used
to accurately estimate a newly presented stimulus [5, 6, 7]. This paradigm is being actively extended
and revised to include information present in populations of neurons, spurring debates on the role of
correlations in neural coding [8, 9, 10]. In each case, however, the underlying structure of the stimulus
space is assumed to be known, and is not treated as itself emerging from the activity of neurons.
This approach is particularly problematic when one considers that the brain does not have access to
stimulus-response functions, and must represent the world without the aid of dictionaries that lend
meaning to neural activity [11]. In coding theory parlance, the brain does not have access to the
encoding map, and must therefore represent stimulus spaces via the intrinsic structure of the neural
code.
How does the brain do this? In order to eventually answer this question, we must first tackle a
simpler one:
Question: What can be inferred about the underlying stimulus space from neural activity alone? I.e.,
what stimulus space features are encoded in the intrinsic structure of the neural code, and can thus
be extracted without knowing the individual stimulus-response functions?
Recently we have shown that, in the case of hippocampal place cell codes, certain topological features
of the animal’s environment can be inferred from the neural code alone, without knowing the place
fields [11]. As will be explained in the next section, this information can be extracted from a simplicial
complex associated to the neural code. What other stimulus space features can be inferred from the
neural code? For this, we turn to algebraic geometry. Algebraic geometry provides a useful framework
for inferring geometric and topological characteristics of spaces by associating rings of functions to
these spaces. All relevant features of the underlying space are encoded in the intrinsic structure of
the ring, where coordinate functions become indeterminates, and the space itself is defined in terms
of ideals in the ring. Inferring features of a space from properties of functions – without specified
domains – is similar to the task confronted by the brain, so it is natural to expect that this framework
may shed light on our question.
In this article we introduce the neural ring, an algebro-geometric object that can be associated to
any combinatorial neural code. Much like the simplicial complex of a code, the neural ring encodes
information about the underlying stimulus space in a way that discards specific knowledge of receptive
field maps, and thus gets closer to the essence of how the brain might represent stimulus spaces. Unlike
the simplicial complex, the neural ring retains the full combinatorial data of a neural code, packaging
this data in a more computationally tractable manner. We find that this object, together with a
closely related neural ideal, can be used to algorithmically extract a compact, minimal description of
the receptive field structure dictated by the code. This enables us to more directly tie combinatorial
properties of neural codes to features of the underlying stimulus space, a critical step towards answering
our motivating question.
Although the use of an algebraic construction such as the neural ring is quite novel in the context
of neuroscience, the neural code (as we define it) is at its core a combinatorial object, and there
is a rich tradition of associating algebraic objects to combinatorial ones [12]. The most well-known
example is perhaps the Stanley-Reisner ring [13], which turns out to be closely related to the neural
ring. Within mathematical biology, associating polynomial ideals to combinatorial data has also been
fruitful. Recent examples include inferring wiring diagrams in gene-regulatory networks [14, 15] and
applications to chemical reaction networks [16]. Our work also has parallels to the study of design
ideals in algebraic statistics [17].
The organization of this paper is as follows. In Section 2 we introduce receptive field codes, and ex3

plore how the requirement of convexity enables these codes to constrain the structure of the underlying
stimulus space. In Section 3 we define the neural ring and the neural ideal, and find explicit relations
that enable us to compute these objects for any neural code. Section 4 is the heart of this paper. Here
we present an alternative set of relations for the neural ring, and demonstrate how they enable us to
“read off” receptive field structure from the neural ideal. We then introduce pseudo-monomials and
pseudo-monomial ideals, by analogy to monomial ideals; this allows us to define a natural “canonical
form” for the neural ideal. Using this, we can extract minimal relationships among receptive fields
that are dictated by the structure of the neural code. Finally, we present an algorithm for finding the
canonical form of a neural ideal, and illustrate how to use our formalism for inferring receptive field
structure in a detailed example. Section 5 describes the primary decomposition of the neural ideal
and, more generally, of pseudo-monomial ideals. Computing the primary decomposition of the neural
ideal is a critical step in our canonical form algorithm, and it also yields a natural decomposition of
the neural code in terms of intervals of the Boolean lattice. We end this section with an algorithm
for finding the primary decomposition of any pseudo-monomial ideal, using ideas similar to those in
the theory of square-free monomial ideals. All longer proofs can be found in Appendix 1. A detailed
classification of neural codes on three neurons is given in Appendix 2.

2
2.1

Background & Motivation
Preliminaries

In this section we introduce the basic objects of study: neural codes, receptive field codes, and convex
receptive field codes. We then discuss various ways in which the structure of a convex receptive field
code can constrain the underlying stimulus space. These constraints emerge most obviously from
the simplicial complex of a neural code, but (as will be made clear) there are also constraints that
arise from aspects of a neural code’s structure that go well beyond what is captured by the simplicial
complex of the code.
def
Given a set of neurons labelled {1, . . . , n} = [n], we define a neural code C ⊂ {0, 1}n as a set of
binary patterns of neural activity. An element of a neural code is called a codeword, c = (c1 , . . . , cn ) ∈ C,
and corresponds to a subset of neurons
def

supp(c) = {i ∈ [n] | ci = 1} ⊂ [n].
Similarly, the entire code C can be identified with a set of subsets of neurons,
def

supp C = {supp(c) | c ∈ C} ⊂ 2[n] ,
where 2[n] denotes the set of all subsets of [n]. Because we discard the details of the precise timing
and/or rate of neural activity, what we mean by neural code is often referred to in the neural coding
literature as a combinatorial code [18, 19].
A set of subsets ∆ ⊂ 2[n] is an (abstract) simplicial complex if σ ∈ ∆ and τ ⊂ σ implies τ ∈ ∆.
We will say that a neural code C is a simplicial complex if supp C is a simplicial complex. In cases
where the code is not a simplicial complex, we can complete the code to a simplicial complex by simply
adding in missing subsets of codewords. This allows us to define the simplicial complex of the code as
def

∆(C) = {σ ⊂ [n] | σ ⊆ supp(c) for some c ∈ C}.
Clearly, ∆(C) is the smallest simplicial complex that contains supp C.
4

2.2

Receptive field codes (RF codes)

Neurons in many brain areas have activity patterns that can be characterized by receptive fields.1
Abstractly, a receptive field is a map fi : X → R≥0 from a space of stimuli, X, to the average firing
rate of a single neuron, i, in response to each stimulus. Receptive fields are computed by correlating
neural responses to independently measured external stimuli. We follow a common abuse of language,
where both the map and its support (i.e., the subset Ui ⊂ X where fi takes on positive values) are
referred to as “receptive fields.” Convex receptive fields are convex2 subsets of the stimulus space,
for X ⊂ Rd . The paradigmatic examples are orientation-selective neurons in visual cortex [3, 4] and
hippocampal place cells [1, 2]. Orientation-selective neurons have tuning curves that reflect a neuron’s
preference for a particular angle (see Figure 1A). Place cells are neurons that have place fields; i.e.,
each neuron has a preferred (convex) region of the animal’s physical environment where it has a high
firing rate (see Figure 1B). Both tuning curves and place fields are examples of receptive fields.
A

1 2

3

4

B

5

4
1

5

2

activity pattern
codeword 1 1 1 0 0

3

activity pattern
codeword 0 0 1 0 1

Figure 1: Receptive field overlaps determine codewords in 1D and 2D RF codes. (A) Neurons in a 1D RF code
have receptive fields that overlap on a line segment (or circle, in the case of orientation-tuning). Each stimulus
on the line corresponds to a binary codeword. Gaussians depict graded firing rates for neural responses; this
additional information is discarded by the RF code. (B) Neurons in a 2D RF code, such as a place field code,
have receptive fields that partition a two-dimensional stimulus space into non-overlapping regions, as illustrated
by the shaded area. All stimuli within one of these regions will activate the same set of neurons, and hence have
the same corresponding codeword.

A receptive field code (RF code) is a neural code that corresponds to the brain’s representation of
the stimulus space covered by the receptive fields. When a stimulus lies in the intersection of several
receptive fields, the corresponding neurons may co-fire while the rest remain silent. The active subset
σ of neurons can be identified with a binary codeword c ∈ {0, 1}n via σ = supp(c). Unless otherwise
noted, a stimulus space X need only be a topological space. However, we usually have in mind X ⊂ Rd ,
and this becomes important when we consider convex RF codes.
Definition. Let X be a stimulus space (e.g., X ⊂ Rd ), and let U = {U1 , . . . , Un } be a collection
of open sets, with each Ui ⊂ X the receptive field of the i-th neuron in a population of n neurons.
The receptive field code (RF code) C(U) ⊂ {0, 1}n is the set of all binary codewords corresponding to
stimuli in X:
\
[
def
C(U) = {c ∈ {0, 1}n | (
Ui ) \ (
Uj ) 6= ∅}.
i∈supp(c)
1

j ∈supp(c)
/

In the vision literature, the term “receptive field” is reserved for subsets of the visual field; we use the term in a
more general sense, applicable to any modality.
2
A subset B ⊂ Rn is convex if, given any pair of points x, y ∈ B, the point z = tx + (1 − t)y is contained in B for any
t ∈ [0, 1].

5

If X ⊂ Rd and each of the Ui s is also a convex subset of X, then we say that C(U) is a convex RF
code.
T
S
Our convention is that the empty intersection is i∈∅ Ui = X, and the empty union is i∈∅ Ui = ∅.
S
This means that if ni=1 Ui ( X, then C(U) includes the all-zeros codeword corresponding to an
T
“outside” point not covered by the receptive fields; on the other hand, if ni=1 Ui 6= ∅, then C(U)
includes the all-ones codeword. Figure 1 shows examples of convex receptive fields covering one- and
two-dimensional stimulus spaces, and examples of codewords corresponding to regions defined by the
receptive fields.
Returning to our discussion in the Introduction, we have the following question: If we can assume
C = C(U) is a RF code, then what can be learned about the underlying stimulus space X from knowledge
only of C, and not of U? The answer to this question will depend critically on whether or not we can
assume that the RF code is convex. In particular, if we don’t assume convexity of the receptive fields,
then any code can be realized as a RF code in any dimension.
Lemma 2.1. Let C ⊂ {0, 1}n be a neural code. Then, for any d ≥ 1, there exists a stimulus space
X ⊂ Rd and a collection of open sets U = {U1 , . . . , Un } (not necessarily convex), with Ui ⊂ X for each
i ∈ [n], such that C = C(U).
Proof. Let C ⊂ {0, 1}n be any neural code, and order the elements of C as {c1 , . . . , cm }, where m = |C|.
For each c ∈ C, choose a distinct point xc ∈ Rd and an open neighborhood Nc of xc such that no
S
def S
two neighborhoods intersect. Define Uj = j∈supp(ck ) Nck , let U = {U1 , . . . , Un }, and X = m
i=1 Nci .
Sn
Observe that if the all-zeros codeword is in C, then N0 = X \ i=1 Ui corresponds to the “outside
point” not covered by any of the Ui s. By construction, C = C(U).
Although any neural code C ⊆ {0, 1}n can be realized as a RF code, it is not true that any code
can be realized as a convex RF code. Counterexamples can be found in codes having as few as three
neurons.
Lemma 2.2. The neural code C = {0, 1}3 \ {111, 001} on three neurons cannot be realized as a convex
RF code.
U1

U2

U1

U2

p2
p1
Proof. Assume the converse, and let U = {U1 , U2 , U3 } be a set of
d
convex open sets in R such that C = C(U). The code necessitates
p2
p1
that U1 ∩U2 6= ∅ (since 110 ∈ C), (U1 ∩U3 )\U2 6= ∅ (since 101 ∈ C),
and (U2 ∩ U3 ) \ U1 6= ∅ (since 011 ∈ C). Let p1 ∈ (U1 ∩ U3 ) \ U2 and
p2 ∈ (U2 ∩ U3 ) \ U1 . Since p1 , p2 ∈ U3 and U3 is convex, the line Figure 2: Two cases in the proof of
segment ` = (1 − t)p1 + tp2 for t ∈ [0, 1] must also be contained in Lemma 2.2.
U3 . There are just two possibilities. Case 1: ` passes through U1 ∩ U2 (see Figure 2, left). This implies
U1 ∩ U2 ∩ U3 6= ∅, and hence 111 ∈ C, a contradiction. Case 2: ` does not intersect U1 ∩ U2 . Since
U1 , U2 are open sets, this implies ` passes outside of U1 ∪ U2 (see Figure 2, right), and hence 001 ∈ C,
a contradiction.

2.3

Stimulus space constraints arising from convex RF codes

It is clear from Lemma 2.1 that there is essentially no constraint on the stimulus space for realizing a
code as a RF code. However, if we demand that C is a convex RF code, then the overlap structure of
the Ui s sharply constrains the geometric and topological properties of the underlying stimulus space
6

X. To see how this works, we first consider the simplicial complex of a neural code, ∆(C). Classical
results in convex geometry and topology provide constraints on the underlying stimulus space X for
convex RF codes, based on the structure of ∆(C). We will discuss these next. We then turn to
the question of constraints that arise from combinatorial properties of a neural code C that are not
captured by ∆(C).
2.3.1

Helly’s theorem and the Nerve theorem

Here we briefly review two classical and well-known theorems in convex geometry and topology, Helly’s
theorem and the Nerve theorem, as they apply to convex RF codes. Both theorems can be used to
relate the structure of the simplicial complex of a code, ∆(C), to topological features of the underlying
stimulus space X.
Suppose U = {U1 , . . . , Un } is a finite collection of convex open subsets of Rd , with dimension d < n.
We can associate to U a simplicial complex N (U) called the nerve of U. A subset {i1 , .., ik } ⊂ [n]
T
belongs to N (U) if and only if the appropriate intersection k`=1 Ui` is nonempty. If we think of the
Ui s as receptive fields, then N (U) = ∆(C(U)). In other words, the nerve of the cover corresponds to
the simplicial complex of the associated (convex) RF code.
Helly’s theorem. Consider k convex subsets, U1 , . . . , Uk ⊂ Rd , for d < k. If the intersection of every
T
d + 1 of these sets is nonempty, then the full intersection ki=1 Ui is also nonempty.
A nice exposition of this theorem and its consequences can be found in [20]. One straightforward
consequence is that the nerve N (U) is completely determined by its d-skeleton, and corresponds to
the largest simplicial complex with that d-skeleton. For example, if d = 1, then N (U) is a clique
complex (fully determined by its underlying graph). Since N (U) = ∆(C(U)), Helly’s theorem imposes
constraints on the minimal dimension of the stimulus space X when C = C(U) is assumed to be a
convex RF code.
def S
Nerve theorem. The homotopy type of X(U) = ni=1 Ui is equal to the homotopy type of the nerve
of the cover, N (U). In particular, X(U) and N (U) have exactly the same homology groups.
The Nerve theorem is an easy consequence of [21, Corollary 4G.3]. This is a powerful theorem relating
the simplicial complex of a RF code, ∆(C(U)) = N (U), to topological features of the underlying space,
such as homology groups and other homotopy invariants. Note, however, that the similarities between
X(U) and N (U) only go so far. In particular, X(U) and N (U) typically have very different dimension.
S
It is also important to keep in mind that the Nerve theorem concerns the topology of X(U) = ni=1 Ui .
Sn
In our setup, if the stimulus space X is larger, so that i=1 Ui ( X, then the Nerve theorem tells us
only about the homotopy type of X(U), not of X. Since the Ui are open sets, however, conclusions
about the dimension of X can still be inferred.
In addition to Helly’s theorem and the Nerve theorem, there is a great deal known about ∆(C(U)) =
N (U) for collections of convex sets in Rd . In particular, the f -vectors of such simplicial complexes
have been completely characterized by G. Kalai in [22, 23].
2.3.2

Beyond the simplicial complex of the neural code

We have just seen how the simplicial complex of a neural code, ∆(C), yields constraints on the stimulus
space X if we assume C can be realized as a convex RF code. The example described in Lemma 2.2,
however, implies that other kinds of constraints on X may emerge from the combinatorial structure
of a neural code, even if there is no obstruction stemming from ∆(C).
7

A
B
In Figure 3 we show four possible arrange3
1
2
ments of three convex receptive fields in the
plane. Each convex RF code has the same corre1
2
sponding simplicial complex ∆(C) = 2[3] , since
3
111 ∈ C for each code. Nevertheless, the arrangements clearly have different combinatorial
properties. In Figure 3C, for instance, we have
D
C
U1 ⊂ U2 ⊂ U3 , while Figure 3A has no spe3
1
2
2
cial containment relationships among the recep3
1
tive fields. This “receptive field structure” (RF
structure) of the code has impliciations for the
underlying stimulus space.
Let d be the minimal integer for which the
Figure 3: Four arrangements of three convex receptive
code can be realized as a convex RF code in Rd ; fields, U = {U , U , U }, each having ∆(C(U)) = 2[3] .
1
2
3
we will refer to this as the minimal embedding Square boxes denote the stimulus space X in cases where
dimension of C. Note that the codes in Figure U1 ∪U2 ∪U3 ( X. (A) C(U) = 2[3] , including the all-zeros
3A,D have d = 2, whereas the codes in Figure codeword 000. (B) C(U) = {111, 101, 011, 001}, with
3B,C have d = 1. The simplicial complex, ∆(C), X = U3 . (C) C(U) = {111, 011, 001, 000}. (D) C(U) =
is thus not sufficient to determine the minimal {111, 101, 011, 110, 100, 010}, and X = U1 ∪ U2 . The
minimal embedding dimension for the codes in panels A
embedding dimension of a convex RF code, but
and D is d = 2, while for panels B and C it is d = 1.
this information is somehow present in the RF
structure of the code. Similarly, in Lemma 2.2 we saw that ∆(C) does not provide sufficient information
to determine whether or not C can be realized as a convex RF code; after working out the RF structure,
however, it was easy to see that the given code was not realizable.

2.3.3

The receptive field structure (RF structure) of a neural code

As we have just seen, the intrinsic structure of a neural code contains information about the underlying
stimulus space that cannot be inferred from the simplicial complex of the code alone. This information
is, however, present in what we have loosely referred to as the “RF structure” of the code. We now
explain more carefully what we mean by this term.
Given a set of receptive fields U = {U1 , . . . , Un } in a stimulus space X, there are certain containment
relations between intersections and unions of the Ui s that are “obvious,” and carry no information
about the particular arrangement in question. For example, U1 ∩U2 ⊆ U2 ∪U3 ∪U4 is always guaranteed
to be true, because it follows from U2 ⊆ U2 . On the other hand, a relationship such as U3 ⊆ U1 ∪ U2
(as in Figure 3D) is not always present, and thus reflects something about the structure of a particular
receptive field arrangement.
Let C ⊂ {0, 1}n be a neural code, and let U = {U1 , . . . , Un } be any arrangement of receptive
fields in a stimulus space X such that C = C(U) (this is guaranteed to exist by Lemma 2.1). The RF
structure of C refers to the set of relations among the Ui s that are not “obvious,” and have the form:
\
[
Ui ⊆
Uj , for σ ∩ τ = ∅.
i∈σ

j∈τ

T
In particular, this includes any empty intersections i∈σ Ui = ∅ (here τ = ∅). In the Figure 3 examples,
the panel A code has no RF structure relations; while panel B has U1 ⊂ U3 and U2 ⊂ U3 ; panel C has
U1 ⊂ U2 ⊂ U3 ; and panel D has U3 ⊂ U1 ∪ U2 .
8

The central goal of this paper is to develop a method to algorithmically extract a minimal description of the RF structure directly from a neural code C, without first realizing it as C(U) for some
arrangement of receptive fields. We view this as a first step towards inferring stimulus space features
that cannot be obtained from the simplicial complex ∆(C). To do this we turn to an algebro-geometric
framework, that of neural rings and ideals. These objects are defined in Section 3 so as to capture the
full combinatorial data of a neural code, but in a way that allows us to naturally and algorithmically
infer a compact description of the desired RF structure, as shown in Section 4.

3

Neural rings and ideals

In this section we define the neural ring RC and a closely-related neural ideal, JC . First, we briefly
review some basic algebraic geometry background needed throughout this paper.

3.1

Basic algebraic geometry background

The following definitions are standard (see, for example, [24]).
Rings and ideals. Let R be a commutative ring. A subset I ⊆ R is an ideal of R if it has the
following properties:
(i) I is a subgroup of R under addition.
(ii) If a ∈ I, then ra ∈ I for all r ∈ R.
An ideal I is said to be generated by a set A, and we write I = hAi, if
I = {r1 a1 + · · · + rn an | ai ∈ A, ri ∈ R, and n ∈ N}.
In other words, I is the set of all finite combinations of elements of A with coefficients in R.
An ideal I ⊂ R is proper if I ( R. An ideal I ⊂ R is prime if it is proper and satisfies: if rs ∈ I
for some r, s ∈ R, then r ∈ I or s ∈ I. An ideal m ⊂ R is maximal if it is proper and for any ideal I
such that m ⊆ I ⊆ R, either I = m or I = R. An ideal I ⊂ R is radical if rn ∈ I implies r ∈ I, for
any r ∈ R and n ∈ N. An ideal I ⊂ R is primary if rs ∈ I implies r ∈ I or sn ∈ I for some n ∈ N. A
primary decomposition of an ideal I expresses I as an intersection of finitely many primary ideals.
Ideals and varieties. Let k be a field, n the number of neurons, and k[x1 , . . . , xn ] a polynomial
ring with one indeterminate xi for each neuron. We will consider k n to be the neural activity space,
where each point v = (v1 , . . . , vn ) ∈ k n is a vector tracking the state vi of each neuron. Note that
any polynomial f ∈ k[x1 , . . . , xn ] can be evaluated at a point v ∈ k n by setting xi = vi each time xi
appears in f . We will denote this value f (v).
Let J ⊂ k[x1 , . . . , xn ] be an ideal, and define the variety
def

V (J) = {v ∈ k n | f (v) = 0 for all f ∈ J}.
Similarly, given a subset S ⊂ k n , we can define the ideal of functions that vanish on this subset as
def

I(S) = {f ∈ k[x1 , . . . ., xn ] | f (v) = 0 for all v ∈ S}.
The ideal-variety correspondence [24] gives us the usual order-reversing relationships: I ⊆ J ⇒ V (J) ⊆
V (I), and S ⊆ T ⇒ I(T ) ⊆ I(S). Furthermore, V (I(V )) = V for any variety V , but it is not always
true that I(V (J)) = J for an ideal J (see Section 6.1). We will regard neurons as having only two
states, “on” or “off,” and thus choose k = F2 = {0, 1}.
9

3.2

Definition of the neural ring

Let C ⊂ {0, 1}n = Fn2 be a neural code, and define the ideal IC of F2 [x1 , . . . , xn ] corresponding to the
set of polynomials that vanish on all codewords in C:
def

IC = I(C) = {f ∈ F2 [x1 , . . . , xn ] | f (c) = 0 for all c ∈ C}.
By design, V (IC ) = C and hence I(V (IC )) = IC . Note that the ideal generated by the Boolean relations,
def

B = hx21 − x1 , . . . , x2n − xn i,
is automatically contained in IC , irrespective of C.
The neural ring RC corresponding to the code C is the quotient ring
def

RC = F2 [x1 , . . . , xn ]/IC ,
together with the set of indeterminates x1 , . . . , xn . We say that two neural rings are equivalent if there
is a bijection between the sets of indeterminates that yields a ring homomorphism.
Remark. Due to the Boolean relations, any element y ∈ RC satisfies y 2 = y (cross-terms vanish
|C|
because 2 = 0 in F2 ), so the neural ring is a Boolean ring isomorphic to F2 . It is important to keep
in mind, however, that RC comes equipped with a privileged set of functions, x1 , . . . , xn ; this allows
the ring to keep track of considerably more structure than just the size of the neural code.

3.3

The spectrum of the neural ring

We can think of RC as the ring of functions of the form f : C → F2 on the neural code, where each
function assigns a 0 or 1 to each codeword c ∈ C by evaluating f ∈ F2 [x1 , . . . , xn ]/IC through the
substitutions xi = ci for i = 1, . . . , n. Quotienting the original polynomial ring by IC ensures that
there is only one zero function in RC . The spectrum of the neural ring, Spec(RC ), consists of all prime
ideals in RC . We will see shortly that the elements of Spec(RC ) are in one-to-one correspondence with
the elements of the neural code C. Indeed, our definition of RC was designed for this to be true.
For any point v ∈ {0, 1}n of the neural activity space, let
def

mv = I(v) = {f ∈ F2 [x1 , . . . , xn ] | f (v) = 0}
be the maximal ideal of F2 [x1 , . . . , xn ] consisting of all functions that vanish on v. We can also write
mv = hx1 − v1 , . . . , xn − vn i (see Lemma 6.3 in Section 6.1). Using this, we can characterize the
spectrum of the neural ring.
Lemma 3.1. Spec(RC ) = {m̄v | v ∈ C}, where m̄v is the quotient of mv in RC .
The proof is given in Section 6.1. Note that because RC is a Boolean ring, the maximal ideal spectrum
and the prime ideal spectrum coincide.

3.4

The neural ideal & an explicit set of relations for the neural ring

The definition of the neural ring is rather impractical, as it does not give us explicit relations for
generating IC and RC . Here we define another ideal, JC , via an explicit set of generating relations.
Although JC is closely related to IC , it turns out that JC is a more convenient object to study, which
is why we will use the term neural ideal to refer to JC rather than IC .
10

For any v ∈ {0, 1}n , consider the function ρv ∈ F2 [x1 , . . . , xn ] defined as
n
Y
ρv =
(1 − vi − xi ) =
def

i=1

Y

xi

{i | vi =1}

Y

(1 − xj ) =

{j | vj =0}

Y
i∈supp(v)

Y

xi

(1 − xj ).

j ∈supp(v)
/

Note that ρv (x) can be thought of as a characteristic function for v, since it satisfies ρv (v) = 1 and
ρv (x) = 0 for any other x ∈ Fn2 . Now consider the ideal JC ⊆ F2 [x1 , . . . , xn ] generated by all functions
ρv , for v ∈
/ C:
def
/ C}i.
JC = h{ρv | v ∈
We call JC the neural ideal corresponding to the neural code C. If C = 2[n] is the complete code, we
simply set JC = 0, the zero ideal. JC is related to IC as follows, giving us explicit relations for the
neural ring.
Lemma 3.2. Let C ⊂ {0, 1}n be a neural code. Then,



/ C}, {xi (1 − xi ) | i ∈ [n]} ,
IC = JC + B = {ρv | v ∈
where B = h{xi (1 − xi ) | i ∈ [n]}i is the ideal generated by the Boolean relations, and JC is the neural
ideal.
The proof is given in Section 6.1.

4

How to infer RF structure using the neural ideal

This section is the heart of the paper. We begin by presenting an alternative set of relations that
can be used to define the neural ring. These relations enable us to easily interpret elements of IC as
receptive field relationships, clarifying the connection between the neural ring and ideal and the RF
structure of the code. We next introduce pseudo-monomials and pseudo-monomial ideals, and use
these notions to obtain a minimal description of the neural ideal, which we call the “canonical form.”
Theorem 4.3 enables us to use the canonical form of JC in order to “read off” a minimal description
of the RF structure of the code. Finally, we present an algorithm that inputs a neural code C and
outputs the canonical form CF (JC ), and illustrate its use in a detailed example.

4.1

An alternative set of relations for the neural ring

Let C ⊂ {0, 1}n be a neural code, and recall by Lemma 2.1 that C can always be realized as a RF code
C = C(U), provided we don’t require the Ui s to be convex. Let X be a stimulus space and U = {Ui }ni=1
a collection of open sets in X, and consider the RF code C(U). The neural ring corresponding to this
code is RC(U ) .
Observe that the functions f ∈ RC(U ) can be evaluated at any point p ∈ X by assigning

1 if p ∈ Ui
xi (p) =
0 if p ∈
/ Ui
each time xi appears in the polynomial f . The vector (x1 (p), . . . , xn (p)) ∈ {0, 1}n represents the
S
neural response to the stimulus p. Note that if p ∈
/ ni=1 Ui , then (x1 (p), . . . , xn (p)) = (0, . . . , 0) is the
all-zeros codeword. For any σ ⊂ [n], define
\
Y
def
def
Uσ =
Ui , and xσ =
xi .
i∈σ

i∈σ

11

Our convention is that x∅ = 1 and U∅ = X, even in cases where X )
p ∈ X,

1 if p ∈ Uσ
xσ (p) =
0 if p ∈
/ Uσ .

Sn

i=1 Ui .

Note that for any

The relations in IC(U ) encode the combinatorial data of U. For example, if Uσ = ∅ then we cannot
have xσ = 1 at any point of the stimulus space X, and must therefore impose the relation xσ to “knock
off” those points. On the other hand, if Uσ ⊂ Ui ∪ Uj , then xσ = 1 implies either xi = 1 or xj = 1,
something that is guaranteed by imposing the relation xσ (1 − xi )(1 − xj ). These observations lead us
to an alternative ideal, IU ⊂ F2 [x1 , . . . , xn ], defined directly from the arrangement of receptive fields
U = {U1 , . . . , Un }:
Y
[ 	
def 

(1 − xi ) | Uσ ⊆
Ui .
IU = xσ
i∈τ

i∈τ

Note that if τ = ∅, we only get a relation for Uσ = ∅, and this is xσ . If σ = ∅, then Uσ = X, and
we only get relations of this type if X is contained in the union of the Ui s. This is equivalent to the
requirement that there is no “outside point” corresponding to the all-zeros codeword.
Perhaps unsurprisingly, it turns out that IU and IC(U ) exactly coincide, so IU provides an alternative
set of relations that can be used to define RC(U ) .
Theorem 4.1. IU = IC(U ) .
The proof is given in Section 6.2.

4.2

Interpreting neural ring relations as receptive field relationships

Theorem 4.1 suggests that we can interpret elements of IC in terms of relationships between receptive
fields.
Lemma 4.2. Let C ⊂ {0, 1}n be a neural code, and let U = {U1 , . . . , Un } be any collection of open
sets (not necessarily convex) in a stimulus space X such that C = C(U). Then, for any pair of subsets
σ, τ ⊂ [n],
Y
[
xσ
(1 − xi ) ∈ IC ⇔ Uσ ⊆
Ui .
i∈τ

i∈τ

Proof. (⇐) This is a direct consequence of Theorem 4.1. (⇒) We distinguish two cases, based on
Q
Q
whether or not σ and τ intersect. If xσ i∈τ (1 − xi ) ∈ IC and σ ∩ τ 6= ∅, then xσ i∈τ (1 − xi ) ∈ B,
where B = h{xi (1 − xi ) | i ∈ [n]}i is the ideal generated by the Boolean relations. Consequently, the
S
relation does not give us any information about the code, and Uσ ⊆ i∈τ Ui follows trivially from the
Q
observation that Ui ⊆ Ui for any i ∈ σ ∩ τ . If, on the other hand, xσ i∈τ (1 − xi ) ∈ IC and σ ∩ τ = ∅,
then ρv ∈ IC for each v ∈ {0, 1}n such that supp(v) ⊇ σ and supp(v) ∩ τ = ∅. Since ρv (v) = 1, it
follows that v ∈
/ C for any v with supp(v) ⊇ σ and supp(v) ∩ τ = ∅. To see this, recall from the original
definition of IC that for all c ∈ C, f (c) = 0 for any f ∈ IC ; it follows that ρv (c) = 0 for all c ∈ C.
Because C = C(U), the fact that v ∈
/ C for any v such that supp(v) ⊇ σ and supp(v) ∩ τ = ∅ implies
T
S
S
i∈σ Ui \ j∈τ Uj = ∅. We can thus conclude that Uσ ⊆
j∈τ Uj .
Lemma 4.2 allows us to extract RF structure from the different types of relations that appear in IC :
• Boolean relations: {xi (1 − xi )}. The relation xi (1 − xi ) corresponds to Ui ⊆ Ui , which does not
contain any information about the code C.

12

• Type 1 relations: {xσ }. The relation xσ corresponds to Uσ = ∅.
 Q
	
S
• Type 2 relations: xσ i∈τ (1 − xi ) | σ, τ 6= ∅, σ ∩ τ = ∅, Uσ 6= ∅ and i∈τ Ui 6= X .
Q
S
The relation xσ i∈τ (1 − xi ) corresponds to Uσ ⊆ i∈τ Ui .
Q
	
Q
S
• Type 3 relations:
i∈τ (1 − xi ) . The relation
i∈τ (1 − xi ) corresponds to X ⊆
i∈τ Ui .
The somewhat complicated requirements on the Type 2 relations ensure that they do not include
polynomials that are multiples of Type 1, Type 3, or Boolean relations. Note that the constant
polynomial 1 may appear as both a Type 1 and a Type 3 relation, but only if X = ∅. The four types
of relations listed above are otherwise disjoint. Type 3 relations only appear if X is fully covered by
the receptive fields, and there is thus no all-zeros codeword corresponding to an “outside” point.
Not all elements of IC are one of the above types, of course, but we will see that these are sufficient
to generate IC . This follows from the observation (see Lemma 6.6) that the neural ideal JC is generated
by the Type 1, Type 2 and Type 3 relations, and recalling that IC is obtained from JC be adding in the
Boolean relations (Lemma 3.2). At the same time, not all of these relations are necessary to generate
the neural ideal. Can we eliminate redundant relations to come up with a “minimal” list of generators
for JC , and hence IC , that captures the essential RF structure of the code? This is the goal of the next
section.

4.3

Pseudo-monomials & a canonical form for the neural ideal

The Type 1, Type 2, and Type 3 relations are all products of linear terms of the form xi and 1−xi , and
are thus very similar to monomials. By analogy with square-free monomials and square-free monomial
ideals [12], we define the notions of pseudo-monomials and pseudo-monomial ideals. Note that we do
not allow repeated indices in our definition of pseudo-monomial, so the Boolean relations are explicitly
excluded.
Q
Q
Definition. If f ∈ F2 [x1 , . . . , xn ] has the form f = i∈σ xi j∈τ (1 − xj ) for some σ, τ ⊂ [n] with
σ ∩ τ = ∅, then we say that f is a pseudo-monomial.
Definition. An ideal J ⊂ F2 [x1 , . . . , xn ] is a pseudo-monomial ideal if J can be generated by a finite
set of pseudo-monomials.
Definition. Let J ⊂ F2 [x1 , . . . , xn ] be an ideal, and f ∈ J a pseudo-monomial. We say that f
is a minimal pseudo-monomial of J if there does not exist another pseudo-monomial g ∈ J with
deg(g) < deg(f ) such that f = hg for some h ∈ F2 [x1 , . . . , xn ].
By considering the set of all minimal pseudo-monomials in a pseudo-monomial ideal J, we obtain a
unique and compact description of J, which we call the “canonical form” of J.
Definition. We say that a pseudo-monomial ideal J is in canonical form if we present it as J =
def
hf1 , . . . , fl i, where the set CF (J) = {f1 , . . . , fl } is the set of all minimal pseudo-monomials of J.
Equivalently, we refer to CF (J) as the canonical form of J.
Clearly, for any pseudo-monomial ideal J ⊂ F2 [x1 , . . . , xn ], CF (J) is unique and J = hCF (J)i. On
the other hand, it is important to keep in mind that although CF (J) consists of minimal pseudomonomials, it is not necessarily a minimal set of generators for J. To see why, consider the pseudomonomial ideal J = hx1 (1 − x2 ), x2 (1 − x3 )i. This ideal in fact contains a third minimal pseudomonomial: x1 (1 − x3 ) = (1 − x3 ) · [x1 (1 − x2 )] + x1 · [x2 (1 − x3 )]. It follows that CF (J) = {x1 (1 −
x2 ), x2 (1 − x3 ), x1 (1 − x3 )}, but clearly we can remove x1 (1 − x3 ) from this set and still generate J.
13

For any code C, the neural ideal JC is a pseudo-monomial ideal because JC = h{ρv | v ∈
/ C}i, and
each of the ρv s is a pseudo-monomial. (In contrast, IC is rarely a pseudo-monomial ideal, because
it is typically necessary to include the Boolean relations as generators.) Theorem 4.3 describes the
canonical form of JC . In what follows, we say that σ ⊆ [n] is minimal with respect to property P if σ
satisfies P , but P is not satisfied for any τ ( σ. For example, if Uσ = ∅ and for all τ ( σ we have
Uτ 6= ∅, then we say that “σ is minimal w.r.t. Uσ = ∅.”
Theorem 4.3. Let C ⊂ {0, 1}n be a neural code, and let U = {U1 , . . . , Un } be any collection of open
sets (not necessarily convex) in a nonempty stimulus space X such that C = C(U). The canonical form
of JC is:


	
JC =
xσ | σ is minimal w.r.t. Uσ = ∅ ,
[
 Y
xσ
(1 − xi ) | σ, τ 6= ∅, σ ∩ τ = ∅, Uσ 6= ∅,
Ui 6= X, and σ, τ are each minimal
i∈τ

w.r.t. Uσ ⊆

i∈τ

[
i∈τ

[ 	
	 Y
Ui ,
(1 − xi ) | τ is minimal w.r.t. X ⊆
Ui .
i∈τ

i∈τ

We call the above three (disjoint) sets of relations comprising CF (JC ) the minimal Type 1 relations,
the minimal Type 2 relations, and the minimal Type 3 relations, respectively.
The proof is given in Section 6.3. Note that, because of the uniqueness of the canonical form, if we
are given CF (JC ) then Theorem 4.3 allows us to read off the corresponding (minimal) relationships
that must be satisfied by any receptive field representation of the code as C = C(U):
• Type 1: xσ ∈ CF (JC ) implies that Uσ = ∅, but all lower-order intersections Uγ with γ ( σ are
non-empty.
Q
S
• Type 2: xσ i∈τ (1 − xi ) ∈ CF (JC ) implies that Uσ ⊆ i∈τ Ui , but no lower-order intersection is
S
S
contained in i∈τ Ui , and all the Ui s are necessary for Uσ ⊆ i∈τ Ui .
Q
S
• Type 3:
i∈τ (1 −Sxi ) ∈ CF (JC ) implies that X ⊆
i∈τ Ui , but X is not contained in any
lower-order union i∈γ Ui for γ ( τ .
The canonical form CF (JC ) thus provides a minimal description of the RF structure dictated by the
code C.
The Type 1 relations in CF (JC ) can be used to obtain a (crude) lower bound on the minimal
embedding dimension of the neural code, as defined in Section 2.3.2. Recall Helly’s theorem (Section 2.3.1), and observe that if xσ ∈ CF (JC ) then σ is minimal with respect to Uσ = ∅; this in turn
implies that |σ| ≤ d+1. (If |σ| > d+1, by minimality all d+1 subsets intersect and by Helly’s theorem
we must have Uσ 6= ∅.) We can thus obtain a lower bound on the minimal embedding dimension d as
d≥

max

{σ|xσ ∈CF (JC )}

|σ| − 1,

where the maximum is taken over all σ such that xσ is a Type 1 relation in CF (JC ). This bound
only depends on ∆(C), however, and does not provide any insight regarding the different minimal
embedding dimensions observed in the examples of Figure 3. These codes have no Type 1 relations in
their canonical forms, but they are nicely differentiated by their minimal Type 2 and Type 3 relations.
From the receptive field arrangements depicted in Figure 3, we can easily write down CF (JC ) for each
of these codes.
14

A. CF (JC ) = {0}. There are no relations here because C = 2[3] .
B. CF (JC ) = {1 − x3 }. This Type 3 relation reflects the fact that X = U3 .
C. CF (JC ) = {x1 (1 − x2 ), x2 (1 − x3 ), x1 (1 − x3 )}. These Type 2 relations correspond to U1 ⊂ U2 ,
U2 ⊂ U3 , and U1 ⊂ U3 . Note that the first two of these receptive field relationships imply the
third; correspondingly, the third canonical form relation satisfies: x1 (1 − x3 ) = (1 − x3 ) · [x1 (1 −
x2 )] + x1 · [x2 (1 − x3 )].
D. CF (JC ) = {(1−x1 )(1−x2 )}. This Type 3 relation reflects X = U1 ∪U2 , and implies U3 ⊂ U1 ∪U2 .
Nevertheless, we do not yet know how to infer the minimal embedding dimension from CF (JC ). In
Appendix 2 (Section 7), we provide a complete list of neural codes on three neurons, up to permutation,
and their respective canonical forms.

4.4

Comparison to the Stanley-Reisner ideal

Readers familiar with the Stanley-Reisner ideal [12, 13] will recognize that this kind of ideal is generated
by the Type 1 relations of a neural code C. The corresponding simplicial complex is ∆(C), the smallest
simplicial complex that contains the code.
Lemma 4.4. Let C = C(U). The ideal generated by the Type 1 relations, hxσ | Uσ = ∅i, is the StanleyReisner ideal of ∆(C). Moreover, if supp C is a simplicial complex, then CF (JC ) contains no Type 2
or Type 3 relations, and JC is thus the Stanley-Reisner ideal for supp C.
Proof. To see the first statement, observe that the Stanley-Reisner ideal of a simplicial complex ∆ is
the ideal
def
I∆ = hxσ | σ ∈
/ ∆i,
and recall that ∆(C) = {σ ⊆ [n] | σ ⊆ supp(c) for some c ∈ C}. As C = C(U), an equivalent
characterization is ∆(C) = {σ ⊆ [n] | Uσ 6= ∅}. Since these sets are equal, so are their complements in
2[n] :
{σ ⊆ [n] | σ ∈
/ ∆(C)} = {σ ⊆ [n] | Uσ = ∅}.
Thus, hxσ | Uσ = ∅i = hxσ | σ ∈
/ ∆(C)i, which is the Stanley-Reisner ideal for ∆(C).
To prove the second statement, suppose that supp C is a simplicial complex. Note that C must
S
contain the all-zeros codeword, so X ) ni=1 Ui and there can be no Type 3 relations. Suppose the
Q
canonical form of JC contains a Type 2 relation xσ i∈τ (1 − xi ), for some σ, τ ⊂ [n] satisfying σ, τ 6= ∅,
σ ∩ τ = ∅ and Uσ 6= ∅. The existence of this relation indicates that σ ∈
/ supp C, while there does exist
an ω ∈ C such that σ ⊂ ω. This contradicts the assumption that supp C is a simplicial complex. We
conclude that JC has no Type 2 relations.
The canonical form of JC thus enables us to immediately read off, via the Type 1 relations, the
minimal forbidden faces of the simplicial complex ∆(C) associated to the code, and also the minimal
deviations of C from being a simplicial complex, which are captured by the Type 2 and Type 3 relations.

4.5

An algorithm for obtaining the canonical form

Now that we have established that a minimal description of the RF structure can be extracted from
the canonical form of the neural ideal, the most pressing question is the following:

15

Question: How do we find the canonical form CF (JC ) if all we know is the code C, and we are not
given a representation of the code as C = C(U)?
In this section we describe an algorithmic method for finding CF (JC ) from knowledge only of C. It
turns out that computing the primary decomposition of JC is a key step towards finding the minimal
pseudo-monomials. This parallels the situation for monomial ideals, although there are some additional
subtleties in the case of pseudo-monomial ideals. As previously discussed, from the canonical form we
can read off the RF structure of the code, so the overall workflow is as follows:
Workflow:

primary
canonical
minimal
neural code
neural ideal
→
→ decomposition →
→ RF structure
form
C ⊂ {0, 1}n
JC = h{ρv | v ∈
/ C}i
of JC
CF (JC )
of C

Canonical form algorithm
Input: A neural code C ⊂ {0, 1}n .
Output: The canonical form of the neural ideal, CF (JC ).



Step 1: From C ⊂ {0, 1}n , compute JC = {ρv | v ∈
/ C} .
Step 2: Compute the primary decomposition of JC . It turns out (see Theorem 5.4 in the next section)
that this decomposition yields a unique representation of the ideal as
\
JC =
pa ,
a∈A

where each a ∈ A is an element of {0, 1, ∗}n , and pa is defined as
 


def 

pa = {xi − ai | ai 6= ∗} = {xi | ai = 0}, {1 − xj | aj = 1} .
Note that the pa s are all prime ideals. We will see later how to compute this primary decomposition algorithmically, in Section 5.3.
Step 3: Observe that any pseudo-monomial f ∈ JC must satisfy f ∈ pa for each a ∈ A. It follows that
f is a multiple of one of the linear generators of pa for each a ∈ A. Compute the following set
of elements of JC :
Y
	
M(JC ) =
ga | ga = xi − ai for some ai 6= ∗ .
a∈A

M(JC ) consists of all polynomials obtained as a product of linear generators ga , one for each
prime ideal pa of the primary decomposition of JC .
Step 4: Reduce the elements of M(JC ) by imposing xi (1 − xi ) = 0. This eliminates elements that
are not pseudo-monomials. It also reduces the degrees of some of the remaining elements, as it
implies x2i = xi and (1 − xi )2 = (1 − xi ). We are left with a set of pseudo-monomials of the form
Q
Q
f = i∈σ xi j∈τ (1 − xj ) for τ ∩ σ = ∅. Call this new reduced set M̃(JC ).
Step 5: Finally, remove all elements of M̃(JC ) that are multiples of lower-degree elements in M̃(JC ).
Proposition 4.5. The resulting set is the canonical form CF (JC ).
The proof is given in Section 6.4.
16

4.6

An example

Now we are ready to use the canonical form algorithm in an example, illustrating how to obtain a
possible arrangement of convex receptive fields from a neural code.
Suppose a neural code C has the following 13 codewords, and 19 missing words:
C

{0, 1}5 \C

=

{00000, 10000, 01000,
11000, 10001, 01100,
00011, 11100, 00111}

=

{00010,
11010,
01110,
11011,

10100,
11001,
01101,
10111,

00100, 00001,
00110, 00101,

10010, 01010,
10110, 10101,
01011, 11110,
01111, 11111}.

01001,
10011,
11101,

Thus, the neural ideal JC has 19 generators, using the original definition JC = h{ρv | v ∈
/ C}i:


JC = x4 (1 − x1 )(1 − x2 )(1 − x3 )(1 − x5 ), x1 x3 (1 − x2 )(1 − x4 )(1 − x5 ), x1 x4 (1 − x2 )(1 − x3 )(1 − x5 ),
x2 x4 (1 − x1 )(1 − x3 )(1 − x5 ), x2 x5 (1 − x1 )(1 − x3 )(1 − x4 ), x1 x2 x4 (1 − x3 )(1 − x5 ),
x1 x2 x5 (1 − x3 )(1 − x4 ), x1 x3 x4 (1 − x2 )(1 − x5 ), x1 x3 x5 (1 − x2 )(1 − x4 ), x1 x4 x5 (1 − x2 )(1 − x3 ),
x2 x3 x4 (1 − x1 )(1 − x5 ), x2 x3 x5 (1 − x1 )(1 − x4 ), x2 x4 x5 (1 − x1 )(1 − x3 ), x1 x2 x3 x4 (1 − x5 )

x1 x2 x3 x5 (1 − x4 ), x1 x2 x4 x5 (1 − x3 ), x1 x3 x4 x5 (1 − x2 ), x2 x3 x4 x5 (1 − x1 ), x1 x2 x3 x4 x5 .

Despite the fact that we are considering only five neurons, this looks like a complicated ideal. Considering the canonical form of JC will help us to extract the relevant combinatorial information and
allow us to create a possible arrangement of receptive fields U that realizes this code as C = C(U).
Following Step 2 of our canonical form algorithm, we take the primary decomposition of JC :
JC = hx1 , x2 , x4 i∩hx1 , x2 , 1−x3 i∩hx1 , x2 , 1−x5 i∩hx2 , x3 , x4 i∩hx3 , x4 , x5 i∩hx1 , x4 , x5 i∩h1−x2 , x4 , x5 i.
Then, as described in Steps 3-5 of the algorithm, we take all possible products amongst these seven
larger ideals, reducing by the relation xi (1 − xi ) = 0 (note that this gives us xi = x2i and hence we
can say xki = xi for any k > 1). We also remove any polynomials that are multiples of smaller-degree
pseudo-monomials in our list. This process leaves us with six minimal pseudo-monomials, yielding the
canonical form:
JC = hCF (JC )i = hx1 x3 x5 , x2 x5 , x1 x4 , x2 x4 , x1 x3 (1 − x2 ), x4 (1 − x3 )(1 − x5 )i.
Note in particular that every generator we originally put in JC is a multiple of one of the six relations
in CF (JC ). Next, we consider what the relations in CF (JC ) tell us about the arrangement of receptive
fields that would be needed to realize the code as C = C(U).
1. x1 x3 x5 ∈ CF (JC ) ⇒ U1 ∩ U3 ∩ U5 = ∅, while U1 ∩ U3 , U3 ∩ U5 and U1 ∩ U5 are all nonempty.
2. x2 x5 ∈ CF (JC ) ⇒ U2 ∩ U5 = ∅, while U2 , U5 are both nonempty.
3. x1 x4 ∈ CF (JC ) ⇒ U1 ∩ U4 = ∅, while U1 , U4 are both nonempty.
4. x2 x4 ∈ CF (JC ) ⇒ U2 ∩ U4 = ∅, while U2 , U4 are both nonempty.
17

5. x1 x3 (1 − x2 ) ∈ CF (JC ) ⇒ U1 ∩ U3 ⊆ U2 , while U1 6⊆ U2 , U3 6⊆ U2 , and U1 ∩ U3 6= ∅.
6. x4 (1 − x3 )(1 − x5 ) ∈ CF (JC ) ⇒ U4 ⊆ U3 ∪ U5 , while U4 6= ∅, and that U4 6⊆ U3 , U4 6⊆ U5 .
The minimal Type 1 relations (1-4) tell us that we should draw U1 , U3 and U5 with all pairwise
intersections, but leaving a “hole” in the middle since the triple intersection is empty. Then U2 should
be drawn to intersect U1 and U3 , but not U5 . Similarly, U4 should intersect U3 and U5 , but not U1 or
U2 . The minimal Type 2 relations (5-6) tell us that U2 should be drawn to contain the intersection
U1 ∩ U3 , while U4 lies in the union U3 ∪ U5 , but is not contained in U3 or U5 alone. There are no
minimal Type 3 relations, as expected for a code that includes the all-zeros codeword.
Putting all this together, and assuming convex receptive fields, we can completely infer the receptive
field structure, and draw the corresponding picture (see Figure 4). It is easy to verify that the code
C(U) of the pictured arrangement indeed coincides with C.

1

5
4

2
3

Figure 4: An arrangement of five sets that realizes C as C(U).

5

Primary decomposition

Let C ⊂ {0, 1}n be a neural code. The primary decomposition of IC is boring:
\
IC =
mc ,
c∈C

where mv for any v ∈ {0, 1}n is the maximal ideal I(v) defined in Section 3.3. This simply expresses
IC as the intersection of all maximal ideals mc for c ∈ C, because the variety C = V (IC ) is just a finite
set of points and the primary decomposition reflects no additional structure of the code.
On the other hand, the primary decomposition of the neural ideal JC retains the full combinatorial
structure of C. Indeed, we have seen that computing this decomposition is a critical step towards
obtaining CF (JC ), which captures the receptive field structure of the neural code. In this section, we
describe the primary decomposition of JC and discuss its relationship to some natural decompositions
of the neural code. We end with an algorithm for obtaining primary decomposition of any pseudomonomial ideal.

5.1

Primary decomposition of the neural ideal

We begin by defining some objects related to F2 [x1 , . . . , xn ] and {0, 1}n , without reference to any
particular neural code. For any a ∈ {0, 1, ∗}n , we define the variety
def

Va = {v ∈ {0, 1}n | vi = ai for all i s.t. ai 6= ∗} ⊆ {0, 1}n .
18

This is simply the subset of points compatible with the word “a”, where ∗ is viewed as a “wild card”
symbol. Note that Vv = {v} for any v ∈ {0, 1}n . We can also associate a prime ideal to a,
def

pa = h{xi − ai | ai 6= ∗}i ⊆ F2 [x1 , . . . , xn ],
consisting of polynomials in F2 [x1 , . . . , xn ] that vanish on all points compatible with a. To obtain all
such polynomials, we must add in the Boolean relations (see Section 6.1):
def

qa = I(Va ) = pa + hx21 − x1 , . . . , x2n − xn i.
Note that Va = V (pa ) = V (qa ).
Next, let’s relate this all to a code C ⊂ {0, 1}n . Recall the definition of the neural ideal,
n
Y
def
/ C}i = h{ ((xi − vi ) − 1) | v ∈
JC = h{ρv | v ∈
/ C}i.
i=1

We have the following correspondences.
Lemma 5.1. JC ⊆ pa ⇔ Va ⊆ C.
Proof. (⇒) JC ⊆ pa ⇒ V (pa ) ⊆ V (JC ). Recalling that V (pa ) = Va and V (JC ) = C, this gives Va ⊆ C.
(⇐) Va ⊆ C ⇒ I(C) ⊆ I(Va ) ⇒ IC ⊆ qa . Recalling that both IC and qa differ from JC and pa ,
respectively, by the addition of the Boolean relations, we obtain JC ⊆ pa .
Lemma 5.2. For any a, b ∈ {0, 1, ∗}n , Va ⊆ Vb ⇔ pb ⊆ pa .
Proof. (⇒) Suppose Va ⊆ Vb . Then, for any i such that bi 6= ∗ we have ai = bi . It follows that each
generator of pb is also in pa , so pb ⊆ pa . (⇐) Suppose pb ⊆ pa . Then, Va = V (pa ) ⊆ V (pb ) = Vb .
Recall that a an ideal p is said to be a minimal prime over J if p is a prime ideal that contains
J, and there is no other prime ideal p0 such that p ) p0 ⊇ J. Minimal primes pa ⊇ JC correspond to
maximal varieties Va such that Va ⊆ C. Consider the set
def

AC = {a ∈ {0, 1, ∗}n | Va ⊆ C}.
We say that a ∈ AC is maximal if there does not exist another element b ∈ AC such that Va ( Vb (i.e.,
a ∈ AC is maximal if Va is maximal such that Va ⊆ C).
Lemma 5.3. The element a ∈ AC is maximal if and only if pa is a minimal prime over JC .
Proof. Recall that a ∈ AC ⇒ Va ⊆ C, and hence JC ⊆ pa (by Lemma 5.1). (⇒) Let a ∈ AC be
maximal, and choose b ∈ {0, 1, ∗} such that JC ⊆ pb ⊆ pa . By Lemmas 5.1 and 5.2, Va ⊆ Vb ⊆ C.
Since a is maximal, we conclude that b = a, and hence pb = pa . It follows that pa is a minimal
prime over JC . (⇐) Suppose pa is a minimal prime over JC . Then by Lemma 5.1, a ∈ AC . Let b be a
maximal element of AC such that Va ⊆ Vb ⊆ C. Then JC ⊆ pb ⊆ pa . Since pa is a minimal prime over
JC , pb = pa and hence b = a. Thus a is maximal in AC .
We can now describe the primary decomposition of JC . Here we assume the neural code C ⊆ {0, 1}n
is non-empty, so that JC is a proper pseudo-monomial ideal.
T
Theorem 5.4. JC = `i=1 pai is the unique irredundant primary decomposition of JC , where pa1 , . . . , pa`
are the minimal primes over JC .
The proof is given in Section 6.6. Combining this theorem with Lemma 5.3, we have:
T
Corollary 5.5. JC = `i=1 pai is the unique irredundant primary decomposition of JC , where a1 , . . . , a`
are the maximal elements of AC .
19

5.2

Decomposing the neural code via intervals of the Boolean lattice

From the definition of AC , it is easy to see that the maximal elements yield a kind of “primary”
decomposition of the neural code C as a union of maximal Va s.
S
Lemma 5.6. C = `i=1 Vai , where a1 , . . . , a` are the maximal elements of AC . (I.e., pa1 , . . . , pa` are
the minimal primes in the primary decomposition of JC .)
S
Proof. Since Va ⊆ C for any a ∈ AC , clearly `i=1 Vai ⊆ C. To see the reverse inclusion, note that for
S
any c ∈ C, c ∈ Vc ⊆ Va for some maximal a ∈ AC . Hence, C ⊆ `i=1 Vai .
Note that Lemma 5.6 could also be regarded as a corollary of Theorem 5.4, since C = V (JC ) =
S
S
T
V ( `i=1 pai ) = `i=1 V (pai ) = `i=1 Vai , and the maximal a ∈ AC correspond to minimal primes
pa ⊇ JC . Although we were able to prove Lemma 5.6 directly, in practice we use the primary
decomposition in order to find (algorithmically) the maximal elements a1 , . . . , a` ∈ AC , and thus
determine the Va s for the above decomposition of the code.
It is worth noting here that the decomposition of C in Lemma 5.6 is not necessarily minimal. This
is because one can have fewer qa s such that
\
\
qai =
pai .
i∈σ([`]

i∈[`]

Since V (qai ) = V (pai ) = Vai , this would lead to a decomposition of C as a union of fewer Vai s.
In contrast, the primary decomposition of JC in Theorem 5.4 is irredundant, and hence none of the
minimal primes can be dropped from the intersection.
Neural activity “motifs” and intervals of the Boolean lattice
We can think of an element a ∈ {0, 1, ∗}n as a neural activity “motif”. That is, a is a pattern of
activity and silence for a subset of the neurons, while Va consists of all activity patterns on the full
population of neurons that are consistent with this motif (irrespective of what the code is). For a
given neural code C, the set of maximal a1 , . . . , al ∈ AC corresponds to a set of minimal motifs that
define the code (here “minimal” is used in the sense of having the fewest number of neurons that are
constrained to be “on” or “off” because ai 6= ∗). If a ∈ {0, ∗}n , we refer to a as a neural silence
motif, since it corresponds to a pattern of silence. In particular, silence motifs correspond to simplices
in supp C, since supp Va is a simplex in this case. If supp C is a simplicial complex, then Lemma 5.6
gives the decomposition of C as a union of minimal silence motifs (corresponding to facets, or maximal
simplices, of supp C).
More generally, Va corresponds to an interval of the Boolean lattice {0, 1}n . Recall the poset
structure of the Boolean lattice: for any pair of elements v1 , v2 ∈ {0, 1}n , we have v1 ≤ v2 if and only
if supp(v1 ) ⊆ supp(v2 ). An interval of the Boolean lattice is thus a subset of the form:
def

[u1 , u2 ] = {v ∈ {0, 1}n | u1 ≤ v ≤ u2 }.
Given an element a ∈ {0, 1, ∗}n , we have a natural interval consisting of all Boolean lattice elements
“compatible” with a. Letting a0 ∈ {0, 1}n be the element obtained from a by setting all ∗s to 0, and
a1 ∈ {0, 1}n the element obtained by setting all ∗s to 1, we find that
Va = [a0 , a1 ] = {v ∈ {0, 1}n | a0 ≤ v ≤ a1 }.
20

Simplices correspond to intervals of the form [0, a1 ], where 0 is the bottom “all-zeros” element in the
Boolean lattice.
While the primary decomposition of JC allows a neural code C ⊆ {0, 1}n to be decomposed as
a union of intervals of the Boolean lattice, as indicated by Lemma 5.6, the canonical form CF (JC )
provides a decomposition of the complement of C as a union of intervals. First, notice that to any
pseudo-monomial f ∈ CF (JC ) we can associate an element b ∈ {0, 1, ∗} as follows: bi = 1 if xi |f ,
bi = 0 if (1 − xi )|f , and bi = ∗ otherwise. In other words,
def

Y

f = fb =

xi

Y

(1 − xj ).

{j|bj =0}

{i|bi =1}

As before, b corresponds to an interval Vb = [b0 , b1 ] ⊂ {0, 1}n . Recalling the JC is generated by pseudomonomials corresponding to non-codewords, it is now easy to see that the complement of C in {0, 1}n
can be expressed as the union of Vb s, where each b corresponds to a pseudo-monomial in the canonical
form. The canonical form thus provides an alternative description of the code, nicely complementing
Lemma 5.6.
S
Lemma 5.7. C = {0, 1}n \ ki=1 Vbi , where CF (JC ) = {fb1 , . . . , fbk }.
111

We now illustrate both decompositions of the
neural code with an example.
110

Example.
Consider the neural code C
{000, 001, 011, 111} ⊂ {0, 1}3 corresponding
a set of receptive fields satisfying U1 ( U2
U3 ( X. The primary decomposition of JC
F2 [x1 , x2 , x3 ] is given by

=
to
(
⊂

100

hx1 , x2 i ∩ hx1 , 1 − x3 i ∩ h1 − x2 , 1 − x3 i,
while the canonical form is
CF (JC ) = hx1 (1 − x2 ), x2 (1 − x3 ), x1 (1 − x3 )i.

101

011

010

001

000

Figure 5: Boolean interval decompositions of the code
C = {000, 001, 011, 111} (in black) and of its complement
(in gray), arising from the primary decomposition and
canonical form of JC , respectively.

From the primary decomposition, we can write C = Va1 ∪ Va2 ∪ Va3 for a1 = 00∗, a2 = 0∗1,
and a3 = ∗11. The corresponding Boolean lattice intervals are [000, 001], [001, 011], and [011, 111],
respectively, and are depicted in black in Figure 5. As noted before, this decomposition of the neural
code need not be minimal; indeed, we could also write C = Va1 ∪ Va3 , as the middle interval is not
necessary to cover all codewords in C.
From the canonical form, we obtain C = {0, 1}3 \ (Vb1 ∪ Vb2 ∪ Vb3 ), where b1 = 10∗, b2 = ∗10, and
b3 = 1∗0. The corresponding Boolean lattice intervals spanning the complement of C are [100, 101],
[010, 110], and [100, 110], respectively; these are depicted in gray in Figure 5. Again, notice that this
decomposition is not minimal – namely, Vb3 = [100, 110] could be dropped.

5.3

An algorithm for primary decomposition of pseudo-monomial ideals

We have already seen that computing the primary decomposition of the neural ideal JC is a critical
step towards extracting the canonical form CF (JC ), and that it also yields a meaningful decomposition

21

of C in terms of neural activity motifs. Recall from Section 4.3 that JC is always a pseudo-monomial
ideal – i.e., JC is generated by pseudo-monomials, which are polynomials f ∈ F2 [x1 , . . . , xn ] of the form
Y
f=
zi , where zi ∈ {xi , 1 − xi } for any i ∈ [n].
i∈σ

In this section, we provide an explicit algorithm for finding the primary decomposition of such ideals.
In the case of monomial ideals, there are many algorithms for obtaining the primary decomposition, and there are already fast implementations of such algorithms in algebraic geometry software
packages such as Singular and Macaulay2 [25]. Pseudo-monomial ideals are closely related to squarefree monomial ideals, but there are some differences which require a bit of care. In particular, if
J ⊆ F2 [x1 , . . . , xn ] is a pseudo-monomial ideal and z ∈ {xi , 1 − xi } for some i ∈ [n], then for f a
pseudo-monomial:
f ∈ hJ, zi 6⇒ f ∈ J or f ∈ hzi.
To see why, observe that x1 ∈ hx1 (1 − x2 ), x2 i, because x1 = 1 · x1 (1 − x2 ) + x1 · x2 , but x1 is not
a multiple of either x1 (1 − x2 ) or x2 . We can nevertheless adapt ideas from (square-free) monomial
ideals to obtain an algorithm for the primary decomposition of pseudo-monomial ideals. The following
lemma allows us to handle the above complication.
Lemma 5.8. Let J ⊂ F2 [x1 , . . . , xn ] be a pseudo-monomial ideal, and let z ∈ {xi , 1 − xi } for some
i ∈ [n]. For any pseudo-monomial f ,
f ∈ hJ, zi ⇒ f ∈ J or f ∈ hzi or (1 − z)f ∈ J.
The proof is given in Section 6.5. Using Lemma 5.8 we can prove the following key lemma for our
algorithm, which mimics the case of square-free monomial ideals.
Q
Lemma 5.9. Let J ⊂ F2 [x1 , . . . , xn ] be a pseudo-monomial ideal, and let i∈σ zi be a pseudomonomial, with zi ∈ {xi , 1 − xi } for each i. Then,
Y
\
hJ,
zi i =
hJ, zi i.
i∈σ

i∈σ

Q

T
The proof is given in Section 6.5. Note that if i∈σ zi ∈ J, then this lemma implies J = i∈σ hJ, zi i,
which is the key fact we will use in our algorithm. This is similar to Lemma 2.1 in [25, Monomial
Ideals Chapter], and suggests a recursive algorithm along similar lines to those that exist for monomial
ideals.
The following observation will add considerable efficiency to our algorithm for pseudo-monomial
ideals.
Lemma 5.10. Let J ⊂ F2 [x1 , . . . , xn ] be a pseudo-monomial ideal. For any zi ∈ {xi , 1 − xi } we can
write
J = hzi g1 , . . . , zi gk , (1 − zi )f1 , . . . , (1 − zi )f` , h1 , . . . , hm i,
where the gj , fj and hj are pseudo-monomials that contain no zi or 1 − zi term. (Note that k, ` or m
may be zero if there are no generators of the corresponding type.) Then,
hJ, zi i = hJ|zi =0 , zi i = hzi , f1 , . . . , f` , h1 , . . . , hm i.
Proof. Clearly, the addition of zi in hJ, zi i renders the zi gj generators unnecessary. The (1 − zi )fj
generators can be reduced to just fj because fj = 1 · (1 − zi )fj + fj · zi .
We can now state our algorithm. Recall that an ideal I ⊆ R is proper if I 6= R.
22

Algorithm for primary decomposition of pseudo-monomial ideals
Input: A proper pseudo-monomial ideal J ⊂ F2 [x1 , . . . , xn ]. This is presented as J = hg1 , . . . , gr i
with each generator gi a pseudo-monomial.
Output: Primary decomposition of J. This is returned as a set P of prime ideals, with J =

T

I∈P

I.

• Step 1 (Initializion Step): Set P = ∅ and D = {J}. Eliminate from the list of generators of J
those that are multiples of other generators.
• Step 2 (Splitting Step): For each ideal I ∈ D compute DI as follows.
Step 2.1: Choose a nonlinear generator zi1 · · · zim ∈ I, where each zi ∈ {xi , 1 − xi }, and m ≥ 2.
(Note: the generators of I should always be pseudo-monomials.)
Step 2.2: Set DI = {hI, zi1 i, . . . , hI, zim i}. By Lemma 5.9 we know that
I=

m
\

\

hI, zik i =

k=1

K.

K∈DI

• Step 3 (Reduction Step): For each DI and each ideal hI, zi i ∈ DI , reduce the set of generators
as follows.
Step 3.1: Set zi = 0 in each generator of I. This yields a “0” for each multiple of zi , and removes
1 − zi factors in each of the remaining generators. By Lemma 5.10, hI, zi i = hI|zi =0 , zi i.
Step 3.2: Eliminate 0s and generators that are multiples of other generators.
Step 3.3: If there is a “1” as a generator, eliminate hI, zi i from DI as it is not a proper ideal.
• Step 4 (Update Step): Update D and P, as follows.
S
Step 4.1: Set D = DI , and remove redundant ideals in D. That is, remove an ideal if it has
the same set of generators as another ideal in D.
Step 4.2: For each ideal I ∈ D, if I has only linear generators (and is thus prime), move I to P
by setting P = P ∪ I and D = D \ I.
• Step 5 (Recursion Step): Repeat Steps 2-4 until D = ∅.
• Step 6 (Final Step): Remove redundant ideals of P. That is, remove ideals that are not necessary
T
to preserve the equality J = I∈P I.
Proposition 5.11. This algorithm is guaranteed to terminate, and the final P is a set of irredundant
T
prime ideals such that J = I∈P I.
Proof. For any pseudo-monomial ideal I ∈ D, let deg(I) be the sum of the degrees of all generating
monomials of I. To see that the algorithm terminates, observe that for each ideal hI, zi i ∈ DI ,
deg(hI, zi i) < deg(I) (this follows from Lemma 5.10). The degrees of elements in D thus steadily
decrease with each recursive iteration, until they are removed as prime ideals that are appended to
n
P. At the same time, the size of D is strictly bounded at |D| ≤ 2( 3 ) , since there are only n3
n
pseudo-monomials in F [x , . . . , x ], and thus at most 2( 3 ) distinct pseudo-monomial ideals.
2

1

n

By construction, the final P is an irredundant
set of prime ideals. Throughout the algorithm,

T
T
however, it is always true that J =
I∈D I ∩
I∈P I . Since the final D = ∅, the final P satisfies
T
J = I∈P I.
23

Acknowledgments
CC was supported by NSF DMS 0920845 and NSF DMS 1225666, a Woodrow Wilson Career Enhancement Fellowship, and an Alfred P. Sloan Research Fellowship. VI was supported by NSF DMS
0967377, NSF DMS 1122519, and the Swartz Foundation.

6
6.1

Appendix 1: Proofs
Proof of Lemmas 3.1 and 3.2

To prove Lemmas 3.1 and 3.2, we need a version of the Nullstellensatz for finite fields. The original “Hilbert’s Nullstellensatz” applies when√ k is an algebraically closed field. It states that if
f ∈ k[x1 , . . . , xn ] vanishes on V (J), then f ∈ J. In other words,
√
I(V (J)) = J.
Because we have chosen k = F2 = {0, 1}, we have to be a little careful about the usual ideal-variety
correspondence,
as there are some subtleties introduced in the case of finite fields. In particular,
√
J = J in F2 [x1 , . . . , xn ] does not imply I(V (J)) = J.
The following lemma and theorem are well-known. Let Fq be a finite field of size q, and Fq [x1 , . . . , xn ]
the n-variate polynomial ring over Fq .
Lemma 6.1. For any ideal J ⊆ Fq [x1 , . . . , xn ], the ideal J + hxq1 − x1 , . . . , xqn − xn i is a radical ideal.
Theorem 6.2 (Strong Nullstellensatz in Finite Fields). For an arbitrary finite field Fq , let J ⊆
Fq [x1 , . . . , xn ] be an ideal. Then,
I(V (J)) = J + hxq1 − x1 , . . . , xqn − xn i.
Proof of Lemma 3.1
We begin by describing the maximal ideals of F2 [x1 , . . . , xn ]. Recall that
def

mv = I(v) = {f ∈ F2 [x1 , . . . , xn ] | f (v) = 0}
is the maximal ideal of F2 [x1 , . . . , xn ] consisting of all functions that vanish on v ∈ Fn2 . We will use
the notation m̄v to denote the quotient of mv in RC , in cases where mv ⊃ IC .
Lemma 6.3. mv = hx1 − v1 , . . . , xn − vn i ⊂ F2 [x1 , . . . , xn ], and is a radical ideal.
Proof. Denote Av = hx1 − v1 , . . . , xn − vn i, and observe that V (Av ) = {v}. It follows that I(V (Av )) =
I(v) = mv . On the other hand, using the Strong Nullstellensatz in Finite Fields we have
I(V (Av )) = Av + hx21 − x1 , . . . , x2n − xn i = Av ,
where the last equality is obtained by observing that, since vi ∈ {0, 1} and x2i − xi = xi (1 − xi ), each
generator of hx21 − x1 , . . . , x2n − xn i is already contained in Av . We conclude that Av = mv , and the
ideal is radical by Lemma 6.1.
In the proof of Lemma 3.1, we make use of the following correspondence: for any quotient ring R/I,
the maximal ideals of R/I are exactly the quotients m̄ = m/I, where m is a maximal ideal of R that
contains I [26].
24

Proof of Lemma 3.1. First, recall that because RC is a Boolean ring, Spec(RC ) = maxSpec(RC ), the
set of all maximal ideals of RC . We also know that the maximal ideals of F2 [x1 , . . . , xn ] are exactly
those of the form mv for v ∈ Fn2 . By the correspondence stated above, to show that maxSpec(RC ) =
{m̄v | v ∈ C} it suffices to show mv ⊃ IC if and only if v ∈ C. To see this, note that for each v ∈ C,
IC ⊆ mv because, by definition, all elements of IC are functions that vanish on each v ∈ C. On the
other hand, if v ∈
/ C then mv 6⊇ IC ; in particular, the characteristic function ρv ∈ IC for v ∈
/ C, but
ρv ∈
/ mv because ρv (v) = 1. Hence, the maximal ideals of RC are exactly those of the form m̄v for
v ∈ C.
We have thus verified that the points in Spec(RC ) correspond to codewords in C. This was expected
given our original definition of the neural ring, and suggests that the relations on F2 [x1 , . . . , xn ] imposed
by IC are simply relations ensuring that V (m̄v ) = ∅ for all v ∈
/ C.
Proof of Lemma 3.2
Here we find explicit relations for IC in the case of an arbitrary neural code. Recall that
ρv =

n
Y
((xi − vi ) − 1) =
i=1

Y
{i | vi =1}

xi

Y

(1 − xj ),

{j | vj =0}

and that ρv (x) can be thought of as a characteristic function for v, since it satisfies ρv (v) = 1 and
ρv (x) = 0 for any other x ∈ Fn2 . This immediately implies that
V (JC ) = V (h{ρv | v ∈
/ C}i) = C.
We can now prove Lemma 3.2.
Proof of Lemma 3.2. Observe that IC = I(C) = I(V (JC )), since V (JC ) = C. On the other hand, the
Strong Nullstellensatz in Finite Fields implies I(V (JC )) = JC + hx21 − x1 , . . . , x2n − xn i = JC + B.

6.2

Proof of Theorem 4.1

Recall that for a given set of receptive fields U = {U1 , . . . , Un } in some stimulus space X, the ideal
IU ⊂ F2 [x1 , . . . , xn ] was defined as:
Y
[

def 

IU = {xσ
(1 − xi ) | Uσ ⊆
Ui } .
i∈τ

i∈τ

The Boolean relations are present in IU irrespective of U, as it is always true that Ui ⊆ Ui and this
yields the relation xi (1 − xi ) for each i. By analogy with our definition of JC , it makes sense to define
an ideal JU which is obtained by stripping away the Boolean relations. This will then be used in the
proof of Theorem 4.1.
S
Note that if σ ∩ τ 6= ∅, then for any i ∈ σ ∩ τ we have Uσ ⊆ Ui ⊆ j∈τ Ui , and the corresponding
relation is a multiple of the Boolean relation xi (1 − xi ). We can thus restrict attention to relations in
IU that have σ ∩ τ = ∅, so long as we include separately the Boolean relations. These observations are
summarized by the following lemma.
Lemma 6.4. IU = JU + hx21 − x1 , . . . , x2n − xn i, where
Y
[

def 

JU = {xσ
(1 − xi ) | σ ∩ τ = ∅ and Uσ ⊆
Ui } .
i∈τ

i∈τ

25

Proof of Theorem 4.1. We will show that JU = JC(U ) (and thus that IU = IC(U ) ) by showing that each
ideal contains the generators of the other.
First, we show that all generating relations of JC(U ) are contained in JU . Recall that the generators
of JC(U ) are of the form
Y

ρv =

i∈supp(v)

xi

Y

(1 − xj ) for v ∈
/ C(U).

j ∈supp(v)
/

If ρ is a generator of JC(U ) , then v ∈
/ C(U) and this implies (by the definition of C(U)) that Usupp(v) ⊆
S v
S
U
.
Taking
σ
=
supp(v)
and τ = [n] \ supp(v), we have Uσ ⊆ j∈τ Uj with σ ∩ τ = ∅.
j
j ∈supp(v)
/
Q
This in turn tells us (by the definition of JU ) that xσ j∈τ (1 − xj ) is a generator of JU . Since
Q
ρv = xσ j∈τ (1 − xj ) for our choice of σ and τ , we conclude that ρv ∈ JU . Hence, JC(U ) ⊆ JU .
Next, we show that all generating relations of JU are contained in JC(U ) . If JU has generator
Q
S
T
S
xσ i∈τ (1−xi ), then Uσ ⊆ i∈τ Ui and σ ∩τ = ∅. This in turn implies that i∈σ Ui \ j∈τ Uj = ∅, and
thus (by the definition of C(U)) we have v ∈
/ C(U) for any v such that supp(v) ⊇ σ and supp(v) ∩ τ = ∅.
Q
It follows that JC(U ) contains the relation xsupp(v) j ∈supp(v)
(1 − xj ) for any such v. This includes all
/
Q
Q
Q
P
,
where
P
∈
{xk , 1 − xk }. Taking f = xσ j∈τ (1 − xj )
relations of the form xσ j∈τ (1 − xj ) k∈σ∪τ
k
k
/
Q
in Lemma 6.5 (below), we can conclude that JC(U ) contains xσ j∈τ (1 − xj ). Hence, JU ⊆ JC(U ) .
 Q
	
Lemma 6.5. For any f ∈ k[x1 , . . . , xn ] and τ ⊆ [n], the ideal h f i∈τ Pi | Pi ∈ {xi , 1 − xi } i = hf i.
	
def  Q
Proof. First, denote If (τ ) = h f i∈τ Pi | Pi ∈ {xi , 1 − xi } i. We wish to prove that If (τ ) = hf i,
for any τ ⊆ [n]. Clearly, If (τ ) ⊆ hf i, since every generator of If (τ ) is a multiple of f . We will prove
If (τ ) ⊇ hf i by induction on |τ |.
If |τ | = 0, then τ = ∅ and If (τ ) = hf i. If |τ | = 1, so that τ = {i} for some i ∈ [n], then
If (τ ) = hf (1 − xi ), f xi i. Note that f (1 − xi ) + f xi = f , so f ∈ If (τ ), and thus If (τ ) ⊇ hf i.
Now, assume that for some ` ≥ 1 we have If (σ) ⊇ hf i for any σ ⊆ [n] with |σ| ≤ `. If ` ≥ n, we
are done, so we need only show that if ` < n, then If (τ ) ⊇ hf i for any τ of size ` + 1. Consider τ ⊆ [n]
with |τ | = ` + 1, and let j ∈ τ be any element. Define τ 0 = τ \{j}, and note that |τ 0 | = `. By our
inductive assumption, If (τ 0 ) ⊇ hf i. We will show that If (τ ) ⊇ If (τ 0 ), and hence If (τ ) ⊇ hf i.
Q
Q
Let g = f i∈τ 0 Pi be any generator of If (τ 0 ) and observe that both f (1 − xj ) i∈τ 0 Pi and
Q
f xj i∈τ 0 Pi are both generators of If (τ ). It follows that their sum, g, is also in If (τ ), and hence
g ∈ If (τ ) for any generator g of If (τ 0 ). We conclude that If (τ ) ⊇ If (τ 0 ), as desired.

6.3

Proof of Theorem 4.3

We begin by showing that JU , first defined in Lemma 6.4, can be generated using the Type 1, Type
2 and Type 3 relations introduced in Section 4.2. From the proof of Theorem 4.1, we know that
JU = JC(U ) , so the following lemma in fact shows that JC(U ) is generated by the Type 1, 2 and 3
relations as well.
Lemma 6.6. For U = {U1 , . . . , Un } a collection of sets in a stimulus space X,
[ 	


Y
JU = {xσ | Uσ = ∅},
(1 − xi ) | X ⊆
Ui ,
i∈τ



xσ

Y

i∈τ

(1 − xi ) | σ, τ 6= ∅, σ ∩ τ = ∅, Uσ 6= ∅,

i∈τ

[
i∈τ

Ui 6= X, and Uσ ⊆

[

Ui

	

.

i∈τ

JU (equivalently, JC(U ) ) is thus generated by the Type 1, Type 3 and Type 2 relations, respectively.
26

Proof. Recall that in Lemma 6.4 we defined JU as:
Y
[

def 

(1 − xi ) | σ ∩ τ = ∅ and Uσ ⊆
Ui } .
JU = {xσ
i∈τ

i∈τ

Observe that if Uσ = ∅, then we can take τ = ∅ to obtain the Type 1 relation xσ , where we have used
Q
the fact that i∈∅ (1 − xi ) = 1. Any other relation with Uσ = ∅ and τ 6= ∅ would be a multiple of xσ .
We can thus write:
Y
[



JU = {xσ | Uσ = ∅}, {xσ
(1 − xi ) | τ 6= ∅, σ ∩ τ = ∅, Uσ 6= ∅, and Uσ ⊆
Ui } .
i∈τ

i∈τ

Q
Next, if σ = ∅ in the second set of relations above, then we have the relation i∈τ (1 − xi ) with
S
U∅ = X ⊆ i∈τ Ui . Splitting off these Type 3 relations, and removing multiples of them that occur if
S
i∈τ Ui = X, we obtain the desired result.
Next, we show that JU can be generated by reduced sets of the Type 1, Type 2 and Type 3 relations
given above. First, consider the Type 1 relations in Lemma 6.6, and observe that if τ ⊆ σ, then xσ
is a multiple of xτ . We can thus reduce the set of Type 1 generators needed by taking only those
corresponding to minimal σ with Uσ = ∅:
h{xσ | Uσ = ∅}i = h{xσ | σ is minimal w.r.t. Uσ = ∅}i.
Similarly, we find for the Type 3 relations:
[ 	 
 Y
[ 	

 Y
(1 − xi ) | X ⊆
Ui =
(1 − xi ) | τ is minimal w.r.t. X ⊆
Ui .
i∈τ

i∈τ

i∈τ

i∈τ

Q

Finally, we reduce the Type 2 generators. If ρ ⊆ σ and xρ i∈τ (1 − xi ) ∈ JU , then we also have
Q
xσ i∈τ (1 − xi ) ∈ JU . So we can restrict ourselves to only those generators for which σ is minimal
S
S
with respect to Uσ ⊆ i∈τ Ui . Similarly, we can reduce to minimal τ such that Uσ ⊆ i∈τ Ui . In
summary:
[
[ 	

 Y
xσ
(1 − xi ) | σ, τ 6= ∅, σ ∩ τ = ∅, Uσ 6= ∅,
Ui 6= X, and Uσ ⊆
Ui =



xσ

i∈τ

i∈τ

Y

[

(1 − xi ) | σ, τ 6= ∅, σ ∩ τ = ∅, Uσ 6= ∅,

i∈τ

w.r.t. Uσ ⊆

i∈τ

Ui 6= X, and σ, τ are each minimal

i∈τ

[

Ui

	

.

i∈τ

We can now prove Theorem 4.3.
Proof of Theorem 4.3. Recall that C = C(U), and that by the proof of Theorem 4.1 we have JC(U ) = JU .
By the reductions given above for the Type 1, 2 and 3 generators, we also know that JU can be reduced
to the form given in the statement of Theorem 4.3. We conclude that JC can be expressed in the desired
form.
To see that JC , as given in the statement of Theorem 4.3, is in canonical form, we must show that
the given set of generators is exactly the complete set of minimal pseudo-monomials for JC . First,
observe that the generators are all pseudo-monomials. If xσ is one of the Type 1 relations, and xσ ∈ hgi
Q
with hxσ i 6= hgi, then g = i∈τ xi for some τ ( σ. Since Uτ 6= ∅, however, it follows that g ∈
/ JC
27

and hence xσ is a minimal pseudo-monomial of JC . By a similar argument, the Type 2 and Type 3
relations above are also minimal pseudo-monomials in JC .
It remains only to show that there are no additional minimal pseudo-monomials in JC . Suppose
Q
S
f = xσ i∈τ (1 − xi ) is a minimal pseudo-monomial in JC . By Lemma 4.2, Uσ ⊆ i∈τ Ui and σ ∩ τ = ∅,
so f is a generator in the original definition of JU (Lemma 6.4). Since f is a minimal pseudo-monomial
Q
of JC , there does not exist a g ∈ JC such that g = xσ0 i∈τ 0 (1 − xi ) with either σ 0 ( σ or τ 0 ( τ .
S
Therefore, σ and τ are each minimal with respect to Uσ ⊆ i∈τ Ui . We conclude that f is one of the
generators for JC given in the statement of Theorem 4.3. It is a minimal Type 1 generator if τ = ∅, a
minimal Type 3 generator if σ = ∅, and is otherwise a minimal Type 2 generator. The three sets of
minimal generators are disjoint because the Type 1, Type 2 and Type 3 relations are disjoint, provided
X 6= ∅.

6.4

Proof of Proposition 4.5

Note that every polynomial obtained by the canonical form algorithm is a pseudo-monomial of JC .
This is because the algorithm constructs products of factors of the form xi or 1 − xi , and then reduces
them in such a way that no index is repeated in the final product, and there are no powers of any
xi or 1 − xi factor; we are thus guaranteed to end up with pseudo-monomials. Moreover, since the
products each have at least one factor in each prime ideal of the primary decomposition of JC , the
pseudo-monomials are all in JC . Proposition 4.5 states that this set of pseudo-monomials is precisely
the canonical form CF (JC ).
To prove Proposition 4.5, we will make use of the following technical lemma. Here zi , yi ∈ {xi , 1 −
Q
xi }, and thus any pseudo-monomial in F2 [x1 , . . . , xn ] is of the form j∈σ zj for some index set σ ⊆ [n].
Lemma 6.7. If yi1 · · · yim ∈ hzj1 , . . . , zj` i where {ik } and {jr } are each distinct sets of indices, then
yik = zjr for some k ∈ [m] and r ∈ [`].
Proof. Let f = yi1 · · · yim and P = {zj1 , . . . , zj` }. Since f ∈ hP i, then hP i = hP, f i, and so
V (hP i) = V (hP, f i). We need to show that yik = zjr for some pair of indices ik , jr . Suppose by
way of contradiction that there is no ik , jr such that yik = zjr .
Select a ∈ {0, 1}n as follows: for each jr ∈ {j1 , . . . , j` }, let ajr = 0 if zjr = xjr , and let ajr = 1
if zjr = 1 − xjr ; when evaluating at a, we thus have zjr (a) = 0 for all r ∈ [`]. Next, for each
def

ik ∈ ω = {i1 , . . . , im }\{j1 , .., j` }, let aik = 1 if yik = xik , and let aik = 0 if yik = 1 − xik , so that
yik (a) = 1 for all ik ∈ ω. For any remaining indices t, let at = 1. Because we have assumed that
yik 6= zjr for any ik , jr pair, we have for any i ∈ {i1 , . . . , im } ∩ {j1 , . . . , j` } that yi (a) = 1 − zi (a) = 1.
It follows that f (a) = 1.
Now, note that a ∈ V (hP i) by construction. We must therefore have a ∈ V (hP, f i), and hence
f (a) = 0, a contradiction. We conclude that there must be some ik , jr with yik = zjr , as desired.
We can now prove the Proposition.
Proof of Proposition 4.5. It suffices to show that after Step 4 of the algorithm, the reduced set M̃(JC )
consists entirely of pseudo-monomials of JC , and includes all minimal pseudo-monomials of JC . If this
is true, then after removing multiples of lower-degree elements in Step 5 we are guaranteed to obtain
the set of minimal pseudo-monomials, CF (JC ), since it is precisely the non-minimal pseudo-monomials
that will be removed in the final step of the algorithm.
T
Let JC = si=1 Pi be the primary decomposition of JC , with each Pi a prime ideal of the form
Pi = hzj1 , . . . , zj` i. Recall that M(JC ), as defined in Step 3 of the algorithm, is precisely the set of all
28

polynomials g that are obtained by choosing one linear factor from the generating set of each Pi :
M(JC ) = {g = zp1 · · · zps | zpi is a linear generator of Pi }.
Furthermore, recall that M̃(JC ) is obtained from M(JC ) by the reductions in Step 4 of the algorithm.
Clearly, all elements of M̃(JC ) are pseudo-monomials that are contained in JC .
To show that M̃(JC ) contains all minimal pseudo-monomials of JC , we will show that if f ∈ JC
is a pseudo-monomial, then there exists another pseudo-monomial h ∈ M̃(JC ) (possibly the same as
f ) such that h|f . To see this, let f = yi1 · · · yim be a pseudo-monomial of JC . Then, f ∈ Pi for each
i ∈ [s]. For a given Pi = hzj1 , . . . , zj` i, by Lemma 6.7 we have yik = zjr for some k ∈ [m] and r ∈ [`].
In other words, each prime ideal Pi has a generating term, call it zpi , that appears as one of the linear
factors of f . Setting g = zp1 · · · zps , it is clear that g ∈ M(JC ) and that either g|f , or zpi = zpj for
some distinct pair i, j. By removing repeated factors in g one obtains a pseudo-monomial h ∈ M̃(JC )
such that h|g and h|f . If we take f to be a minimal pseudo-monomial, we find f = h ∈ M̃(JC ).

6.5

Proof of Lemmas 5.8 and 5.9

Here we prove Lemmas 5.8 and 5.9, which underlie the primary decomposition algorithm.
Proof of Lemma 5.8. Assume f ∈ hJ, zi is a pseudo-monomial. Then f = zi1 zi2 · · · zir , where zi ∈
{xi , 1 − xi } for each i, and the ik are distinct. Suppose f ∈
/ hzi. This implies zik 6= z for all factors
appearing in f . We will show that either f ∈ J or (1 − z)f ∈ J.
Since J is a pseudo-monomial ideal, we can write
J = hzg1 , . . . , zgk , (1 − z)f1 , . . . , (1 − z)fl , h1 , . . . , hm i,
where the gj , fj and hj are pseudo-monomials that contain no z or 1 − z term. This means
f = zi1 zi2 · · · zir = z

k
X

uj gj + (1 − z)

j=1

l
X

vj fj +

m
X

j=1

wj hj + yz,

j=1

for polynomials uj , vj , wj , and y ∈ F2 [x1 , . . . , xn ]. Now consider what happens if we set z = 0 in f :
f |z=0 = zi1 zi2 · · · zir |z=0 =

l
X

vj |z=0 fj +

j=1

m
X

wj |z=0 hj .

j=1

Next, observe that after multiplying the above by (1 − z) we obtain an element of J:
(1 − z)f |z=0 = (1 − z)

l
X

vj |z=0 fj + (1 − z)

j=1

m
X

wj |z=0 hj ∈ J,

j=1

since (1 − z)fj ∈ J for j = 1, . . . , l and hj ∈ J for j = 1, . . . , m. There are two cases:
Case 1: If 1 − z is a factor of f , say zi1 = 1 − z, then f |z=0 = zi2 · · · zir and thus f = (1 − z)f |z=0 ∈ J.
Case 2: If 1 − z is not a factor of f , then f = f |z=0 . Multiplying by 1 − z we obtain (1 − z)f ∈ J.
We thus conclude that f ∈
/ hzi implies f ∈ J or (1 − z)f ∈ J.

29

Proof of Lemma 5.9. Clearly, hJ, zσ i ⊆
We have three cases.

T

i∈σ hJ, zi i.

To see the reverse inclusion, consider f ∈

T

i∈σ hJ, zi i.

Case 1: f ∈ J. Then, f ∈ hJ, zσ i.
Case 2: f ∈
/ J, but f ∈ hzi i for all i ∈ σ. Then f ∈ hzσ i, and hence f ∈ hJ, zσ i.
Case 3: f ∈
/ J and f ∈
/ hzi i for all i ∈ τ ⊂ σ, but f ∈ hzj i for all j ∈ σ \ τ . Without loss of generality,
we can rearrange indices so that τ = {1, . . . , m} for m ≥ 1. By Lemma 5.8, we have (1−zi )f ∈ J
for all i ∈ τ . We can thus write:
f = (1 − z1 )f + z1 (1 − z2 )f + . . . + z1 · · · zm−1 (1 − zm )f + z1 · · · zm f.
Observe that the first m terms are each in J. On the other hand, f ∈ hzj i for each j ∈ σ \ τ
implies that the last term is in hzτ i ∩ hzσ\τ i = hzσ i. Hence, f ∈ hJ, zσ i.
T
We may thus conclude that i∈σ hJ, zi i ⊆ hJ, zσ i, as desired.

6.6

Proof of Theorem 5.4

Recall that JC is always a proper pseudo-monomial ideal for any nonempty neural code C ⊆ {0, 1}n .
Theorem 5.4 is thus a direct consequence of the following proposition.
Proposition 6.8. Suppose J ⊂ F2 [x1 , . . . , xn ] is a proper pseudo-monomial ideal. Then, J has a
T
unique irredundant primary decomposition of the form J = a∈A pa , where {pa }a∈A are the minimal
primes over J.
Proof. By Proposition 5.11, we can always (algorithmically) obtain an irredundant set P of prime ideals
T
such that J = I∈P I. Furthermore, each I ∈ P has the form I = hzi1 , . . . , zik i, where zi ∈ {xi , 1 − xi }
for each i. Clearly, these ideals are all prime ideals of the form pa for a ∈ {0, 1, ∗}. It remains only to
show that this primary decomposition is unique, and that the ideals {pa }a∈A are the minimal primes
over J. This is a consequence of some well-known facts summarized in Lemmas 6.9 and 6.10, below.
First, observe by Lemma 6.9 that J is a radical ideal. Lemma 6.10 then tells us that the decomposition
in terms of minimal primes is the unique irredundant primary decomposition for J.
T
Lemma 6.9. If J is the intersection of prime ideals, J = `i=1 pi , then J is a radical ideal.
Proof. Suppose pn ∈ J. Then pn ∈ pi for all i ∈ [`], and hence p ∈ pi for all i ∈ [`]. Therefore,
p ∈ J.
The following fact about the primary decomposition of radical ideals is true over any field, as a
consequence of the Lasker-Noether theorems [24, pp. 204-209].
Lemma 6.10. If J is a proper radical ideal, then it has a unique irredundant primary decomposition
consisting of the minimal prime ideals over J.

30

7

Appendix 2: Neural codes on three neurons

Label
A1
A2
A3
A4
A5
A6
A7
A8
A9
A10
A11
A12
A13
A14
A15
A16*
A17*
A18*
A19*
A20*
B1
B2
B3
B4
B5
B6*
C1
C2
C3*
D1
E1
E2
E3
E4
F1*
F2*
F3*
G1*
H1*
I1*

Code C
000,100,010,001,110,101,011,111
000,100,010,110,101,111
000,100,010,001,110,101,111
000,100,010,110,101,011,111
000,100,010,110,111
000,100,110,101,111
000,100,010,101,111
000,100,010,001,110,111
000,100,001,110,011,111
000,100,010,101,011,111
000,100,110,101,011,111
000,100,110,111
000,100,010,111
000,100,010,001,111
000,110,101,011,111
000,100,011,111
000,110,101,111
000,100,111
000,110,111
000,111
000,100,010,001,110,101
000,100,010,110,101
000,100,010,101,011
000,100,110,101
000,100,110,011
000,110,101
000,100, 010,001, 110
000,100,010,101
000,100,011
000,100,010,001
000,100,010,001,110,101,011
000,100,010,110,101,011
000,100,110,101,011
000,110,011,101
000,100,010,110
000,100,110
000,110
000,100
000
000,100,010

Canonical Form CF (JC )
∅
x3 (1 − x1 )
x2 x3 (1 − x1 )
x3 (1 − x1 )(1 − x2 )
x3 (1 − x1 ), x3 (1 − x2 )
x2 (1 − x1 ), x3 (1 − x1 )
x3 (1 − x1 ), x1 x2 (1 − x3 )
x1 x3 (1 − x2 ), x2 x3 (1 − x1 )
x3 (1 − x2 ), x2 (1 − x1 )(1 − x3 )
x3 (1 − x1 )(1 − x2 ), x1 x2 (1 − x3 )
x2 (1 − x1 )(1 − x3 ), x3 (1 − x1 )(1 − x2 )
x3 (1 − x1 ), x3 (1 − x2 ), x2 (1 − x1 )
x3 (1 − x1 ), x3 (1 − x2 ), x1 x2 (1 − x3 )
x1 x2 (1 − x3 ), x2 x3 (1 − x1 ), x1 x3 (1 − x2 )
x1 (1 − x2 )(1 − x3 ), x2 (1 − x1 )(1 − x3 ), x3 (1 − x1 )(1 − x2 )
x2 (1 − x3 ), x3 (1 − x2 )
x2 (1 − x1 ), x3 (1 − x1 ), x1 (1 − x2 )(1 − x3 )
x2 (1 − x1 ), x2 (1 − x3 ), x3 (1 − x1 ), x3 (1 − x2 )
x3 (1 − x1 ), x3 (1 − x2 ), x1 (1 − x2 ), x2 (1 − x1 )
x1 (1 − x2 ), x2 (1 − x3 ), x3 (1 − x1 ), x1 (1 − x3 ), x2 (1 − x1 ), x3 (1 − x2 )
x2 x3
x2 x3 , x3 (1 − x1 )
x1 x2 , x3 (1 − x1 )(1 − x2 )
x2 x3 , x2 (1 − x1 ), x3 (1 − x1 )
x1 x3 , x3 (1 − x2 ), x2 (1 − x1 )(1 − x3 )
x2 x3 , x2 (1 − x1 ), x3 (1 − x1 ), x1 (1 − x2 )(1 − x3 )
x1 x3 , x2 x3
x1 x2 , x2 x3 , x3 (1 − x1 )
x1 x2 , x1 x3 , x2 (1 − x3 ), x3 (1 − x2 )
x1 x2 , x2 x3 , x1 x3
x1 x2 x3
x1 x2 x3 , x3 (1 − x1 )(1 − x2 )
x1 x2 x3 , x2 (1 − x1 )(1 − x2 ), x3 (1 − x1 )(1 − x2 )
x1 x2 x3 , x1 (1 − x2 )(1 − x3 ), x2 (1 − x1 )(1 − x3 ), x3 (1 − x1 )(1 − x2 )
x3
x3 , x2 (1 − x1 )
x3 , x1 (1 − x2 ), x2 (1 − x1 )
x2 , x 3
x1 , x 2 , x 3
x3 , x 1 x2

Table 1: Forty permutation-inequivalent codes, each containing 000, on three neurons. Labels A–I indicate
the various families of Type 1 relations present in CF (JC ), organized as follows (up to permuation of indices):
(A) None, (B) {x1 x2 }, (C) {x1 x2 , x2 x3 }, (D) {x1 x2 , x2 x3 , x1 x3 }, (E) {x1 x2 x3 }, (F) {x1 }, (G) {x1 , x2 }, (H)
{x1 , x2 , x3 }, (I) {x1 , x2 x3 }. All codes within the same A–I series share the same simplicial complex, ∆(C). The
∗s denote codes that have Ui = ∅ for at least one receptive field (as in the F, G, H and I series) as well as
codes that require U1 = U2 or U1 = U2 ∪ U3 (up to permutation of indices); these are considered to be highly
degenerate. The remaining 27 codes are depicted with receptive field diagrams (Figure 6) and Boolean lattice
diagrams (Figure 7).

31

A1

A2

A3

A4

A5

1
1

1

2

2

1

1

2
3

2

3

3

3

2
3

A6

A7

1

1

A8

A9

A10

3
2

1
1

3

3

2

2

1

2

3

2

3

A11

A12

A13
1
2

1

A14

A15
1

3
1
1

2

3
2

2

3

3

3

2

B1

B3 non-convex

B2

B5 non-convex

B4

1
1
3

2

C1

2

1

3

2

1

3

2

3

3

2

D1

C2

1

1

2

3

1
1

2
3
3

2
E2 non-convex

E1
1

2

E3 non-convex
2

1

3

2

E4 non-convex
2

1

1
3

3

3

Figure 6: Receptive field diagrams for the 27 non-∗ codes on three neurons listed in Table 1. Codes that admit
no realization as a convex RF code are labeled “non-convex.” The code E2 is the one from Lemma 2.2, while
A1 and A12 are permutation-equivalent to the codes in Figure 3A and 3C, respectively. Deleting the all-zeros
codeword from A6 and A4 yields codes permutation-equivalent to those in Figure 3B and 3D, respectively.

32

A1

A2

111

110

101

010
001

100

001

000

A6

111

110

101

010
001 100

001

000

A11

A12

010
001 100

001

000

B2

111

110

011 110

101
010

001

C1

111

C2
011 110 101

110
101

011

E1

111

010
001

101

E3

E4
011 110

101

001
000

111
011

101
010

010

001 100
000

111

011 110

010

010
100

001
000

111

011 110 101

110

100

000

E2

001

011

101

001 100
000

100

111

110

010

010
100

011

101

000

000

D1

000
111

010
001

000

001

B5
011 110

001 100

000
111

011

100

010

010
001 100

000

000
111

011 110 101

101

100

001

B4

111

010

010

011 110

101

A15
011 110 101

101

111

001
000

111

001 100

B3

100

000

A14

011

010

011 110

100

010

100

111

111
101

001

000

000
111

000

011 110

101

100

010

010

100

B1

A13

001

A10

010
001

011 110 101

101

010

111

000

111

011 110

101

011 110

100

000

111

110

111

011

101

000

A9

010

010

100

111

001 100

000

011 110 101

011 110

101

010
001 100

A8

111

011 110

101

100

000

A7

A5

111

011 110

010

010

100

A4

111

011 110 101

011 110

101

A3

111

001 100

100
000

001
000

Figure 7: Boolean lattice diagrams for the 27 non-∗ codes on three neurons listed in Table 1. Interval decompositions (see Section 5.2) for each code are depicted in black, while decompositions of code complements, arising
from CF (JC ), are shown in gray. Thin black lines connect elements of the Boolean lattice that are Hamming
distance 1 apart. Note that the lattice in A12 is permutation-equivalent to the one depicted in Figure 5.

33

References
[1] J. O’Keefe and J. Dostrovsky. The hippocampus as a spatial map. preliminary evidence from
unit activity in the freely-moving rat. Brain Research, 34(1):171–175, 1971.
[2] B. L. McNaughton, F. P. Battaglia, O. Jensen, E. I. Moser, and M. B. Moser. Path integration
and the neural basis of the ’cognitive map’. Nat Rev Neurosci, 7(8):663–78, 2006.
[3] D.W. Watkins and M.A. Berkley. The orientation selectivity of single neurons in cat striate
cortex. Experimental Brain Research, 19:433–446, 1974.
[4] R. Ben-Yishai, R. L. Bar-Or, and H. Sompolinsky. Theory of orientation tuning in visual cortex.
Proc Natl Acad Sci U S A, 92(9):3844–8, 1995.
[5] E. N. Brown, L. M. Frank, D. Tang, M. C. Quirk, and M. A. Wilson. A statistical paradigm
for neural spike train decoding applied to position prediction from ensemble firing patterns of rat
hippocampal place cells. J Neurosci, 18(18):7411–25, 1998.
[6] S. Deneve, P. E. Latham, and A. Pouget. Reading population codes: a neural implementation of
ideal observers. Nat Neurosci, 2(8):740–5, 1999.
[7] W. J. Ma, J. M. Beck, P. E. Latham, and A. Pouget. Bayesian inference with probabilistic
population codes. Nat Neurosci, 9(11):1432–8, 2006.
[8] S. Nirenberg and P. E. Latham. Decoding neuronal spike trains: How important are correlations?
Proceedings of the National Academy of Sciences of the United States of America, 100(12):7348–
7353, 2003.
[9] B. B. Averbeck, P. E. Latham, and A. Pouget. Neural correlations, population coding and
computation. Nat Rev Neurosci, 7(5):358–66, 2006.
[10] E. Schneidman, M. Berry II, R. Segev, and W. Bialek. Weak pairwise correlations imply strongly
correlated network states in a neural population. Nature, 440(20):1007–1012, 2006.
[11] C. Curto and V. Itskov. Cell groups reveal structure of stimulus space. PLoS Computational
Biology, 4(10), 2008.
[12] Ezra Miller and Bernd Sturmfels. Combinatorial Commutative Algebra. Graduate Texts in Mathematics. Springer, 2005.
[13] Richard Stanley. Combinatorics and Commutative Algebra. Progress in Mathematics. Birkhauser
Boston, 2004.
[14] A. Jarrah, R. Laubenbacher, B. Stigler, and M. Stillman. Reverse-engineering of polynomial
dynamical systems. Advances in Applied Mathematics, 39:477–489, 2007.
[15] Alan Veliz-Cuba. An algebraic approach to reverse engineering finite dynamical systems arising
from biology. SIAM Journal on Applied Dynamical Systems, 11(1):31–48, 2012.
[16] Anne Shiu and Bernd Sturmfels. Siphons in chemical reaction networks. Bulletin of Mathematical
Biology, 72(6):1448–1463, 2010.

34

[17] Giovanni Pistone, Eva Riccomagno, and Henry P. Wynn. Algebraic statistics, volume 89 of
Monographs on Statistics and Applied Probability. Chapman & Hall/CRC, Boca Raton, FL,
2001. Computational commutative algebra in statistics.
[18] E. Schneidman, J. Puchalla, R. Segev, R. Harris, W. Bialek, and M. Berry II. Synergy from
silence in a combinatorial neural code. arXiv:q-bio.NC/0607017, 2006.
[19] L. Osborne, S. Palmer, S. Lisberger, and W. Bialek. The neural basis for combinatorial coding
in a cortical population response. Journal of Neuroscience, 28(50):13522–13531, 2008.
[20] Ludwig Danzer, Branko Grünbaum, and Victor Klee. Helly’s theorem and its relatives. In Proc.
Sympos. Pure Math., Vol. VII, pages 101–180. Amer. Math. Soc., Providence, R.I., 1963.
[21] Allen Hatcher. Algebraic topology. Cambridge University Press, Cambridge, 2002.
[22] Gil Kalai. Characterization of f -vectors of families of convex sets in Rd . I. Necessity of Eckhoff’s
conditions. Israel J. Math., 48(2-3):175–195, 1984.
[23] Gil Kalai. Characterization of f -vectors of families of convex sets in Rd . II. Sufficiency of Eckhoff’s
conditions. J. Combin. Theory Ser. A, 41(2):167–188, 1986.
[24] David Cox, John Little, and Donal O’Shea. Ideals, varieties, and algorithms. Undergraduate
Texts in Mathematics. Springer-Verlag, New York, second edition, 1997. An introduction to
computational algebraic geometry and commutative algebra.
[25] David Eisenbud, Daniel R. Grayson, Michael Stillman, and Bernd Sturmfels, editors. Computations in algebraic geometry with Macaulay 2, volume 8 of Algorithms and Computation in
Mathematics. Springer-Verlag, Berlin, 2002.
[26] M. F. Atiyah and I. G. Macdonald. Introduction to commutative algebra. Addison-Wesley Publishing Co., Reading, Mass.-London-Don Mills, Ont., 1969.

35

