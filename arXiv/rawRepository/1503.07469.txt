Properties of Sparse Distributed Representations
and their Application to Hierarchical Temporal
Memory
Subutai Ahmad and Jeff Hawkins
Numenta
Redwood City, CA 94063
sahmad@numenta.com, jhawkins@numenta.com
March 24, 2015
Abstract
Empirical evidence demonstrates that every region of the neocortex
represents information using sparse activity patterns. This paper examines
Sparse Distributed Representations (SDRs), the primary information
representation strategy in Hierarchical Temporal Memory (HTM) systems
and the neocortex. We derive a number of properties that are core to scaling,
robustness, and generalization. We use the theory to provide practical
guidelines and illustrate the power of SDRs as the basis of HTM. Our goal is
to help create a unified mathematical and practical framework for SDRs as it
relates to cortical function.

I. Introduction
Our neocortex continually processes an endless stream of rich sensory information. It
does this remarkably well, better than any existing computer. A wealth of empirical
evidence demonstrates that cortical regions represent all information using sparse
patterns of activity. To function effectively throughout a lifetime these representations
must have tremendous capacity and must be extremely tolerant to noise. However, a
detailed theoretical understanding of the capacity and robustness of cortical sparse
representations has been missing.
Cortical representations are such that only a small percentage of neurons are very
active while the rest remain relatively inactive, and hence the activity is considered
sparse; the result of inhibitory neurons. The representations are considered distributed
because the information is encoded not just in a single neuron but across a set of active
neurons. Sparse distributed representations (SDRs) encode information throughout the
cortex, and for a diverse variety of functions. The representations exist in early auditory
and visual areas (HromÃ¡dka et al., 2008; Weliky et al., 2003), corresponding to sensory
features such as audio frequencies, and visual lines and edges. The SDRs in later sensory
areas encode more abstract and categorical information. Similarly, both concrete motor
commands (Sanes & Donoghue, 2000) and abstract behavioral planning (Graziano et al.,
2002) are represented via sparse distributed encodings in primary motor and premotor
areas, respectively.
This paper analyzes certain properties and operations of SDRs relevant to cortical
encoding. The binary SDR operations examined here are motivated by neuroscience and

	 Â 

1	 Â 

central to generalization, high order sequence memory, and achieving invariant
representations in HTM learning algorithms. We derive classification error bounds and
capacity scaling laws based on these operations. The results demonstrate that neurons
encoding information via SDRs have massive representational power. Robustness to
noise is high enough such that reliable classification can be performed with as much as
50% noise. We analyze the â€œunion propertyâ€ and show how it can be used to make
multiple temporal predictions reliably.
The theory behind sparse representations has become a topic of significant interest in
recent years. They have been studied in the context of theoretical neuroscience (Kanerva,
1988, Olshausen and Field, 2004), statistics (Tibshirani, 1996), machine learning (Lee,
2008), compressed sensing (Donoho, 2006), and even web server data structures (Broder
and Mitzenmacher, 2004). In our analysis we lean on the intuitions provided by Kanerva
(Kanerva, 1988, Kanerva, 1997) as well as some of the techniques used for analyzing
Bloom filters (Bloom, 1970). This discussion follows in Section II. The application of
these properties to a number of different aspects of the HTM Learning Algorithm, as
described in (Hawkins and Ahmad, 2010), is discussed in Section III. Section IV
concludes the paper with the advantages of SDRs as the mathematical base of HTM.

II. Mathematical Foundations of SDRs
In this section we discuss certain mathematical properties of SDRs, with a focus on
deriving fundamental scaling laws and error bounds. Properties such as probability of
mismatches, robustness in noise, subsampling, classifying vectors, and unions
demonstrate the usefulness of SDRs as a memory space. We illustrate properties and
operations with examples to give an intuition to the mathematics.

A. Definitions and Notation
SDRs: Given a population of ğ‘› neurons, their instantaneous activity is represented as
an SDR, i.e. an ğ‘› -dimensional vector of binary components, e.g. ğ‘¥ = ğ‘! , â€¦ , ğ‘!!! .
Typically these vectors are highly sparse ,i.e. a small percentage of the components are 1.
We use ğ‘¤! to denote the number of components in ğ‘¥ that are 1, i.e. ğ‘¤! = ğ‘¥ ! .
Overlap: We determine the similarity between two SDR encodings using an overlap
score. The overlap score is simply the number of bits that are ON in the same locations
in both vectors. If ğ‘¥ and ğ‘¦ are two binary SDRs, then the overlap can be computed as the
dot product:
ğ‘œğ‘£ğ‘’ğ‘Ÿğ‘™ğ‘ğ‘(ğ‘¥, ğ‘¦) â‰¡ ğ‘¥ âˆ™ ğ‘¦
Notice we do not use a typical distance metric, such as Hamming or Euclidean, to
quantify similarity. With overlap we can derive some useful properties discussed later,
which would not hold with these distance metrics.
Matching: We realize a match between two SDRs if their overlap exceeds some
threshold ğœƒ:
ğ‘šğ‘ğ‘¡ğ‘â„(ğ‘¥, ğ‘¦) â‰¡ ğ‘œğ‘£ğ‘’ğ‘Ÿğ‘™ğ‘ğ‘(ğ‘¥, ğ‘¦) â‰¥ ğœƒ
Typically ğœƒ is set such that ğœƒ â‰¤ ğ‘¤! and ğœƒ â‰¤ ğ‘¤! .

	 Â 

2	 Â 

Consider an example of two SDR vectors:
ğ‘¥ = [0100000000000000000100000000000110000000]
ğ‘¦ = [1000000000000000000100000000000110000000]
Both vectors have size ğ‘› = 40, and ğ‘¤ = 4. The overlap between ğ‘¥ and ğ‘¦ is 3, and thus
the two vectors match when ğœƒ = 3. Throughout the paper weâ€™ll present examples of
SDRs with sample parameters typical of current Hierarchical Temporal Memory (HTM)
implementations. These are listed below, and detailed later in Section III.
HTM parameters:
ğ‘› = 1024 to 65,536, representing the length of an SDR vector
ğ‘¤ = 10 to 40, representing the number of ON bits in an SDR vector
!
ğ‘  = 0.05% to 2.0%, representing the sparsity, where ğ‘  =
!

B. Uniqueness and Exact Matches
Given a fixed n and w, the number of unique SDR encodings is ğ‘› choose ğ‘¤:
ğ‘›!
ğ‘›
=
ğ‘¤
ğ‘¤! ğ‘› âˆ’ ğ‘¤ !

(1)

Note this is significantly smaller than the number of encodings possible with dense
representations, which is 2! . This implies a potential loss of information, as the number
of possible input patterns is much greater than the number of possible representations in
the SDR encoding. In practice this is meaningless. With ğ‘› = 40 and ğ‘¤ = 4, the number of
encodings is 91,390. With more typical values ğ‘› = 2048 and ğ‘¤ = 40 , the SDR
representation space is astronomically large at 2.37Ã—10!" encodings; the estimated
number of atoms in the observable universe is ~10!" .
Given two random SDR encodings with the same parameters, ğ‘¥ and ğ‘¦, the probability
they are identical is
ğ‘ƒ ğ‘¥ = ğ‘¦ = 1/

ğ‘›
ğ‘¤

(2)

With ğ‘› = 1024 and ğ‘¤ = 2 there are 523,776 possible encodings and the probability
two random encodings are identical is rather high, i.e. 1 in 523,776. This probability
decreases extremely rapidly as ğ‘¤ increases. With ğ‘¤ = 4, the probability dives to less
than 1 in 45 billion. For the HTM values ğ‘› = 2048 and ğ‘¤ = 40, the probability two
random encodings are identical is essentially zero. These calculations are carried out for
varying parameters in Table 1 of Appendix A.

C. Overlap Sets
We introduce the notion of an overlap set to help analyze the effects of matching under
varying conditions. Let ğ‘¥ be an SDR encoding. The overlap set of ğ‘¥ with respect to ğ‘ is
Î©! (ğ‘›, ğ‘¤, ğ‘), defined as the set of vectors of size ğ‘› with ğ‘¤ bits on, that have exactly ğ‘ bits

	 Â 

3	 Â 

of overlap with ğ‘¥. The number of such vectors is Î©! (ğ‘›, ğ‘¤, ğ‘) , the cardinality of the set.
Assuming ğ‘ â‰¤ ğ‘¤! and ğ‘ â‰¤ ğ‘¤,
Î©! (ğ‘›, ğ‘¤, ğ‘) =

ğ‘¤!
ğ‘› âˆ’ ğ‘¤!
Ã—
ğ‘
ğ‘¤âˆ’ğ‘

(3)

The first term in the product of (3) is the number of subsets of ğ‘¥ with ğ‘ bits ON, and
the second term is the number of other patterns containing ğ‘› âˆ’ ğ‘¤! bits, of which ğ‘¤ âˆ’ ğ‘
bits are on.

D. Inexact Matching
In general we would like the system to be somewhat tolerant to changes or noise in the
input. That is, it is rare to require exact matches where ğœƒ = ğ‘¤. Lowering Â ğœƒ decreases the
sensitivity and increases the overall noise robustness of the system. For example,
consider SDR vectors ğ‘¥ and ğ‘¥â€², where ğ‘¥â€² is corrupted by random noise. With ğ‘¤ = 40 and
ğœƒ lowered to 20, the noise can change 50% of the ON bits and still match ğ‘¥ to ğ‘¥â€².
Yet increasing the robustness comes with the cost of more false positives. That is,
decreasing ğœƒ also increases the probability of a false match with another random vector.
There is an inherent tradeoff in these parameters, as we would like the chance of a false
match to be as low as possible while retaining robustness. With appropriate parameter
values the SDRs can have a large amount of noise robustness with a very small chance of
false positives.
Given an SDR encoding ğ‘¥ and another random vector ğ‘¦, what is the probability of a
false match, i.e. the chance the ğ‘œğ‘£ğ‘’ğ‘Ÿğ‘™ğ‘ğ‘(ğ‘¥, ğ‘¦) â‰¥ ğœƒ? A match is defined as an overlap of ğœƒ
ğ‘›
bits or greater, up to ğ‘¤. With
total patterns, the probability of a false positive is:
ğ‘¤
!
ğ‘“ğ‘!

ğœƒ =

!
!!! |Î©!

ğ‘›
ğ‘¤

ğ‘›, ğ‘¤, ğ‘ |

(4)

Note an exact match occurs when ğœƒ = ğ‘¤. The numerator in (4) evaluates to 1, and the
equation reduces to (2).
For example, again suppose vector parameters ğ‘› = 1024 and ğ‘¤ = 4. If the threshold
is ğœƒ = 2, corresponding to 50% noise, then the probability of an error is one in 14,587.
That is, with 50% noise there is a significant chance of false matches. If ğ‘¤ and ğœƒ are
increased to 20 and 10, respectively, the probability of a false match decreases drastically
to less than 1 in 10!" . Thus, with a relatively modest increase in ğ‘¤ and ğœƒ (holding ğ‘›
fixed), SDRs can achieve essentially perfect robustness with up to 50% noise. These
calculations are carried out for varying parameters in Table 2 of Appendix A.
For the majority of cases we are interested in1, the first term in the numerator sum of
(4) dominates by at least an order of magnitude, thus (5) gives an excellent
approximation of the false positive likelihood:

	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 
1	 Â That is, whenever ğ‘¤ > 7 and ğœƒ > !.	 Â 
!
	 Â 

4	 Â 

!
ğ‘“ğ‘!
ğœƒ â‰ˆ

|Î©! ğ‘›, ğ‘¤, ğœƒ |
ğ‘›
ğ‘¤

(5)

E. Subsampling
An interesting property of SDRs is the ability to reliably compare against a subsampled
version of a vector. That is, recognizing a large distributed pattern by matching a small
subset of the active bits in the large pattern. Let ğ‘¥ be an SDR vector and let ğ‘¥â€² be a
subsampled version of ğ‘¥, such that ğ‘¤!! â‰¤ ğ‘¤! . The subsampled vector ğ‘¥â€² will always
match ğ‘¥, as long as ğœƒ â‰¤ ğ‘¤! , but as you increase the subsampling the chance of a false
positive increases.
What is the probability of a false match between Â ğ‘¥â€² a random vector ğ‘¦? Here the
overlap set is computed with respect to the subsample ğ‘¥ ! , rather than the full vector ğ‘¥. If
ğ‘ â‰¤ ğ‘¤!! and ğ‘¤!! â‰¤ ğ‘¤! then the number of patterns with exactly b bits of overlap with ğ‘¥â€²
is:
Î©!! (ğ‘›, ğ‘¤! , ğ‘) =

ğ‘› âˆ’ ğ‘¤!!
ğ‘¤!!
Ã— ğ‘¤ âˆ’ğ‘
ğ‘
!

(6)

Given a threshold ğœƒ â‰¤ ğ‘¤!! , the chance of a false positive then is:
!
ğ‘“ğ‘!
!

ğœƒ =

!!!
!!! |Î©!!

ğ‘›, ğ‘¤! , ğ‘ |
ğ‘›
ğ‘¤!

(7)

Notice (6) and (7) differ from (3) and (4), respectively, only in the vectors being
compared. That is, subsampling is simply a variant of the inexact matching properties
discussed above.
For instance, suppose ğ‘› = 1024 and ğ‘¤! = 8 . Subsampling half the bits in ğ‘¥ and
setting the threshold to 2 (i.e. ğ‘¤!! = 4, ğœƒ = 2), we find the probability of an error is one in
3,142. However, increasing ğ‘¤! to 20 and the relevant parameter ratios fixed (i.e.
ğ‘¤!! = 10, ğœƒ = 5) the chance of a false positive drops to 1 in 2.5 million. Increasing ğ‘› to
2048, ğ‘¤! = 40 , ğ‘¤!! = 20 , and ğœƒ = 10 , more practical HTM parameter values, the
probability of a false positive plummets to better than 1 in 10!" . This is remarkable
considering that the threshold is about 25% of the original number of bits. These
calculations are carried out for varying parameters in Table 2 of Appendix A.

F. Classifying a Set of Vectors
We consider a form of classification similar to nearest neighbor classification. Let ğ‘‹ be a
set of ğ‘€ vectors, ğ‘‹ = ğ‘¥! , â€¦ , ğ‘¥! , where each vector ğ‘¥! is an SDR. We assume that all
vectors in ğ‘‹ are unique with respect to matching, i.e.

	 Â 

5	 Â 

âˆ€!âˆˆ! âˆ€!âˆˆ!,!!! ğ‘šğ‘ğ‘¡ğ‘â„ ğ‘¥, ğ‘¦ = ğ‘“ğ‘ğ‘™ğ‘ ğ‘’

(8)

Given any vector ğ‘¦ we classify it as belonging to this set as follows:
ğ‘¦ âˆˆ ğ‘‹ Â  â‰¡  Â  âˆƒ!! âˆˆ! ğ‘šğ‘ğ‘¡ğ‘â„ ğ‘¥! , ğ‘¦ = ğ‘¡ğ‘Ÿğ‘¢ğ‘’

(9)

How reliably can we classify a vector ğ‘¥! corrupted by up to ğ‘¡ bits of noise? Assuming
ğ‘¡ â‰¤ ğ‘¤ âˆ’ ğœƒ, there are no false negatives in this scheme, only false positives. Our question
is then what is the probability the classification of a random vector ğ‘¦ is a false positive?
Since all vectors in ğ‘‹ are unique with respect to matching, the probability of a false
positive is bounded by:
!
!
ğ‘“ğ‘!
(ğ‘¡)
!

ğ‘“ğ‘! (ğ‘¡) â‰¤

(10)

!

!!!

This is an upper bound because it â€œdouble countsâ€ a vector that matches two
different vectors in X. In the special case where all vectors in Î§ have identical w, this is
just:
!
ğ‘“ğ‘! (ğœƒ) â‰¤ ğ‘€ğ‘“ğ‘!
(ğœƒ)

(11)

Consider for example ğ‘› = 64 and ğ‘¤ = 3 for all vectors. If ğœƒ = 2, 10 vectors can be
stored in the list and the probability of false positives is about 1 in 22. Increasing ğ‘¤ and ğœƒ
!

!

to 12 and 8, respectively, maintaining the ratio = , the chance of a false positive drops
!
!
to about 1 in 2363. Now increase the parameters to more realistic values: ğ‘› = 1024,
ğ‘¤ = 21, and ğœƒ = 14 (i.e. two-thirds of ğ‘¤). In this case the chance of a false positive with
10 vectors plummets to about 1 in 10!" . In fact, with these parameters the false positive
rate for storing a billion vectors is better than 1 in 10!" .
This result illustrates a remarkable property of SDRs. Suppose a large set of patterns
is encoded in SDRs, and stored in a list. A massive number of these patterns can be
retrieved almost perfectly, even in the presence of a large amount of noise. The main
requirement being the SDR parameters ğ‘›, ğ‘¤, and ğ‘¡ need to be sufficiently high. As
illustrated in the above example, low values such as ğ‘› = 64, ğ‘¤ = 3, etc. are insufficient
to capture these properties. These calculations are carried out for a variety of parameters
in Table 3 of Appendix A.

G. The Surprising Union Property
One of the most fascinating properties of SDRs is the ability to reliably store a set of
patterns in a single fixed representation by taking the OR of all the vectors. We call this
the â€œunion propertyâ€. To store a set of ğ‘€ vectors, the union mechanism is simply the

	 Â 

6	 Â 

Boolean OR of all the vectors, resulting in a new vector ğ‘‹. To determine if a new SDR ğ‘¦
is a member of the set, we simply compute the ğ‘šğ‘ğ‘¡ğ‘â„(ğ‘‹, ğ‘¦).

	 Â 
	 Â 
	 Â 
	 Â 

ğ‘¥! = [01000000000010000000 â€¦ 010]	 Â 
ğ‘¥! = [00000000000000000010 â€¦ 100]	 Â 
ğ‘¥! = [10100000000000000000 â€¦ 010]	 Â 
â‹®	 Â 
ğ‘¥!" = [00000000000000110000 â€¦ 010]	 Â 
ğ‘‹ = ğ‘¥! ğ‘‚ğ‘…ğ‘¥! ğ‘‚ğ‘…, . . . , ğ‘¥!" 	 Â 
ğ‘‹ = [11100000000110110000 â€¦ 110]	 Â 
ğ‘¦ = [10000000000001000000 â€¦ 001]	 Â 
âˆ´ ğ‘šğ‘ğ‘¡ğ‘â„(ğ‘‹, ğ‘¦) = 1	 Â 

Figure 1: (top) Taking the OR of a set of ğ‘€ SDR vectors results in the union vector ğ‘‹. With the
sparsity of each individual vector at 2%, and ğ‘€ = 10, it follows that the sparsity of ğ‘‹ is at most
20%. The logic is straightforward: if there is no overlap within the set of vectors, each ON bit will
correspond to its own ON bit in the union vector, summing the sparsities. With overlap,
however, ON bits will be shared in the union vector, resulting in a lower sparsity. (bottom)
Computing the ğ‘šğ‘ğ‘¡ğ‘â„ ğ‘‹, ğ‘¦ reveals if ğ‘¦ is a member of the union set ğ‘‹ â€“ i.e. if the ON positions in
ğ‘¦ are ON in ğ‘‹ as well.

The advantage of the union property is a fixed-size SDR vector can store a dynamic
set of elements. As such, a fixed set of cells and connections can operate on a dynamic
list. It also provides an alternate way to do classification. In HTMâ€™s, unions are used
extensively to make temporal predictions, for temporal pooling, to represent
invariances, and to create an effective hierarchy. However, there are limits on the
number of vectors that can be reliably stored in a set. That is, the union property has the
downside of increased potential for false positives.
How reliable is the union property? There is no risk of false negatives; if a given
vector is in the set, its bits will all be one regardless of the other patterns, and the overlap
will be perfect. However, the union property increases the likelihood of false positives.
With the number of vectors, ğ‘€, sufficiently large, the union set will become saturated
with ON bits, and almost any other random vector will return a false positive match.
Let us first calculate the probability of a false positive assuming exact matches, i.e.
ğœƒ = ğ‘¤. In this case, a false positive with a new random pattern ğ‘¦ occurs if all of the bits
!
in ğ‘¦ overlap with ğ‘‹. When ğ‘€ = 1, the probability any given bit is 0 is given by 1 âˆ’ . As
!
ğ‘€ grows, this probability is given by
ğ‘! = 1 âˆ’

	 Â 

ğ‘¤
ğ‘›

7	 Â 

!

(12)

After ğ‘€ union operations, the probability a given bit in X is ON is 1 âˆ’ ğ‘! .

Figure 2: The expected percentage of ON bits as a function of ğ‘€, the number of vectors in the
union set. In this case, ğ‘ = 2048 and ğ‘¤ = 40, i.e. ğ‘  = 2%.

The probability of a false positive, i.e. all ğ‘¤ bits in ğ‘¦ are ON, is therefore
ğ‘!" = 1 âˆ’ ğ‘!

!

ğ‘¤
= 1âˆ’
ğ‘›

! !

(13)

The technique used to arrive at (13) is similar to the derivation of the false positive rate
for Bloom filters (Bloom, 1970; Broder and Mitzenmacher, 2004)2.
For instance, consider SDR parameters ğ‘› = 1024 and ğ‘¤ = 2. Storing ğ‘€ = 20 vectors,
the chance of a false positive is about 1 in 680. However, if ğ‘¤ is increased to 20, the
chance drops dramatically to about 1 in 5.5 billion. This is a remarkable feature of the
union property. In fact, if increasing ğ‘€ to 40, the chance of an error is still better than
10!! .
To gain an intuitive sense of the union property, the expected number of ON bits in
the union vector is ğ‘›(1 âˆ’ ğ‘! ). This grows slower than linearly, as shown in Figure 2.
Consider for instance ğ‘€ = 80, where 20% of the bits are 0. When we consider an
additional vector with 40 ON bits, there is a reasonable chance it will have at least one
bit among this 20, and hence it wonâ€™t be a false positive. That is, only vectors with all of
their ğ‘¤ bits amongst the 80% ON are false positives. As we increase ğ‘› and ğ‘¤, the number
of patterns that can OR together reliably increases substantially. Calculations to illustrate
this property are carried out for a variety of parameters in Table 4 of Appendix A.

	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 
2	 Â The slight difference being in Bloom filters each bit is chosen independently, i.e. with
replacement. As such, a given vector could contain less than ğ‘¤ ON bits. In this analysis we
guarantee that there are exactly ğ‘¤ bits on in each vector. 	 Â 

	 Â 

8	 Â 

In HTMs the vector sizes are often substantially larger than 1024, and the union
property proves incredibly useful. We will discuss the impact of these numbers in more
detail in Section III.

H. Inexact Matches with Unions
The union property was derived above in the context of no noise, i.e. ğœƒ = ğ‘¤. We would
like to understand the effects of noise in the system, and therefore now relax the criteria
of a perfect match when considering unions. How reliably then can we match ğ‘¦ against
ğ‘‹ using a threshold ğœƒ < ğ‘¤?
As mentioned above, the expected number of ON bits in the union vector ğ‘‹ is
ğ‘¤! = ğ‘›(1 âˆ’ ğ‘! ). Assuming ğ‘› â‰¥ ğ‘¤! â‰¥ ğ‘¤, we can calculate the expected size of the
overlap set:

	 Â 
ğ¸ Î©! (ğ‘›, ğ‘¤, ğ‘) =

ğ‘¤!
ğ‘› âˆ’ ğ‘¤!
Ã—
	 Â 
ğ‘
ğ‘¤âˆ’ğ‘

(14)	 Â 

	 Â 
In order for a match, we can have an overlap of ğœƒ or greater bits (up to ğ‘¤). The
probability of a false match is therefore:

	 Â 
ğœ€â‰ˆ

!
!!! |Î©!

ğ‘›
ğ‘¤

	 Â 

ğ‘›, ğ‘¤, ğ‘ |

	 Â 

(15)	 Â 

Note (15) is an approximation of the error, as weâ€™re working with the expected
number of ON bits in ğ‘‹ 3. As in (4), for most of the cases we are interested in, the first
term in the numerator sum dominates, allowing us to simplify (15). Thus, (16) is an
excellent approximation for all practical purposes4.	 Â 

	 Â 
ğœ€â‰ˆ

|Î©! ğ‘›, ğ‘¤, ğ‘ |
	 Â 
ğ‘›
ğ‘¤

(16)	 Â 

As one would expect, the chance of error increases as the threshold is lowered. The
consequences of this tradeoff can be mitigated by increasing ğ‘›. Suppose ğ‘› = 1024 and
ğ‘¤ = 20. When storing ğ‘€ = 20 vectors, the chance of a false positive when using perfect
matches is about 1 in 5 billion. Using a threshold of 19 increases the false positive rate to
about 1 in 123 million. When ğœƒ = 18, the chance increases to 1 in 4 million. However if
you increase ğ‘› to 2048 with ğœƒ = 18, the false positive rate improves dramatically to 1 in
223 billion. This example illustrates the union propertyâ€™s robustness to noise, and is yet
another example of our larger theme: small linear changes in SDR numbers can cause
super-exponential improvements in the error rates.

	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 
3	 Â Subsequently, in the simplified case of no unions, i.e. ğ‘¤ = ğ‘¤, there are slight discrepancies with
!
(14), which is an exact calculation. Nevertheless, for numbers in the ranges we are concerned
with, the discrepancies are insignificant. An excellent approximation of the error for all practical
purposes is given by (16).	 Â 
4	 Â Specifically whenever ğ‘¤ > 12 and ğœƒ > !.	 Â 

	 Â 
	 Â 

!

9	 Â 

I. Computational Efficiency
Although SDR vectors are large, all the operations we've discussed run in time linear in
the number of ON bits. That is they are ğ‘‚(ğ‘¤) and independent of the size of the vector,
ğ‘›. This would not be the case, however, with more standard distance metrics which are
typically ğ‘‚(ğ‘›). For HTM systems this is important since in practice ğ‘¤ â‰ª ğ‘›.

III. SDRs and HTM
Hierarchical Temporal Memory is a detailed computational theory of the neocortex.
At the core of HTM are time-based learning algorithms that store and recall spatial and
temporal patterns. SDR is the primary data structure used in the cortex, and used
everywhere in HTM systems. The algorithms as described in the HTM whitepaper
(Hawkins and Ahmad, 2010) are critically reliant on binary SDRs. In HTM there isnâ€™t a
single unitary SDR, rather there are a number of distinct SDRs for specialized purposes.
These SDRs are involved in different parts of the HTM model neuron, and different
functions in the system of algorithms.
The following discussion assumes familiarity with HTM basics. It would behoove the
reader to understand the implementation and pseudocode in the HTM whitepaper
(Hawkins and Ahmad, 2010), as we discuss SDRs in the context of the neuron model i.e.
columns of cells, and their proximal and distal dendritic segments, and cortical
operations â€“ i.e. spatial pooling and predictions.
Note that HTM structures and operations such as hierarchy, feedback, sensorimotor
inference, and motor commands also use specific SDRs and rely on SDR properties.
Although a discussion of those topics as well as the learning algorithm is beyond the
scope of this paper, the same principles and intuitions apply. 	 Â 

A. Notation
The main HTM algorithms discussed are â€œSpatial Poolingâ€ (SP) and â€œTemporal
Memoryâ€ (TM), where TM refers to the sequence learning portion of the pseudocode in
Chapter 4 of HTM whitepaper (Hawkins and Ahmad, 2010) The following constants are
used:
N : size of input vector
C : number of columns
k : the number of columns active after spatial inhibition
L : number of cells per column
S : number of segments per cell

B. Spatial Pooling
Here we provide an overview of the SDR operations as they are implemented in the SP
process, with vector operations depicted in Figure 3. The SP process takes as input a
binary vector of length ğ‘. In practice this vector is usually sparse, but is not required to
be sparse. Each column in the SP represents proximal segments in a cell. A binary matrix
with dimensions ğ‘Ã—ğ¶ can be used to represent the set of connected synapses in the SP.
This matrix is not restricted to be sparse, but in practice is almost always sparse. The

	 Â 

10	 Â 

result of the vector-matrix multiplication is a vector of overlap counts, the third data
frame in Figure 3. An inhibition step chooses the column winners to form the output.
That is, the indices corresponding to the top ğ‘˜ overlaps correspond to the ON bits in the
output SDR. By construction this SDR is of size 1Ã—ğ¶ with ğ‘˜ components that are 1.

Figure 3: SDRs used in spatial pooling, where SP inhibition is run on the input vector to yield an
output binary vector representing the columns with the top overlap counts.

In the absence of learning, the SP process examines the overlap between a set of
randomly initialized columns and individual binary input vectors. The top ğ‘˜ columns,
determined by calculating the overlap, win and form the ON bits in the resulting SDR.
This SDR is then used as input into subsequent TM processes.
Consider a collection of random binary vectors ğ‘‹ each with size ğ‘› and ğ‘¤! ON bits.
Given a new random sparse vector ğ‘¦ of the same size, but possibly different ğ‘¤, how
many vectors in ğ‘‹ will have exactly ğ‘ bits of overlap with ğ‘¦? The probability of such a
match for a single vector in ğ‘‹ is:
ğ‘ ğ‘œğ‘£ğ‘’ğ‘Ÿğ‘™ğ‘ğ‘ ğ‘¥, ğ‘¦ = ğ‘ =

|Î©! ğ‘›, ğ‘¤! , ğ‘ |
ğ‘›
ğ‘¤!

(17)

It follows that the expected number of columns with b bits of overlap is ğ‘‹ âˆ™
ğ‘(ğ‘œğ‘£ğ‘’ğ‘Ÿğ‘™ğ‘ğ‘ ğ‘¥, ğ‘¦ = ğ‘), from which we can calculate the â€œoverlap curveâ€. This is the
overlap for each column after sorting, shown in Figure 4 shows this curve for a
representative set of parameters. This curve provides some intuition as to how a
randomly initialized SP process functions. One can see that a small amount of noise at
the input will somewhat change the output SDR, but that most of the winners will be
unchanged. The sharper the drop off after k, the more noise robustness in the system.
One of the effects of SP learning is to make the overlap curve sharper, thereby increasing
robustness to noise.

	 Â 

11	 Â 

Figure 4: The overlap curve for the top 800 columns of 2048.

C. Temporal Memory
The TM process is discussed in two phases, where the first phase calculates the active
states at time step ğ‘¡, and the second predicts which states will be active in the next time
step, ğ‘¡ + 1.
The first phase of TM follows the SP and determines the current active temporal state.
This phase examines the cells in each column predicted in the previous time step, and
the actual winning columns in the SP output SDR. Cells in winning columns that were
correctly predicted stay ON to represent the active temporal state of the system. Figure 5
shows a schematic of this operation. The first matrix is the 1Ã—ğ¶ SP output SDR, followed
by the LÃ—ğ¶ matrix predicted state matrix. Row-by-row element-wise multiplication
(represented by the symbol âŠ™ ) of these two matrices is used to determine the active
state, which is also ğ¿Ã—ğ¶. All three structures are sparse.

Figure 5: SDRs used in phase 1 of temporal memory, where the inputs are the spatial-pooled SDR
and the predicted state, and the output is the active state.

	 Â 

12	 Â 

The second phase of TM determines the predictions for the next time step by
matching individual cell segments with the current active state. Figure 6 shows this
operation schematically. Each cell contains a list of segments, where each segment is
represented by an SDR of size ğ¿Ã—ğ¶. For each segment the TM computes a match
between this representation and the current active state. If the match of any segment is
above the threshold, the predicted state for this cell will be ON.

Figure 6: SDRs in phase two of temporal memory, where the inputs are the active state and set of
segments, and the output is the predicted state.

Matching the active state is equivalent to the SDR classification function discussed in
the previous section. The ability of each cell to robustly â€œclassifyâ€ the active state will
impact the overall performance of the TM. In addition, at time ğ‘¡ there may be many
possible states predicted for time ğ‘¡ + 1, and all the cells corresponding to these states
will be in predicted state. From a computational standpoint, this step then determines a
union of possible temporal states for the next time step. The ability of the predicted state to
robustly represent this union is a fundamental property of SDRs and key to the
performance of the TM.
The TM learns sequences of SDRs, but what is the mechanism by which HTM uses
SDRs to represent high-order sequences? The TM can uniquely represent inputs as
unique steps in a sequence by using the cells within columns to represent inputs in
varying contexts. That is, in a learned temporal sequence, only one of the cells in an
HTM column becomes active. High-order sequences rely on creating a unique temporal
context. We can calculate the number of unique temporal contexts based on the number
of cells per column. For ğ‘¤ columns of ğ‘¥ cells each, there are ğ‘¥ ! ways to represent the
same input in different contexts. For conservative HTM parameters ğ‘¤ = 40 and ğ‘¥ = 8,
this evaluates to 1.33Ã—10!" . This is a massive capacity, even with a limited number of
cells per column; some HTM models implement 32 cells per column.
The full set of segments implement classification as discussed above in Section IIF.
The TM is able to make temporal predictions if and only if enough cells are able to
correctly classify the current active state. In TM each of a cellâ€™s dendrite segments
connects to other cells in the region, but the connections are limited to only a small
portion of the cells. A basic distal segment (without overloading or pooling) uses inexact

	 Â 

13	 Â 

matching, as discussed above. The equations (4)-(7) give us lower bounds on the number
of synapses per segment and help us understand the effect of lowering the activation
threshold. We can use the equations to set these parameters such that false classification
by a segment is highly unlikely. With more segments per dendrite, the TM can learn
more unique contexts. A higher activation threshold will call for more of the synapses
on these segments to be active in order for a cell to become predicted, placing a more
stringent requirement on segmentsâ€™ subsampling their input.
The TM makes a union of predictions. Using the union property we can figure out
how many predictions can be made at a time with minimal probability of false matches.
We can provide upper bounds on the number of simultaneous predictions before the
predicted state saturation becomes useless â€“ i.e. predict too many states.

IV. Conclusion
To fully understand any computational system, we need an understanding of the data
structure and their properties. SDRs form the basic data structure in HTM systems.
From their mathematics we can derive properties such as bounds and scaling laws,
performance characteristics, and ideal parameters. In this paper we have shown that
SDRs can be used to perform robust classification under noise and random deletions.
The union property shows how dynamic lists can be robustly represented within a
single fixed vector. We have outlined how various HTM operations map to SDRs.
Under the right set of parameters SDRs enable a massive capacity to learn temporal
sequences and form the basis for highly robust classification systems. Taken together
these properties provide a simple and elegant mathematical theory characterizing the
robustness of HTM systems.

Acknowledgement
The authors thank Alexander Lavin and Celeste Baranski for their help in editing this
paper, and Yuwei Cui, Scott Purdy, and Chetan Surpur for many helpful discussions.

References
Bloom, Burton H. "Space/time trade-offs in hash coding with allowable errors."
Communications of the ACM 13.7 (1970): 422-426.
Boureau, Y-lan, and Yann L. Cun. "Sparse feature learning for deep belief networks."
Advances in neural information processing systems. 2008.
Broder, Andrei, and Michael Mitzenmacher. "Network applications of bloom filters: A
survey." Internet mathematics 1.4 (2004): 485-509.
Donoho, David L. "Compressed sensing." Information Theory, IEEE Transactions on 52.4
(2006): 1289-1306.

	 Â 

14	 Â 

Graziano, M. S. A., Taylor, C. S. R., and Moore, T. (2002). Complex movements evoked
by microstimulation of precentral cortex. Neuron 34, 841â€“851. doi:10.1016/S08966273(02)00698-0.
Hawkins, Jeff, and Sandra Blakeslee. On Intelligence. Macmillan, 2007.
Hawkins, Jeff, Subutai Ahmad, and D. Dubinsky. "Hierarchical temporal memory
including HTM cortical learning algorithms." Technical report, Numenta, Inc, Palto Alto
http://numenta.org/cla-white-paper.html (2010).
HromÃ¡dka, T., DeWeese, M. R., and Zador, A. M. (2008). Sparse representation of
sounds in the unanesthetized auditory cortex. PLoS Biol. 6, 0124â€“0137.
doi:10.1371/journal.pbio.0060016.
Kanerva, Pentti. Sparse distributed memory. MIT press, 1988.
Kanerva, Pentti. "Hyperdimensional computing: An introduction to computing in
distributed representation with high-dimensional random vectors." Cognitive
Computation 1.2 (2009): 139-159.
Kanerva, Pentti. "Fully distributed representation." PAT 1.5 (1997): 10000.
Lee, Honglak, Chaitanya Ekanadham, and Andrew Y. Ng. "Sparse deep belief net model
for visual area V2." Advances in neural information processing systems. 2008.
Olshausen, Bruno A., and David J. Field. "Sparse coding with an overcomplete basis set:
A strategy employed by V1." Vision research 37.23 (1997): 3311-3325.
Olshausen, Bruno A., and David J. Field. "Sparse coding of sensory inputs." Current
opinion in neurobiology 14.4 (2004): 481-487.
Sanes, J. N., and Donoghue, J. P. (2000). Plasticity and primary motor cortex. Annual
Review of Neuroscience. 23, 393â€“415. doi:10.1146/annurev.neuro.23.1.393.
Tibshirani, Robert. "Regression shrinkage and selection via the lasso." Journal of the Royal
Statistical Society. Series B (Methodological) (1996): 267-288.
Vinje, William E., and Jack L. Gallant. "Sparse coding and decorrelation in primary
visual cortex during natural vision." Science 287.5456 (2000): 1273-1276.
Weliky, M., Fiser, J., Hunt, R. H., and Wagner, D. N. (2003). Coding of natural scenes in
primary visual cortex. Neuron 37, 703â€“718. doi:10.1016/S0896-6273(03)00022-9.

Appendix A â€“ Practical Considerations
The Numbers Game
The equations derived above provide significant insights to set most of the parameters
in HTM networks. They can tell us the number of columns, the desired sparsity, how to
determine the potential pool percent, how to set the threshold and other parameters on a

	 Â 

15	 Â 

segment, the limits of temporal memory predictions, how many patterns we can reliably
pool together, and so on.
Getting HTMs to work well in practice often boils down to a numbers game, and this
fact is often lost. A common approach in working with HTMs is to start with toy
problems and small values of ğ‘›, ğ‘¤, etc. This suffices for getting the code working and
initial debugging, but it is critical to move on to more practical values. As shown in the
paper, there are a number of exponentials and super-exponentials involved in SDR
properties. With a little bit of parameter tweaking, itâ€™s easy to find range of numbers that
work well across a large number of applications.
In the rest of this Appendix, we list tables with a number of different parameter
combinations and associated error rates. They can be used to understand the behavior
and set parameters appropriately.

SDR Actuarial Tables
Table 1 â€“ Exact matches: This table shows the number of possible patterns in various SDRs
and the associated probability of false exact matches. Even small values of ğ‘› and ğ‘¤ lead
to a large universe of patterns and low error rates.
n

w

Number of patterns

Prob. of false match

64 Â 

1 Â 

64 Â 

0.015625 Â 

64 Â 

3 Â 

41664 Â 

2.40015E-Â­â€05 Â 

64 Â 

5 Â 

7624512 Â 

1.31156E-Â­â€07 Â 

64 Â 

7 Â 

621216192 Â 

1.60975E-Â­â€09 Â 

64 Â 

9 Â 

27540584512 Â 

3.631E-Â­â€11 Â 

64 Â 

11 Â 

7.43596E+11 Â 

1.34482E-Â­â€12 Â 

512 Â 

1 Â 

512 Â 

0.001953125 Â 

512 Â 

3 Â 

22238720 Â 

4.49666E-Â­â€08 Â 

512 Â 

5 Â 

2.87516E+11 Â 

3.47807E-Â­â€12 Â 

512 Â 

7 Â 

1.75619E+15 Â 

5.69416E-Â­â€16 Â 

512 Â 

9 Â 

6.20812E+18 Â 

1.61079E-Â­â€19 Â 

1024 Â 

1 Â 

1024 Â 

0.000976563 Â 

1024 Â 

3 Â 

178433024 Â 

5.60434E-Â­â€09 Â 

1024 Â 

5 Â 

9.29119E+12 Â 

1.07629E-Â­â€13 Â 

1024 Â 

7 Â 

2.29479E+17 Â 

4.35769E-Â­â€18 Â 

1024 Â 

9 Â 

3.29326E+21 Â 

3.03651E-Â­â€22 Â 

Table 2 â€“ Inexact matches: This table shows the probability of false inexact matches when
comparing two SDRs and various values of the threshold t. The values show it is
difficult to get a low false match probability with n=64. However, increasing n to 1024
dramatically decreases the chances even with a much lower threshold. It is obvious
larger values of n will continue to improve the chances, and are thus excluded from the
table.

	 Â 

16	 Â 

n

w

t

Prob. of false match

64 Â 

4 Â 

4 Â 

1.57387E-Â­â€06 Â 

64 Â 

4 Â 

3 Â 

0.000379303 Â 

64 Â 

4 Â 

2 Â 

0.017093815 Â 

64 Â 

4 Â 

1 Â 

0.232525308 Â 

64 Â 

8 Â 

8 Â 

2.25929E-Â­â€10 Â 

64 Â 

8 Â 

7 Â 

1.01442E-Â­â€07 Â 

64 Â 

8 Â 

6 Â 

9.84351E-Â­â€06 Â 

64 Â 

8 Â 

5 Â 

0.000360558 Â 

64 Â 

8 Â 

4 Â 

0.006169265 Â 

64 Â 

32 Â 

32 Â 

5.45666E-Â­â€19 Â 

64 Â 

32 Â 

24 Â 

6.70223E-Â­â€05 Â 

64 Â 

32 Â 

16 Â 

0.59857385 Â 

1024 Â 

20 Â 

20 Â 

1.82484E-Â­â€42 Â 

1024 Â 

20 Â 

17 Â 

3.50023E-Â­â€31 Â 

1024 Â 

20 Â 

14 Â 

9.93621E-Â­â€23 Â 

1024 Â 

20 Â 

10 Â 

9.32924E-Â­â€14 Â 

Table 3 â€“ Classifying vectors: This table shows the probability of false matches when
classifying a list of vectors under different parameter combinations. Itâ€™s clear increasing
the value of n and w has a very large impact on the number of vectors that can be
classified accurately and robustly.
n

w

M

ğœ½

Prob. of false positive

64 Â 

3 Â 

10 Â 

3 Â 

0.000240015 Â 

64 Â 

3 Â 

10 Â 

2 Â 

0.044162826 Â 

64 Â 

12 Â 

10 Â 

12 Â 

3.04487E-Â­â€12 Â 

64 Â 

12 Â 

10 Â 

10 Â 

2.68378E-Â­â€07 Â 

64 Â 

12 Â 

10 Â 

8 Â 

0.000423112 Â 

1024 Â 

21 Â 

10 Â 

21 Â 

3.81689E-Â­â€43 Â 

1024 Â 

21 Â 

10 Â 

14 Â 

8.8349E-Â­â€21 Â 

1024 Â 

21 Â 

1.00E+09 Â 

21 Â 

3.81689E-Â­â€35 Â 

1024 Â 

21 Â 

1.00E+09 Â 

17 Â 

9.5841E-Â­â€21 Â 

1024 Â 

21 Â 

1.00E+09 Â 

14 Â 

8.8349E-Â­â€13 Â 

Table 4 â€“ Union with inexact matches: This table shows the probability of false matches
when you have a union of patterns and when the threshold is allowed to vary. We
highlight some specific parameter settings corresponding to some common Temporal
Memory regimes. n=8192 corresponds to 1024 columns with 8 cells per column. n=65536
corresponds to 2048 columns with 32 cells per column.

	 Â 

17	 Â 

n

w

t

M

Prob. of false match

64 Â 

4 Â 

4 Â 

10 Â 

0.043131941 Â 

64 Â 

4 Â 

3 Â 

10 Â 

0.42652697 Â 

64 Â 

8 Â 

8 Â 

10 Â 

0.07104513 Â 

64 Â 

8 Â 

7 Â 

10 Â 

0.866750589 Â 

1024 Â 

20 Â 

20 Â 

20 Â 

1.2532E-Â­â€10 Â 

1024 Â 

20 Â 

18 Â 

20 Â 

2.49E-Â­â€07 Â 

1024 Â 

20 Â 

16 Â 

20 Â 

6.59353E-Â­â€05 Â 

1024 Â 

20 Â 

20 Â 

30 Â 

7.76674E-Â­â€08 Â 

1024 Â 

20 Â 

18 Â 

30 Â 

8.09221E-Â­â€05 Â 

1024 Â 

20 Â 

16 Â 

30 Â 

0.011323733 Â 

1024*8=8192 Â 

20 Â 

20 Â 

60 Â 

4.33389E-Â­â€18 Â 

1024*8=8192 Â 

20 Â 

18 Â 

60 Â 

4.61314E-Â­â€14 Â 

1024*8=8192 Â 

20 Â 

16 Â 

60 Â 

6.58692E-Â­â€11 Â 

1024*8=8192 Â 

20 Â 

14 Â 

60 Â 

2.95373E-Â­â€08 Â 

1024*8=8192 Â 

40 Â 

40 Â 

80 Â 

2.15567E-Â­â€20 Â 

1024*8=8192 Â 

40 Â 

36 Â 

80 Â 

1.92105E-Â­â€13 Â 

1024*8=8192 Â 

40 Â 

32 Â 

80 Â 

1.57968E-Â­â€08 Â 

2048*32=65536 Â 

40 Â 

40 Â 

80 Â 

1.06052E-Â­â€53 Â 

2048*32=65536 Â 

40 Â 

36 Â 

80 Â 

1.9751E-Â­â€43 Â 

2048*32=65536 Â 

40 Â 

32 Â 

80 Â 

3.37299E-Â­â€35 Â 

2048*32=65536 Â 

40 Â 

28 Â 

80 Â 

4.95502E-Â­â€28 Â 

2048*32=65536 Â 

40 Â 

40 Â 

1000 Â 

2.4446E-Â­â€14 Â 

2048*32=65536 Â 

40 Â 

36 Â 

1000 Â 

5.40046E-Â­â€08 Â 

2048*32=65536 Â 

40 Â 

32 Â 

1000 Â 

0.001114562 Â 

2048*32=65536 Â 

40 Â 

28 Â 

1000 Â 

1 Â 

2048*32=65536 Â 

40 Â 

40 Â 

600 Â 

2.86956E-Â­â€21 Â 

2048*32=65536 Â 

40 Â 

36 Â 

600 Â 

3.07893E-Â­â€14 Â 

2048*32=65536 Â 

40 Â 

32 Â 

600 Â 

3.06773E-Â­â€09 Â 

2048*32=65536 Â 

40 Â 

28 Â 

600 Â 

2.67369E-Â­â€05 Â 

With n=64 it is difficult to do any significant pooling; the error rate is simply too high.
With the more typical settings of 1024 or 2048 columns, a very large amount of pooling
is possible with very low error rates and reasonable noise robustness.

	 Â 

18	 Â 

