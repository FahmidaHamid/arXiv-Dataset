The Complexity of Finding Multiple Solutions to
Betweenness and Quartet Compatibility
arXiv:1101.2170v2 [q-bio.PE] 28 Mar 2011

Maria Luisa Bonet∗

Simone Linz∗†

Katherine St. John‡§

March 29, 2011

Abstract
We show that two important problems that have applications in computational
biology are ASP-complete, which implies that, given a solution to a problem, it is
NP-complete to decide if another solution exists. We show first that a variation of Betweenness, which is the underlying problem of questions related to radiation hybrid
mapping, is ASP-complete. Subsequently, we use that result to show that Quartet
Compatibility, a fundamental problem in phylogenetics that asks whether a set of
quartets can be represented by a parent tree, is also ASP-complete. The latter result
shows that Steel’s Quartet Challenge, which asks whether a solution to Quartet
Compatibility is unique, is coNP-complete.

1

Introduction

Many biological problems focus on synthesizing data to yield new information. We focus on
the complexity of two such problems. The first is motivated by radiation hybrid mapping (RH
mapping) [10] which was developed to construct long range maps of mammalian chromosomes
(e.g. [1, 8, 17]). Roughly, RH mapping uses x-rays to break the DNA into fragments and
gives the relative order of DNA markers on the fragments [10]. The underlying computational
problem is to assemble these fragments into a single strand (i.e., a “linear order”). As Chor
and Sudan [7] show, the assembly of these fragments can be modeled by the well-known
decision problem Betweenness. Loosely speaking, this problem asks if there exists a total
ordering over a set of elements that satisfies a set of constraints, each specifying one element
to lie between two other elements (see Section 2 for a more detailed definition). Since this
∗

Lenguajes y Sistemas Informaticos (LSI), Universitat Politècnica de Catalunya (UPC), 08034 Barcelona,
Spain, bonet@lsi.upc.edu.
†
Corresponding author: simone linz@yahoo.de.
‡
Department of Math & Computer Science, Lehman College– City University of New York (CUNY),
Bronx, NY 12581, United States, stjohn@lehman.cuny.edu.
§
Department of Computer Science, CUNY Graduate Center, New York, NY 10016.

1

classical problem is NP-complete [22], Chor and Sudan [7] developed a polynomial-time
approximation. Their algorithm, by using a geometric approach, either returns that no
betweenness ordering exists or returns such an ordering that satisfies at least one half of
the given constraints. However, in the context of RH mappings, one usually knows the socalled 3’ and 5’ end of the DNA under consideration. Therefore, we consider a variation of
Betweenness—called cBetweenness—whose instances do not only contain a collection
of constraints, but also an explicit specification of the first and last DNA marker, and that
asks whether or not there exists a total ordering whose first and last element coincide with
the first and last DNA marker, respectively. In this paper, we are particularly interested
in the following question related to cBetweenness: given a solution to an instance of
cBetweenness, is there another solution? A positive answer to this question may imply
that the sampling of relatively ordered DNA markers is not large enough to determine the
correct ordering of the entire set of DNA markers.
Our second question focuses on finding the optimal phylogenetic tree for a set of taxa
(e.g. species). Under the most popular optimization criteria (maximum parsimony and
maximum likelihood), it is NP-hard to find the optimal tree [13, 24]. Despite the NPhardness, several approaches to this problem exists, one of which finds a phylogenetic tree
by splitting the problem into subproblems, solves the subproblems and then recombines the
solutions to form a complete phylogenetic tree that represents all taxa under consideration
[4, 6, 19]. To this end, quartets which are phylogenetic trees on 4 taxa are often used. Given
4 taxa, there are three possible ways to arrange them:
t
b @

td
@
@r

r
@
@

a t
ab|cd

c t

td

@
@@r
@t c

r
@
@

a t
ac|bd

d t@

tc
@
@r

@t b

r
@
@

a t

@t b

ad|bc

Since the number of possible topologies grows exponentially with the number of taxa, it is
easier to decide the arrangement or topology of each subset of 4 taxa than the topology
for a large set of taxa. This leads to the question: how hard is it to build a tree from
quartets? If Q denotes the set of all quartets of a phylogenetic tree T , then T is uniquely
determined by Q and can be reconstructed in polynomial time [12]. However, in most cases
T is not given, and Q is often incomplete (i.e. there exists a set of 4 taxa for which no
quartet is given) or elements in Q contradict each other. In such a case, it is NP-complete
to decide whether there exists a phylogenetic tree on n taxa that displays Q [27]; that
is, a phylogenetic tree that explains all the ancestral relationships given by the quartets,
where n is the number of taxa over all elements in Q. Because of the NP-completeness
of this latter problem—called Quartet Compatibility—algorithmic approaches are rare.
Nevertheless, several attractive graph-theoretic characterizations of the problem exist [16,
25]. While [25] approaches the problem by using a chordal-graph characterization on an
underlying intersection graph, [16] establishes a so-called quartet graph and edge colorings
2

via this graph to decide whether or not there exists a phylogenetic tree that displays a given
set of quartets. As a follow-up on this last question, Steel asks whether or not the following
problem, called the Quartet Challenge, is NP-hard [28]: given a set Q of quartets
over n taxa and a phylogenetic tree T on n taxa that displays Q, is T the unique such
tree that displays Q? Although the above-mentioned characterizations [16, 25] comprises
several results on when a set of quartets is displayed by a unique phylogenetic tree, the
computational complexity of the Quartet Challenge remains open. We note that if a
set Q of quartets that does not contain any redundant information is displayed by a unique
phylogenetic tree on n taxa, then the minimum size of Q is n − 3 [26, Corollary 6.3.10] while
the current largest maximum size is 2n − 8 [11].
To investigate the computational complexity of problems for when a solution is given and
one is interested in finding another solution, Yato and Seta [30] developed the framework
of Another Solution Problems (ASP). Briefly, if a problem is ASP-complete, then
given a solution to a problem, it is NP-complete to decide if a distinct solution exists. Many
canonical problems are ASP-complete, such as several variations of satisfiability, as well as
games like Sudoku [30].
In this paper, we show that, given a solution to an instance of cBetweenness or
Quartet Compatibility, finding a second solution is ASP-complete. To show that cBetweenness is ASP-complete, we use a reduction from a variant of satisfiability, namely,
Not-All-Equal-3SAT with Constants (see Section 2 for a detailed definition). Using
this result, we establish a second reduction that subsequently shows that Quartet Compatibility is also ASP-complete. As we will soon see, the ASP-completeness of Quartet
Compatibility implies coNP-completeness of the Quartet Challenge.
We note that while this paper was in preparation, a preprint was released [18] that
addresses the complexity of the Quartet Challenge using different techniques than employed here.
This paper is organized as follows: Section 2 details background information from complexity theory and phylogenetics. Section 3 gives the two reduction results, and Section 4
contains some concluding remarks.

2

Preliminaries

This section gives an outline of the ASP-completeness concept and formally states the decision problems that are needed for this paper. Preliminaries in the context of phylogenetics
are given in the second part of this section.

2.1

Computational complexity

Notation and terminology introduced in this section follows [14] and [30], with the former
being an excellent reference for general complexity results.

3

ASP-completeness. The notion of ASP-completeness was first published by Yato and
Seta [30]. Their paper provides a theoretical framework to analyze the computational complexity of problems whose input contains, among others, a solution to a given problem
instance, and the objective is to find a distinct solution to that instance or to return that
no such solution exists. To this end, the authors use function problems whose answers can
be more complex in contrast to decision problems that are always answered with either ‘yes’
or ‘no’. Formally, the complexity class FNP contains each function problem Π that satisfies
the following two conditions:
(i) There exists a polynomial p such that the size of each solution to a given instance ψ
of Π is bounded by p(ψ).
(ii) Given an instance ψ of Π and a solution s, it can be decided in polynomial time if s is
a solution to ψ.
Note that the complexity class FNP is a generalization of the class NP and that each function
problem in FNP has an analogous decision problem.
Now, let Π and Π0 be two function problems. We say that a polynomial-time reduction
f from Π to Π0 is an ASP-reduction if for any instance ψ of Π there is a bijection from the
solutions of ψ to the solutions of f (ψ), where f (ψ) is an instance of Π0 that has been obtained under f . Note that, while each ASP-reduction is a so-called ‘parsimonious reduction’,
the converse is not necessarily true. Parsimonious reductions have been introduced in the
context of enumeration problems (for details, see [23]). Furthermore, a function problem Π0
is ASP-complete if and only if Π0 ∈ FNP and there is an ASP-reduction from Π to Π0 for
any function problem Π ∈ FNP.
Remark. Throughout this paper, we prove that several problems are ASP-complete. Although these problems are stated as decision problems in the remainder of this section, it
should be clear from the context which associated function problems we consider. More
precisely, for a decision problem Πd , we consider the function problem Π whose instance
ψ consists of the same parameters as an instance of Πd and, additionally, of a solution to
ψ, and whose question is to find a distinct solution that fulfills all conditions given in the
question of Πd . Hence, if Π is ASP-complete, then this implies that, unless P=NP, it is
computationally hard to find a second solution to an instance of Π.
Satisfiability (SAT) problems. The satisfiability problem is a well-known problem
in the study of computational complexity. In fact, it was the first problem shown to be
NP-complete [14, 9]. Before we can formally state the problem, we need some definitions.
Let V = {x1 , x2 , . . . , xn } be a set of variables. A literal is either a variable xi or its negation
x̄i , and a clause is a disjunction of literals. Now let C be a conjunction of clauses (for an
example, consider the four clauses given in Figure 1). A truth assignment for C assigns each
literal to either true or false such that, for each i ∈ {1, 2, . . . , n}, xi = true if and only if
x̄i = f alse. We say that a literal is satisfied (resp. falsified) if its truth value is true (resp.
false).
4

C1
C2
C3
C4

: x1 ∨ x2 ∨ x3
: x1 ∨ x̄3 ∨ x4
: x̄1 ∨ x3 ∨ x̄4
: x2 ∨ x̄3 ∨ x4

σ0 : {x1 , x2 , x3 , x4 } → true
σ1 : {x1 , x2 } → true; σ1 : {x3 , x4 } → f alse
σ2 : {x1 , x3 , x4 } → true; σ2 : {x2 } → f alse

Figure 1: Left: An example of 4 clauses on the variables x1 , . . . , x4 . Right: Truth assignments
to the non-negated literals. As an instance of 3SAT, there are several possible satisfying truth
assignments including σ0 , σ1 , and σ2 . When viewed as an instance of NAE-3SAT, σ0 is not
satisfying since it assigns all literals of the first clause C1 to true, violating the ‘not all equal’
condition.

Problem: Satisfiability
Instance: A set of variables V and a conjunction C of clauses over V .
Question: Does there exist a truth assignment for C such that each clause
contains at least one literal assigned to true?
3SAT is a special case of the general SAT problem in which each clause of a given instance
contains exactly three literals. Referring back to Figure 1, all three truth assignments σ0 , σ1 ,
and σ2 satisfy the four clauses for when regarded as an instance of 3SAT. The next theorem
is due to [30, Theorem 3.5].
Theorem 2.1. 3SAT is ASP-complete.
We will next show the ASP-completeness of another version of SAT that is similar to the
following decision problem.
Problem: Not-All Equal-3SAT (NAE-3SAT)
Instance: A set of variables V and a conjunction C of 3-literal clauses over V .
Question: Is there a truth assignment such that for each clause there is a literal
satisfied and a literal falsified by the assignment?
As an example, see Figure 1, and note that σ0 does not satisfy the four clauses when regarded
as an instance of NAE-3SAT. It is an immediate consequence of the definition of NAE-3SAT
that, given a solution S to an instance, a second solution to this instance can be calculated
in polynomial time by taking the complement of S; that is assigning each literal to true
(resp. false) if it is assigned to false (resp. true) in S (see [21]).
The next decision problem can be obtained from NAE-3SAT by allowing for instances
that contain the constants T or F .
Problem: Not-All Equal-3SAT with constants (cNAE-3SAT)
Instance: A set of variables V , constants T and F , and a conjunction C of
3-literal clauses over V ∪ {T, F }.
Question: Is there a truth assignment such that the constants T and F are
assigned true and false, respectively, and for each clause, there is a literal or
constant satisfied and a literal or constant falsified by the assignment?
5

In the case of cNAE-3SAT, we cannot always obtain a second solution from a first one
by taking its complement. For instance, if an instance of cNAE-3SAT contains the clause
ak ∨bk ∨T , then the assignment ak = bk = f alse is valid, while the complementary assignment
ak = bk = true is not. In fact, we next show that cNAE-3SAT is ASP-complete.
Theorem 2.2. cNAE-3SAT is ASP-complete.
Proof. Regarding cNAE-3SAT as a function problem (see the remark earlier in this section),
it is easily seen that deciding if a truth assignment to an instance of cNAE-3SAT satisfies
this instance takes polynomial time. Hence, cNAE-3SAT is in FNP. Now, let ψ be an
instance of the APS-complete problem 3SAT over the variables V = {x1 , . . . , xn }. To show
that cNAE-3SAT is ASP-complete we reduce ψ to an instance ψ 0 of cNAE-3SAT over an
expanded set of variables V 0 = V ∪ {xx+1 , . . . , xn+m }, where m is the number of clauses in
ψ. Let xn+k be a new variable chosen for the clause (ak ∨ bk ∨ ck ) of ψ. We obtain ψ 0 from
ψ by replacing each clause (ak ∨ bk ∨ ck ) with the following 4 clauses:
(ak ∨ bk ∨ xn+k ) ∧ (x̄n+k ∨ ck ∨ F ) ∧ (ak ∨ xn+k ∨ T ) ∧ (bk ∨ xn+k ∨ T ).
Clearly, this reduction can be done in polynomial time. The size of ψ 0 is polynomial in
the size of ψ, and a straightforward check shows that ψ is satisfiable if and only if ψ 0 is
satisfiable. Furthermore, for each clause, xn+k is uniquely determined by the truth values of
ak and bk , since the reduction makes x̄n+k equivalent to ak ∨bk . Hence, each truth assignment
that satisfies ψ can be mapped to a unique valid truth assignment of ψ 0 . Consequently, the
converse; i.e. each truth assignment of ψ 0 is mapped to a unique truth assignment of ψ,
also holds. It now follows that the described reduction from 3SAT to cNAE-3SAT is an
ASP-reduction, thereby completing the proof of this theorem.
The Betweenness problem. The decision problem Betweenness, that we introduce
next, asks whether or not a given finite set can be totally ordered such that a collection of
constraints which are given in form of triples is satisfied.
Problem: Betweenness
Instance: A finite set A and a collection C of ordered triples (a, b, c) of distinct
elements from A such that each element of A occurs in at least one triple from
C.
Question: Does there exist a betweenness ordering f of A for C; that is a oneto-one function f : A → {1, 2, . . . , |A|} such that for each triple (a, b, c) in C
either f (a) < f (b) < f (c) or f (c) < f (b) < f (c)?
Loosely speaking, for each triple (a, b, c), the element b lies between a and c in a betweenness
ordering of A for C. Betweenness has been shown to be NP-complete [22]. Similar to
NAE-3SAT, notice that if there is a solutions, say a1 < a2 < . . . < as , to an instance of
Betweenness, then there is always a second solution as < . . . < a2 < a1 to that instance
that can clearly be calculated in polynomial time. Therefore, Betweenness is not ASPcomplete.

6

We next introduce a natural variant of Betweenness—called cBetweenness—that
is ASP-complete (see Section 3.1). An instance of cBetweenness differs from an instance
of Betweenness in a way that the former contains two constants, say m and M , and each
betweenness ordering has m as its first and M as its last element. We say that m is the
minimum and M the maximum of each betweenness ordering.
Problem: cBetweenness
Instance: A finite set A and a collection C of ordered triples (a, b, c) of distinct
elements from A ∪ {M, m} with m, M ∈
/ A such that each element of A ∪ {M, m}
occurs in at least one triple from C.
Question: Does there exist a betweenness ordering f of A ∪ {M, m} for C such
that f is a one-to-one function f : A ∪ {m, M } → {0, 1, 2, . . . , |A| + 1} such that
for each triple (a, b, c) in C either f (a) < f (b) < f (c) or f (c) < f (b) < f (c), and
f (m) = 0 and f (M ) = |A| + 1?
Although an instance ψ of cBetweenness can have several betweenness orderings, note
that if a0 < a1 < a2 < . . . < a|A|+1 is a betweenness ordering for ψ with a0 = m and
a|A|+1 = M , then a|A|+1 < . . . < a2 < a1 < a0 is not such an ordering. This is because m
must be the minimal element, and M the maximal.

2.2

Phylogenetics

This section provides preliminaries in the context of phylogenetics. For a more thorough
overview, we refer the interested reader to Semple and Steel [26].
Phylogenetic trees and subtrees. An unrooted phylogenetic X-tree T is a connected
acyclic graph whose leaves are bijectively labeled with elements of X and have degree 1.
Furthermore, T is binary if each non-leaf vertex has degree 3. The set X is the label set of
T and denoted by L(T ).
Now let T be an unrooted phylogenetic X-tree, and let X 0 be a subset of X. The
minimal subtree of T that connects all elements in X 0 is denoted by T (X 0 ). Furthermore,
the restriction of T to X 0 , denoted by T |X 0 , is the phylogenetic tree obtained from T (X 0 )
by contracting degree-2 vertices.
Throughout this paper, we will use the terms ‘unrooted phylogenetic tree’ and ‘phylogenetic tree’ interchangeably.
Quartets. A quartet is an unrooted binary phylogenetic tree with exactly four leaves.
For example, let q be a quartet whose label set is {a, b, c, d}. We write ab|cd (or equivalently, cd|ab) if the path from a to b does not intersect the path from c to d. Similarly
to the label set of a phylogenetic tree, L(q) denotes the label set of q, which is {a, b, c, d}.
Now, let Q = {q1 , q2 , . . . , qn } be a set of quartets. We write L(Q) to denote the union
L(q1 ) ∪ L(q2 ) ∪ . . . ∪ L(qn ).

7

Compatibility. Let T be a phylogenetic tree whose leaf set is a superset of L(q). Then
T displays q if q is isomorphic to T |L(q). Furthermore, T displays a set Q of quartets if T
displays each element of Q, in which case Q is said to be compatible. Lastly, <Q> denotes the
set of all unrooted binary phylogenetic trees that display Q and whose label set is precisely
L(Q).
The concept of compatibility leads to the following decision problem, which has been
shown to be NP-complete [27].
Problem: Quartet Compatibility
Instance: A set Q of quartets.
Question: Is Q compatible?
The next problem has originally been posed by Steel [28] and is a natural extension of
Quartet Compatibility.
Problem: Quartet Challenge
Instance: A binary phylogenetic X-tree T and a set Q of quartets on X such
that T displays Q.
Question: Is T the unique phylogenetic X-tree that displays Q?
Remark. Given a binary phylogenetic X-tree T and a set Q of quartets on X such that
T displays Q, deciding whether another solution exists is the complement question of the
Quartet Challenge. That is, a no answer to an instance of the first question translates
to a yes answer to the same instance of the Quartet Challenge and vice versa.
We end this section by highlighting the relationship between the two problems Quartet
Challenge and Quartet Compatibility. Let Q be an instance of Quartet Compatibility. If Q is compatible, then there exists an unrooted phylogenetic tree T with label
set L(Q) that displays Q. This naturally leads to the question whether T is the unique
such tree on L(Q), which is exactly the question of the Quartet Challenge. To make
progress towards resolving the complexity of this challenge, we will first show that Quartet Compatibility is ASP-complete. Thus, by [30, Theorem 3.4], the decision problem
that corresponds to Quartet Compatibility, i.e. asking whether another solution exists,
is NP-complete. Now, recalling the last remark, this in turn implies that the Quartet
Challenge is coNP-complete. Lastly, note that if T is the unique tree with label set L(Q)
that displays Q, then T is binary.

3
3.1

ASP-Completeness Results
ASP-Reduction for cBetweenness

In this section, we focus on establishing an ASP-reduction from cNAE-3SAT to cBetweenness. This reduction gives that cBetweenness is ASP-complete (see Theorem 3.1).
We note that, by a similar argument, we can also reduce NAE-3SAT to Betweenness.
8

Let ψ be an instance of cNAE-3SAT consisting of a conjunction of 3-literal clauses
{ak ∨ bk ∨ ck : 1 ≤ k ≤ l}, on the set of variables {x1 , . . . , xn } and a subset of the constants
{T, F }. Let {−x1 , −x2 , . . . , −xn , x1 , x2 , . . . , xn } be the set of corresponding literals of ψ,
where −xi (instead of x̄i ) denotes the negation of xi . We next build an instance ψ 0 of
cBetweenness.
In the following, we think of an ordering as setting symbols on a line segment where
the symbol X is the center; i.e. X represents ‘0’. Furthermore, we refer to the region
left of X as the negative side and to the region right of X as the positive side of the line
segment. For every variable xi with i ∈ {1, 2, . . . , n}, we preserve the two symbols xi and
−xi and introduce two new symbols Mi and −Mi which are auxiliary symbols that mark the
midpoints between the xi and −xi symbols (see Figure 2). Moreover, if T or F is contained
in any clause of ψ, then we also introduce the symbol M and m, respectively, such that M
represents the largest and m the smallest value on the line segment (for details, see below).
Intuitively, if the literal xi is assigned to true, then the symbol xi is assigned to the positive
side and the symbol −xi to the negative side. Otherwise, if the literal xi is assigned to false,
then the symbol xi is assigned to the negative side and the symbol −xi to the positive side.
The following triples fix X as ‘0’. For every i ≤ n, they put xi and −xi on either side of
X. They also put Mi and −Mi on either side of X.
(−xi , X, xi )
(−Mi , X, Mi )

for all i such that 1 ≤ i ≤ n
for all i such that 1 ≤ i ≤ n

(1)

The next set of triples put an order between the xi and Mi symbols. They establish that
|xi | < |xi+1 | for every i, 1 ≤ i < n, where we interpret | · | to be the distance to X (i.e. ‘0’)
under the induced ordering. Also, they fix Mi and −Mi as middle points between xi (or
−xi ), and xi−1 (or −xi−1 ) (see Figure 2).
(−Mi , xi−1 , Mi ) (−Mi , −xi−1 , Mi )
(−xi , Mi , xi )
(−xi , −Mi , xi )

for all i such that 2 ≤ i ≤ n
for all i such that 1 ≤ i ≤ n

(2)

We will require that either both xi and Mi are on the positive side, or on the negative side.
(xi , X, −Mi ) (−xi , X, Mi )

for all i such that 1 ≤ i ≤ n

(3)

Original Encoding: Given a clause (ak ∨ bk ∨ ck ) of ψ, we assume for the remainder of
Section 3.1 that ak ∈ {−xi , xi }, bk ∈ {−xi0 , xi0 }, and ck ∈ {−xi00 , xi00 } such that i < i0 < i00 .
Since there are at most two constants per clause, we also assume that ak is never a constant
and that, if bk is a constant, then ck is a constant. Lastly, we assume that the whole set of
clauses of ψ is ordered lexicographically.
To guarantee the ‘not-all-equal’ condition, we use the original encoding of Opatrny [22].
For each clause ak ∨ bk ∨ ck with k ∈ {1, 2, . . . , l}, we add a new symbol, Zk , where l is
the number of clauses in ψ. We add the following triples that correspond to the original
encoding of Opatrny [22]:
(ak , Zk , bk ) (ck , X, Zk )

for all k such that 1 ≤ k ≤ l.
9

(4)

x4
m

x4 M4

x1

x3
x3 M 3 -x2 -M2 -x1 -M1 X

x2

M1 x1 M2 x 2 -M3 -x3 -M4 -x4

M

Z1
Z2

Z3

Z4

Figure 2: A mapping of the first set of clauses under the truth assignment σ1 from Figure 1.
The top blue variables are the initial variables from the instance of cNAE-3SAT. For a given
truth assignment, the ordering of the xi and Mi symbols is fixed by the triples in Equation 14. However, without additional triples (and auxiliary symbols), the Zi symbols have overlapping
ranges (as indicated by the lines with arrows) and, as such, several possible orderings for a single
truth assignment.

If a clause contains a constant F or T , it gets substituted by m or M , respectively, in the
triple. For instance, a clause ak ∨ bk ∨ T generates the two triples (ak , Zk , bk ), (T, X, Zk ).
These triples force Zk to be on the negative side.
The triples of Equation 4 say that at least one of the literals of the k th clause is assigned to
true and one to false (see Figure 2). When viewed in terms of the possible truth assignment
to the variables in the original clause, the truth assignment ak = bk = ck = true is eliminated
since for all three initial literals to be assigned true, both ck and Zk would be assigned to
the positive side of X violating the second triple of Equation 4. By a similar argument,
the truth assignment ak = bk = ck = f alse is eliminated. This leaves six other possible
satisfying truth assignments.
The triples of Equation 1-4 are not sufficient to prove ASP-completeness of cBetweenness since different orderings of cBetweenness can be reduced to the same satisfying truth
assignment of the cNAE-3SAT instance (see Figure 2). This happens since the symbols in
{Z1 , Z2 , . . . , Zl } are not fixed with respect to the xi and −xi symbols or to one another. In
what follows, we will show how to fix the ordering of these symbols.
Fixing Auxiliary Symbols in the Ordering of the Initial Symbols: We next introduce new symbols −Z1 , . . . , −Zl , where l is the number of clauses in ψ. From now on, we
will establish a set of triples for every clause. We assume that the triples up to the (k − 1)th
clause have been defined, and now we will give the set of triples of the k th clause. The
intuition is that we want −Zk to be opposite to Zk with respect to X. We add:
(−ak , −Zk , −bk ) (−ck , X, −Zk )

(5)

To fix the position of Zk and −Zk for every 1 ≤ k ≤ l relative to the xi and Mi symbols,
we need more triples. Recall that ak ∈ {−xi , xi }. We add the following triples saying that

10

x1
M3

-x 2

-M 2

-x1

-M1

X

M1

x2

x1

M2

x2

-M3

Z1
Z2

Z3

Z4

Figure 3: Equations 6-7 limit the ranges of the Zk symbols but do not completely fix the ordering.
Continuing the example from Figure 1, we show the possible ordering for the σ1 truth assignment.
Note that the order of Z1 and Z2 is not fixed and additional triples (and variables) are needed.

|Zk | < |Mi+1 |.
(−Mi+1 , Zk , Mi+1 ) (−Mi+1 , −Zk , Mi+1 )

(6)

The following triples say that |Mi | < |Zk |.
(−Zk , Mi , Zk ) (−Zk , −Mi , Zk )

(7)

These triples eliminate the interval [−Mi , Mi ] for the positions of Zk and −Zk , respectively. Since the Mi symbols occur as midpoints between the xi symbols, we have restricted
each Zk to be ‘near’ ak or −ak ; i.e. Zk is ‘near’ −xi or xi on the line segment. As a consequence of Equations 6, we have |Mi | < |Zk | < |xi | or |xi | < |Zk | < |Mi+1 |. At this point, we
have the symbols Zk and −Zk in a tight interval between consecutive positions, except for
the truth assignments ak = ck = f alse and bk = true, and ak = ck = true and bk = f alse. In
these cases, both |Mi | < |Zk | < |xi | and |xi | < |Zk | < |Mi+1 |, are still possible. See Figure 3
for an example. We therefore add:
(Zk , −ak , ck ) (−Zk , ak , −ck )

(8)

which fixes the Zk such that |xi | < |Zk | < |Mi+1 |.
Fixing the Order of Auxiliary Symbols Among Themselves: With the Zk and −Zk
being fixed around xi and −xi , respectively, and recalling that ai ∈ {−xi , xi }, we need to
address the case where the first literal of several clauses is either xi or −xi . Note that these
corresponds to consecutive clauses of ψ since ψ is ordered lexicographically. In this case, we
will use extra auxiliary symbols to nest the Zk symbols around xi and −xi . The intuition for
these clauses is to partition the consecutive intervals into distinct regions for the different
Zk and −Zk symbols (see Figure 4).
Let the k th clause be ak ∨ bk ∨ ck and assume that it is not the only clause starting by xi
or −xi . We will add the symbols Lk , −Lk , Uk , −Uk to create 4 new subintervals (two around
xi and two around −xi ) where we will fix Zk and −Zk . Also, we will add the new symbols
Yk to be the mirror image of Zk with respect to xi (or −xi ), and −Yk to be the mirror image
of −Zk with respect to xi (or −xi ).
11

The following triples express that the symbols Zk , Yk , Lk and Uk are all placed on the
positive side, or in the negative side, and similarly for the negated symbols −Zk , −Yk , −Lk
and −Uk .
(Zk , X, −Yk ) (−Zk , X, Yk )
(Zk , X, −Lk ) (−Zk , X, Lk )
(9)
(Zk , X, −Uk ) (−Zk , X, Uk )
First, if the k th clause is the first clause in the ordering that starts by xi or −xi , we need
the following triples saying that |xi | < |Uk | and |Lk | < |xi |.
(−Uk , xi , Uk ) (−Uk , −xi , Uk )
(−xi , Lk , xi ) (−xi , −Lk , xi )

(10)

Second, if the k th clause is not the first one in the ordering that has xi or −xi as its
first literal (i.e. ak−1 , ak ∈ {−xi , xi }), we proceed by introducing the following triples. By
induction, we assume that for the previous (k − 1)st clause, the subintervals were created
using Lk−1 and Uk−1 with the corresponding Zk−1 and Yk−1 in them. In this case, we need
the triples saying that |Zk−1 | < |Uk | and |Yk−1 | < |Uk | (instead of the first two triples of
Equation 10):
(−Uk , Zk−1 , Uk ) (−Uk , −Zk−1 , Uk )
(11)
(−Uk , Yk−1 , Uk ) (−Uk , −Yk−1 , Uk )
and the triples saying that |Lk | < |Zk−1 | and |Lk | < |Yk−1 | (instead of the last two triples of
Equation 10).
(−Zk−1 , Lk , Zk−1 ) (−Zk−1 , −Lk , Zk−1 )
(12)
(−Yk−1 , Lk , Yk−1 ) (−Yk−1 , −Lk , Yk−1 )
At this point, we have Zk−1 either between two consecutive L symbols, or between two
consecutive U symbols. The same is true for −Zk−1 , Yk−1 and −Yk−1 .
Now, we need triples to locate Zk , −Zk , Yk and −Yk in the newly created intervals. We
add triples saying that Lk and Uk are between Yk and Zk , and similarly for the negated
symbols.
(Zk , Uk , Yk )
(Zk , Lk , Yk )
(13)
(−Zk , −Uk , −Yk ) (−Zk , −Lk , −Yk )
Since the L and U symbols are nested around xi and −xi , this puts the Yk and Zk symbols
in their corresponding region around xi and −xi .
Finally, we need to keep the Zk , −Zk , Yk , and −Yk from being too far from xi or −xi and
intruding in the region of xi+1 , −xi+1 , xi−1 , or −xi−1 . This was done already for the Zk and
−Zk symbols in Equations 6 and 7, and now we will do it for the Yk and −Yk symbols. This
is important in the case that the k th clause is the last one containing xi or −xi as its first
literal. To do this, we need additional clauses saying that |Mi | < |Yk | and |Yk | < |Mi+1 |.
(Yk , Mi , −Yk )
(Yk , −Mi , −Yk )
(Mi+1 , Yk , −Mi+1 ) (Mi+1 , −Yk , −Mi+1 )
Theorem 3.1. cBetweenness is ASP-complete.
12

(14)

Proof. Given a 3CNF instance of cNAE-3SAT {ak ∨ bk ∨ ck : 1 ≤ k ≤ l}, on the set
of variables {x1 , . . . , xn } and a subset of the constants {T, F }, we can create an instance
of cBetweenness by using Equations 1-14. We show how to build a bijection between
satisfying truth assignments for the formula instance and betweenness orderings that are
solution to the cBetweenness instance.
To define the total betweenness orderings, we consider the line segment [−n − 1, n + 1]
and define a mapping φσ for every truth assignment σ of the variables x1 , . . . , xn . While the
domain of σ is {x1 , . . . , xn }, the domain of φσ , S = dom(φσ ), is contained in
{x1 , . . . , xn , −x1 , . . . , −xn , m, M, X, M1 , . . . , Mn , −M1 , . . . , −Mn ,
Z1 , . . . , Zl , −Z1 , . . . , −Zl , Y1 , . . . , Yl , −Y1 , . . . , −Yl ,
L1 , . . . , Ll , −L1 , . . . , −Ll , U1 , . . . , Ul , −U1 , . . . , −Ul }.
The mapping φσ of truth assignments to orderings can now be defined the following way.
First as a general property of φσ , let us say that φσ (−x) = −φσ (x), for every symbol x of
the instance. If σ(xi ) = T , then φσ (xi ) = i (and φσ (−xi ) = −i), and otherwise φσ (xi ) = −i
(and φσ (−xi ) = i). At this point the symbols, xi and −xi get fixed in the interval [−n, n] on
opposite sides of 0. Note that the symbol X represents 0 in the ordering, that is, φσ (X) = 0.
This part of the definition of φσ fulfills Equation 1. Next, we put m below −n, and M above
n (i.e. φσ (m) = −n − 1 and φσ (M ) = n + 1), as is required for the definition of a betweenness
ordering for cBetweenness.
Next, we define the ordering function for the Mi symbols. If φσ (xi ) > 0, then φσ (Mi ) =
φσ (xi ) − 1/2 and φσ (−Mi ) = φσ (−xi ) + 1/2. If φσ (xi ) < 0, then φσ (Mi ) = φσ (xi ) + 1/2 and
φσ (−Mi ) = φσ (−xi ) − 1/2. This definition fulfills Equations 2 and 3.
Now, for every k, 1 ≤ k ≤ l, we have to fix the position of every Zk under the mapping
φσ . Recall that each clause ak ∨ bk ∨ ck is ordered from smaller to larger index. We begin
with the case where only this clause begins with the variable represented by ak . Then, no
additional auxiliary variables (i.e. Yk , Lk , and Uk ) were introduced, and only Zk has to be
placed in the order. There are six cases based on possible truth values assigned to ak , bk , and
ck (as noted above, ak = bk = ck = f alse and ak = bk = ck = true are no satisfying truth
assignments for an instance of cNAE-3SAT. If σ(ak ) = σ(ck ) and σ(bk ) has the opposite
value (i.e. the cases of ak = ck = f alse and bk = true, and ak = ck = true and bk = f alse),
then Zk will be set around −φσ (ak ), since the Equations 5 and 6, the fact that the index of
bk is bigger than that of ak , and the fact that we have the triple (Zk , X, ck ) of Equation 3.
Note that the triples in Equation 7 fix the positions of φσ (Zk ) to one side of −φσ (ak ). For
the remaining cases where σ(ak ) 6= σ(ck ) we define φσ to place Zk near φσ (ak ), again by
Equations 3, 5, and 6. The general definition is as follows:

if σ(ak ) 6= σ(ck ) and σ(bk ) = true
φσ (ak ) + 14



1
φσ (ak ) − 4
if σ(ak ) 6= σ(ck ) and σ(bk ) = f alse
φσ (Zk ) =
1
φ
(−a
)
+
if σ(ak ) = σ(ck ) and σ(bk ) = true

σ
k
4


1
φσ (−ak ) − 4 if σ(ak ) = σ(ck ) and σ(bk ) = f alse.
If there is only one clause beginning with a given literal or its negation, then by the
triples in Equations 1 to 9, all the symbols (as well as their negations) are fixed.
13

There might be a number of clauses with the same variable in the first position of the
disjunction. The positions of these respective Zk ’s have to be fixed, as well as the auxiliary
variables, Lk , Uk and Yk ’s. By the triples in Equations 12, 13 and 14 the auxiliary variables
Lk and Uk (and the negative ones) are nested around φσ (ak ) and φσ (−ak ) forming intervals,
and Zk and Yk are set inside intervals of consecutive Lk ’s or consecutive Uk ’s (see Figure 4).
We assume that this is the pth clause that begins with the same variable. Then, as above,
the exact placement of these variables depends on σ. Define φσ as follows:
• Case 1: σ(ak ) = f alse, σ(bk ) = f alse, σ(ck ) = true:
φσ (Lk ) = φσ (ak ) +
φσ (Zk ) = φσ (ak ) −

p
2l
2p+1
4l

φσ (Uk ) = φσ (ak ) − 2lp
φσ (Yk ) = φσ (ak ) + 2p+1
4l

• Case 2: σ(ak ) = f alse, σ(bk ) = true, σ(ck ) = f alse:
φσ (Lk ) = −φσ (ak ) −
φσ (Zk ) = −φσ (ak ) +

p
2l
2p+1
4l

φσ (Uk ) = −φσ (ak ) + 2lp
φσ (Yk ) = −φσ (ak ) − 2p+1
4l

• Case 3: σ(ak ) = f alse, σ(bk ) = true, σ(ck ) = true:
φσ (Lk ) = φσ (ak ) +
φσ (Zk ) = φσ (ak ) +

p
2l
2p+1
4l

φσ (Uk ) = φσ (ak ) − 2lp
φσ (Yk ) = φσ (ak ) − 2p+1
4l

• Case 4: σ(ak ) = true, σ(bk ) = f alse, σ(ck ) = f alse:
φσ (Lk ) = φσ (ak ) −
φσ (Zk ) = φσ (ak ) −

p
2l
2p+1
4l

φσ (Uk ) = φσ (ak ) + 2lp
φσ (Yk ) = φσ (ak ) + 2p+1
4l

• Case 5: σ(ak ) = true, σ(bk ) = f alse, σ(ck ) = true:
φσ (Lk ) = −φσ (ak ) +
φσ (Zk ) = −φσ (ak ) −

p
2l
2p+1
4l

φσ (Uk ) = −φσ (ak ) − 2lp
φσ (Yk ) = −φσ (ak ) + 2p+1
4l

• Case 6: σ(ak ) = true, σ(bk ) = true, σ(ck ) = f alse:
φσ (Lk ) = φσ (ak ) −
φσ (Zk ) = φσ (ak ) +

p
2l
2p+1
4l

φσ (Uk ) = φσ (ak ) + 2lp
φσ (Yk ) = φσ (ak ) − 2p+1
4l

For each of these cases, it can be easily checked that the auxiliary variables satisfy Equations 9-14.
We have shown that given a satisfying truth assignment σ, there exists a mapping,
φσ : S → [−n − 1, n + 1]. This mapping induces a natural ordering on S that we will call
fσ : S → [0, |S| + 1]. For s1 , s2 ∈ S,
fσ (s1 ) < fσ (s2 ) ⇐⇒ φσ (s1 ) < φσ (s2 ).
14

M3 -x2 -M2
-Z4

-x1

Z 3 -Z 2 -Z1
U3 -U2 -U1

-M1
-Y1

X

M1

-Y2 Y3

-L1 -L2

x1

-Y3 Y2
-L 3 L 2

L3

Y1

M2 x 2 -M3 -x3
Z1

L1

U1

Z 2 -Z 3

Z4

U2 -U3

Figure 4: Equations 9-14 fix the locations of the Z symbols, as well as the auxiliary variables
uniquely in the order. Above illustrates the location of these auxiliary symbols for the σ1 truth
assignment from Figure 1.

Note that this fixes the minimal and maximal elements, m and M so that fσ (m) = 0 and
fσ (M ) = |S| + 1. Further, we note that fσ satisfies Equations 1-14, since φσ satisfied them
and has the same ordering. We note that, by construction, each satisfying truth assignment,
σ, uniquely defines fσ . This construction can be done in quadratic time in |S|. Since the
number of auxiliary variables in S is bounded polynomially in n, we have a polynomial time
reduction from cNAE-3SAT to cBetweenness.
Now we need to show the converse. Given a betweenness ordering on S that satisfies all
the triples obtained from an instance, we need to define an assignment that for every clause,
there is one literal satisfied and one literal falsified. We define the assignment as follows.
For all symbols xi (resp. −xi ) such that f (xi ) > f (X) (resp. f (−xi ) > f (X)), we assign xi
(resp. −xi ) to true. Similarly, for all symbols xi (resp. −xi ) such that f (xi ) < f (X) (resp.
f (−xi ) < f (X)), we assign xi (resp. −xi ) to false. Furthermore, let m be the constant F ,
and let M be the constant T . Now, we have to see that the assignment obtained satisfies
at least one literal, and falsifies at least one literal of every clause. Equation 5 ensures that
for a given clause ak ∨ bk ∨ ck , not all three literals can be to the right of X or to the left of
X. Therefore, the assignment created from the ordering will set at least one literal to true
and at least one literal to false. Lastly, we note that if two betweenness orderings on S, f1
and f2 , yield identical truth assignments on {x1 , . . . , xn }, then, by Equations 1-4, f1 and f2
agree on the ordering of {x1 , . . . , xn , −x1 , . . . , −xn , m, M, X}. Further, Equations 5-14 fix
the remainder auxiliary variables, and as such, we must have f1 = f2 .

3.2

The Quartet Challenge is coNP-complete

In this section, we show that the Quartet Challenge is coNP-complete. To this end,
we extend the original argument of Steel [27, Theorem 1] that showed that the related question, Quartet Compatibility, is NP-complete. He reduced Betweenness to Quartet
Compatibility by mapping a betweenness ordering to a caterpillar tree (for a definition, see
below). Under that reduction, multiple solutions to an instance ψ of the Quartet Compatibility problem could correspond to a single solution of the Betweenness instance that is
obtained by transforming ψ. To prove that the Quartet Challenge is coNP-complete,
we extend Steel’s polynomial-time reduction from Betweenness to an ASP-reduction from
15

α

x1

β

x2

x3

x4

x5

Figure 5: The caterpillar αx1 |x2 x3 x4 |x5 β.
cBetweenness to Quartet Compatibility.
We first give some additional definitions. Let A be a finite set, and let C be a set of
ordered triples of elements from A. Let (x, y) be a pair of elements of A such that no triple
of C contains x and y. We say that (x, y) is a lost pair with regards to A and C.
Let T be an unrooted phylogenetic tree. A pair of leaves (a, b) of T is called a cherry
(or sibling pair) if a and b are leaves that are adjacent to a common vertex of T . Furthermore, T is a caterpillar if T is binary and has exactly two cherries. Following [27], we
say that T is an αβ-caterpillar, if α and β are leaves of distinct cherries of T . We write
αx1 |x2 x3 . . . xn−1 |xn β to denote the caterpillar whose two cherries are (α, x1 ) and (xn , β),
and, for each i ∈ {1, 2, . . . , n}, the path from α to xi consists of i + 1 edges. Now, let
αx1 |x2 x3 . . . xn−1 |xn β be an αβ-caterpillar. For each i, j ∈ {1, 2, . . . , n} with i 6= j, we say
that the path from xi to xj crosses xk if and only if i < k < j or j < k < i. For example,
Figure 5 shows an αx1 |x2 x3 x4 |x5 β-caterpillar whose path from x1 to x4 crosses x2 and x3 .
Before we prove the main result of this section (Theorem 3.3), we need a lemma.
Lemma 3.2. Let T be a phylogenetic tree, and let ab|cd be a quartet that is displayed by T .
Then no element of {(a, c), (a, d), (b, c), (b, d)} is a cherry of T .
Proof. By the definition of a quartet, the path from a to b in T does not intersect the path
from c to d in T . Thus, no element of {(a, c), (a, d), (b, c), (b, d)} is a cherry of T .
Theorem 3.3. Quartet Compatibility is ASP-complete.
Proof. We start by noting that it clearly takes polynomial time to decide whether or not
a phylogenetic tree T displays a given set Q of quartets since it is sufficient to check if
T |L(q) ∼
= q for each quartet q in Q. Hence, Quartet Compatibility is in FNP.
To show that Quartet Compatibility is ASP-complete, we next describe an ASPreduction from cBetweenness to Quartet Compatibility. Let ψ be an instance of
cBetweenness over a finite set A = {a1 , a2 , . . . , as } ∪ {m, M }. Let C = {π1 , π2 , . . . , πn }
be the set of triples of ψ, with πi = (bi , ci , di ) for each i ∈ {1, 2, . . . , n}, such that each
element of A ∪ {m, M } is contained in at least one triple. Recall that m is the first and M
the last element of each betweenness ordering f of A ∪ {m, M } for C; that is f (m) = 0 and
f (M ) = |A| + 1. For simplicity throughout this proof, let A0 = A ∪ {m, M }. Furthermore,
let L = {τn+1 , τn+2 , . . . , τn0 } precisely be the set of all lost pairs with regards to A0 and C,
where τi = (xi , yi ) for each i ∈ {n + 1, n + 2, . . . , n0 }.

16

We next describe six sets of quartets:
1. Each triple πi = (bi , ci , di ) in C is represented by 6 quartets in
Q1 =

n
[

Qπi =

i=1

n
[

{pi p0i |bi ci , pi bi |ci di , pi ci |di qi , pi di |qi qi0 , αpi |p0i β, αqi |qi0 β}.

i=1

2. Each lost pair τi = (xi , yi ) in L is represented by 5 quartets in
0

Q2 =

n
[

0

Qτi =

i=n+1

n
[

{pi p0i |xi yi , pi xi |yi qi , pi yi |qi qi0 , αpi |p0i β, αqi |qi0 β}.

i=n+1

3. Let aj , ak ∈ A0 , and let a be any fixed element of A. Set Q3 , Q4 , and Q5 to be the
following:
n0 i−1
[
[
Q3 =
{pi p0i |pj a, pi p0i |p0j a, qi qi0 |qj a, qi qi0 |qj0 a},
i=2 j=1
0

Q4 =

0

n [
n
[

{pi p0i |qj qj0 , pi p0i |qj a, pi p0i |qj0 a}, and

i=1 j=1
0

Q5 =

n s+2
[
[ j−1
[

{pi p0i |aj ak , qi qi0 |aj ak }.

i=1 j=2 k=1

4. Let ai , aj ∈ A, and set Q6 to be the following:
Q6 =

s i−1
[
[

{αm|ai aj , ai aj |M β}.

i=2 j=1

Noting that n0 is in the order of O(|A|3 ), the quartet set
Q=

6
[

Qi

i=1

can be constructed in polynomial time.
We note that for Steel’s original proof [27, Theorem 1], in which he describes a polynomialtime reduction from Betweenness to Quartet Compatibility in order to show that the
latter decision problem is NP-complete, the construction of Q1 is sufficient.
A straightforward analysis of the quartets in Qπi and Qτi , respectively, shows that <Qπi >
and <Qτi > contain the following phylogenetic trees which are all αβ-caterpillars:
<Qπi > = {αpi |p0i bi ci di qi |qi0 β, αqi |qi0 di ci bi pi |p0i β}
17

for each i ∈ {1, 2, . . . , n} and
<Qτi > = {αpi |p0i xi yi qi |qi0 β, αqi |qi0 yi xi pi |p0i β}
for each i ∈ {n + 1, n + 2, . . . , n0 }.
Let T be a phylogenetic tree of <Q>. By Q1 and Q2 , it is easily checked that either, if
pi and p0i are both crossed by the path from α to bi (resp. xi ) in T , then qi and qi0 are both
crossed by the path from β to bi (resp. xi ) in T , or if qi and qi0 are both crossed by the path
from α to bi (resp. xi ) in T , then pi and p0i are both crossed by the path from β to bi (resp.
xi ) in T for when i ∈ {1, 2, . . . , n} (resp. i ∈ {n + 1, n + 2, . . . , n0 }). We refer to this property
of T as the desired pq-property for i.
Let V be the set {p1 , . . . , pn0 , p01 , . . . , p0n0 , q1 , . . . , qn0 , q10 , . . . , qn0 0 }, and let T be a phylogenetic tree in <Q>. We continue with making several observations that will be important in
what follows:
1. The second and third quartet in Q1 , the second quartet in Q2 , and Lemma 3.2 imply
that T does not have a cherry (a, b) with a, b ∈ A0 .
2. The quartets in Q5 and Lemma 3.2 imply that T does not have a cherry (a, b) with
a ∈ A0 and b ∈ V .
3. The last two quartets in Q1 and Q2 , the quartets in Q3 , the first quartet in Q4 , and
Lemma 3.2 imply that T does not have a cherry (a, b) with a, b ∈ V .
In conclusion, T is an αβ-caterpillar. This observation leads to a number of additional
properties that are satisfied by T :
(i) By Q5 and the desired pq-property for each i ∈ {1, 2, . . . , n0 }, the subtree T (A0 ) can
be obtained from T by deleting exactly two of its edges.
(ii) Let i ∈ {1, 2, . . . , n0 }. Let P contain each element of ({p1 , p2 , . . . , pn0 , p01 , p02 , . . . , p0n0 } −
{pi , p0i }) that is crossed by the path from pi (and p0i ) to a in T for any a ∈ A0 . Then, by
Q3 , each element in P has an index that is smaller than i. Analogously, let P 0 contain
each element of ({q1 , q2 , . . . , qn0 , q10 , q20 , . . . , qn0 0 } − {qi , qi0 }) that is crossed by the path
from qi (and qi0 ) to a in T for any a ∈ A0 . Then, again by Q3 , each element in P 0 has
an index that is smaller than i.
(iii) Let a ∈ A0 . By the second and third quartet of Q4 the path from qi (and qi0 ) to a does
not cross an element of {p1 , p2 , . . . , pn0 , p01 , p02 , . . . , p0n0 } in T for each i ∈ {1, 2, . . . , n0 }.
(iv) By (i)-(iii), the path from pi (resp. qi ) to p0i (resp. qi0 ) in T consists of 3 edges for each
i ∈ {1, 2, . . . , n0 }. In particular, by the last two quartets of Q1 and Q2 , respectively,
the path from α to p0i (resp. qi0 ) crosses pi (resp. qi ) and the path from β to pi (resp.
qi ) crosses p0i (resp. qi0 ) in T .
18

e0

e

α

p5 p05 p4 p04 p1 p01

q3 q30 q2 q20

m

a

b

c

M

β

q1 q10 q4 q40 q5 q50

p2 p02 p3 p03

Figure 6: An αβ-caterpillar in <Q> that satisfies properties (i)-(v) for an instance of cBetweenness that consists of the four triples π1 = (m, a, b), π2 = (M, c, b), π3 = (c, a, m), and
π4 = (m, b, M ). Note that the associated set of lost pairs only contains τ5 = (a, M ). Details on
how to construct Q are given in in the proof of Theorem 3.3.

(v) By Q6 , the path from m to M crosses each element in A. Furthermore, neither the
path from α to m nor the path from β to M crosses an element of A.
To illustrate, Figure 6 shows an αβ-caterpillar T of <Q> and, consequently, satisfies properties (i)-(v) for an instance of cBetweenness that contains the four triples π1 = (m, a, b),
π2 = (M, c, b), π3 = (c, a, m), and π4 = (m, b, M ). Note that T (A0 ) can be obtained from T
by deleting the two edges e and e0 .
Now, let T be a phylogenetic tree in <Q>. Let T 0 be the phylogenetic tree obtained from
T by interchanging α and β, and for each i ∈ {1, 2, . . . , n0 }, interchanging pi and p0i , and qi
and qi0 . Noting that T 0 does display Q\Q6 but does not display Q since property (v) is not
satisfied, the rest of this proof essentially consists of two claims.
Claim 1. Let T and T 0 be two elements of <Q>. Then T ∼
= T 0 if and only if T |(A0 ∪{α, β}) ∼
=
0
0
T |(A ∪ {α, β}).
Trivially, if T ∼
= T 0 , then in particular T |(A0 ∪ {α, β}) ∼
= T 0 |(A0 ∪ {α, β}). To prove the
claim it is therefore sufficient to show that, if T  T 0 , then T |(A0 ∪{α, β})  T 0 |(A0 ∪{α, β}).
Assume the contrary. Then there exist two distinct elements T and T 0 in <Q> such that
T |(A0 ∪ {α, β}) ∼
= T 0 |(A0 ∪ {α, β}). Let a be an element of A0 . Since both of T and T 0 are
αβ-caterpillars that satisfy properties (i)-(v), there exists an i ∈ {1, 2, . . . , n0 } such that the
path from α to a crosses pi and p0i in one of T and T 0 , say T , while the path from α to a
crosses qi and qi0 in T 0 . By the desired pq-property for each i and property (i), note that
the path from β to a crosses qi and qi0 in T , and the path from β to a crosses pi and p0i in
T 0 . If i ∈ {1, 2, . . . , n}, let S = {α, β, pi , p0i , qi , qi0 , bi , ci , di }, and if i ∈ {n + 1, n + 2, . . . , n0 },
let S = {α, β, pi , p0i , qi , qi0 , xi , yi }. Since T |(S − {pi , p0i , qi , qi0 }) ∼
= T 0 |(S − {pi , p0i , qi , qi0 }), it now
follows that either T |S or T 0 |S is not an element of <Qπi > (if i ∈ {1, 2, . . . , n}) or <Qτi >
(if i ∈ {n + 1, n + 2, . . . , n0 }); thereby contradicting that T and T 0 are both in <Q>. This
completes the proof of Claim 1.
Claim 2. Q is compatible if and only if A0 has a betweenness ordering f for C with f (m) = 0
and f (M ) = |A|+1. In particular, there is a bijection from the solutions of ψ to the elements
in <Q>.
19

First, suppose that Q is compatible. Again, let T be an unrooted binary phylogenetic
tree in <Q>. Recall that the sets <Qπi > and <Qτi > both contain two αβ-caterpillars. Thus
T |{pi , p0i , qi , qi0 , α, β, bi , ci , di }
is isomorphic to one phylogenetic tree of <Qπi > for each i ∈ {1, 2, . . . , n}, and
T |{pi , p0i , qi , qi0 , α, β, xi , yi }
is isomorphic to one phylogenetic tree of <Qτi > for each i ∈ {n + 1, n + 2, . . . , n0 }. Noting
that T is an αβ-caterpillar, we next define a betweenness ordering of A0 for C. Let T ∗ be
T |{A0 ∪ {α, β}}, and define f : A0 → {1, 2, . . . , |A0 |} such that 2 + f (aj ) denotes the number
of edges on the path from α to aj in T ∗ for each aj ∈ A0 . Since T displays Qπi for each
i ∈ {1, 2, . . . , n} and the path from bi to di crosses ci in both phylogenetic trees of <Qπi >, it
follows that f (bi ) < f (ci ) < f (di ) or f (di ) < f (ci ) < f (bi ). Since this holds for each πi ∈ C,
it follows that f is a betweenness ordering of A0 for C. In particular, by property (v), we
have f (m) = 0 and f (M ) = |A| + 1. Furthermore, by Claim 1 and the paragraph prior to
Claim 1, each element of <Q> is mapped to a distinct betweenness ordering of A0 for C
with f (m) = 0 and f (M ) = |A| + 1.
Second, suppose that A0 has a betweenness ordering for C, and let f be one such ordering
with f (m) = 0 and f (M ) = |A|+1. Note that f imposes an ordering on each lost pair (xi , yi )
such that either f (xi ) < f (yi ) or f (yi ) < f (xi ). Furthermore, recall that n0 = |C| + |L| and
|A0 | = s + 2. Let T0 be the unique αβ-caterpillar, whose label set is A0 ∪ {α, β}, such that the
path from α to aj in T0 contains 2 + f (aj ) edges for each aj ∈ A0 . Let a be any element of A.
Next, we describe the algorithm BuildTree that iteratively construct a series T1 , T2 , . . . , Tn0
of αβ-caterpillars. Set i to be 1. To obtain Ti from Ti−1 , proceed in the following way:
Let P = {p1 , p2 , . . . , pi−1 , p01 , p02 , . . . , p0i−1 }. We first define two edges ei and e0i in Ti−1 . If
the path from α to a in Ti−1 crosses an element of P , let ei = {u, v} be the first edge on this
path such that u is adjacent to a leaf labeled with an element of P and v is adjacent to a
leaf labeled with an element that is not contained in P . Otherwise, choose ei to be the edge
that is incident with α. Similarly, if the path from β to a in Ti−1 crosses an element of P ,
let e0i = {u0 , v 0 } be the first edge on this path such that u0 is adjacent to a leaf labeled with
an element of P and v 0 is adjacent to a leaf labeled with an element that is not contained
in P . Otherwise, choose e0i to be the edge that is incident with β. Note that ei and e0i are
uniquely defined.
To obtain Ti from Ti−1 , we consider two cases. First, if i ∈ {1, 2, . . . , n} and f (bi ) <
f (ci ) < f (di ), or if i ∈ {n + 1, n + 2, . . . , n0 } and f (xi ) < f (yi ), subdivide the edge incident
with α twice and join each of the two newly created vertices with a new leaf labeled pi
and p0i , respectively, by introducing two new edges such that the path from α to p0i crosses
pi . Furthermore, subdivide e0i twice and join each of the two newly created vertices with a
new leaf labeled qi0 and qi , respectively, by introducing two new edges such that the path
20

e04

e4

α

p1 p01

q3 q30 q2 q20

m

a

b

c

M

q1 q10

β

p2 p02 p3 p03

e05

e5

α

p4 p04 p1 p01

q3 q30 q2 q20

m

a

b

c

M

q1 q10 q4 q40

β

p2 p02 p3 p03

Figure 7: The intermediate trees T3 (top) and T4 (bottom) that are obtained from applying the
algorithm BuildTree to the Betweenness instance that is described in the caption of Figure 6
for when m < a < b < c < M is the given betweenness ordering. Note that T4 is obtained from T3
by subdividing twice the edge that is incident with α and e04 , respectively. Furthermore, the tree
depicted in Figure 6 is obtained from T4 by applying one more iteration of BuildTree.

from β to qi crosses qi0 . Second, if i ∈ {1, 2, . . . , n} and f (di ) < f (ci ) < f (bi ), or if i ∈
{n + 1, n + 2, . . . , n0 } and f (yi ) < f (xi ), subdivide ei twice and join each of the two newly
created vertices with a new leaf labeled qi and qi0 , respectively, by introducing two new edges
such that the path from α to qi0 crosses qi . Furthermore, subdivide the edge incident with
β twice and join each of the two newly created vertices with a new leaf labeled p0i and pi ,
respectively, by introducing two new edges such that the path from β to pi crosses p0i . A
specific example of the definition of ei and e0i , respectively, and on how to obtain Ti from
Ti−1 is shown in Figure 7.
If i < n0 , increment i by 1 and repeat; otherwise stop. In this way, we obtain a tree
Tn0 that displays Q and, hence Q is compatible. In particular, Tn0 is an element of <Q>.
Furthermore, again by Claim 1 and the paragraph prior to Claim 1, Tn0 is the unique tree
of <Q> that has the property that Tn0 |(A0 ∪ {α, β}) ∼
= T0 . Thus, each betweenness ordering
f of A0 for C with f (m) = 0 and f (M ) = |A| + 1 is mapped to a distinct element of <Q>.
This completes the proof of Claim 2.
It now follows that the presented transformation from an instance of cBetweenness to
an instance of Quartet Compatibility is an ASP-reduction that can be carried out in
polynomial time. Hence, Quartet Compatibility is ASP-complete. This establishes the
proof of this theorem.
Now recall that ASP-completeness implies NP-completeness of the corresponding decision
problem, say Πd [30, Theorem 3.4]. Since Πd is exactly the complementary question of the
Quartet Challenge (see last paragraph of Section 2), the next corollary immediately
follows.

21

Corollary 3.4. The Quartet Challenge is coNP-complete.

4

Conclusion

In this paper, we have shown that the two problems cBetweenness and Quartet Compatibility that have applications in computational biology are ASP-complete. Thus, given
a betweenness ordering or a phylogenetic tree that displays a set of quartets, it is computationally hard to decide if another solution exists to a problem instance of cBetweenness
and Quartet Compatibility, respectively. If there is another solution, then this may imply that a data set that underlies an analysis does not contain enough information to obtain
an unambiguous result. Furthermore, by Corollary 3.4, the ASP-completeness of Quartet
Compatibility implies that the Quartet Challenge, which is one of Mike Steel’s $100
challenges [28], is coNP-complete. Lastly, due to [30, Theorem 3.4], regardless of how many
solutions to an instance of cBetweenness or Quartet Compatibility are known, it is
always NP-complete to decide whether an additional solution exists.
Unless P=NP, the existence of efficient algorithms to exactly solve the above-mentioned
two problems is unlikely. Nevertheless, there is a need to develop exact algorithms that solve
small to medium sized problem instances and, most importantly, return all solutions. For example, it might be possible to start filling this gap by using fixed-parameter algorithms that
have recently proven to be particularly useful to approach many questions in computational
biology [15]. Alternatively, heuristics and polynomial-time approximation algorithms often
provide a valuable tool to efficiently approach problem instances of larger size. While Chor
and Sudan [7] established a geometric approach to approximate a betweenness ordering that
satisfies at least one half of a given set of constraints, the statement of Quartet Compatibility does not directly allow for an approximation algorithm since it is a recognition-type
problem. Nevertheless, since compatible quartet sets are rare, the goal of a related problem
is, given a set of quartets, to reconstruct a phylogenetic tree that displays as many quartets
as possible. This problem is known as the Maximum Quartet Consistency problem.
Despite its NP-hardness [3, 27], several exact algorithms (e.g. see [2, 29] and references
therein) as well as a polynomial-time approximation [20] exist. It would therefore be interesting to investigate if these algorithms can be extended in a way such that they return
all solutions in order to analyze whether a unique phylogenetic tree displays a given set of
compatible quartets.
We end this paper by noting that the computational complexity of the Quartet Challenge changes greatly if all elements in a set of quartets over n taxa have a common taxa,
say x. By rooting each quartet at x, i.e. deleting the vertex labeled x and its incident edge
and regarding the resulting degree-2 vertex as the root, we obtain a set S of rooted triples
(rooted phylogenetic trees on three taxa). By applying the Build algorithm it can now be
checked in polynomial time if S is compatible [26, Proposition 6.4.4]. Furthermore, there is
a unique rooted phylogenetic tree on n taxa that displays S if and only if Build returns a
rooted binary phylogenetic tree [5, Proposition 2]. If Build returns a rooted phylogenetic
tree that is not binary, then every refinement of this tree also displays S.
22

5

Acknowledgments

We would like to thank Juraj Stacho (University of Haifa) for pointing out an oversight in
an earlier version of this paper, and Ward Wheeler (American Museum of Natural History)
for insightful conversations. The project was partially supported by grants from the Spanish
Government (TIN2007-68005-C04-03 to Bonet and Linz), (TIN2010-20967-C04-04 to Bonet)
and from the US National Science Foundation (#09-20920 to St. John).

References
[1] M. E. J. Amaral, J. R. Grant, P. K. Riggs, N. B. Stafuzza, E. A. R. Filho, T. Goldammer,
R. Weikard, R. M. Brunner, K. J. Kochan, A. J. Greco, J. Jeong, Z. Cai, G. Lin, A. Prasad,
S. Kumar, G. P. Saradhi, B. Mathew, M. A. Kumar, M. N. Miziara, P. Mariani, A. R. Caetano,
S. R. Galvão, M. S. Tantia, R. K. Vijh, B. Mishra, S. B. Kumar, V. A. Pelai, A. M. Santana,
L. C. Fornitano, B. C. Jones, H. Tonhati, S. Moore, P. Stothard, and J. E. Womack, “A first
generation whole genome RH map of the river buffalo with comparison to domestic cattle,”
BMC Genomics, vol. 9, no. 631, pp. 1–11, 2008.
[2] A. Ben-Dor, B. Chor, D. Graur, R. Ophir, and D. Pelleg, “From four-taxon trees to phylogenies:
the case of mammalian evolution,” in Proceedings of RECOMB’98, 1998, pp. 9–19.
[3] V. Berry, T. Jiang, P. Kearney, M. Li, and T. Wareham, “Quartet cleaning: improved algorithms and simulations,” in Proceedings of ESA99, ser. LNCS 1643, 1999, pp. 313–324.
[4] V. Berry and O. Gascuel, “Inferring evolutionary trees with strong combinatorial evidence,”
Theoret. Comput. Sci., vol. 240, no. 2, pp. 271–298, 2000.
[5] D. Bryant and M. Steel, “Extension operations on sets of leaf-labelled trees,” Adv. in Appl.
Math., vol. 16, no. 4, pp. 425–453, 1995.
[6] P. Buneman, “A note on the metric properties of trees,” J. Combinatorial Theory Ser. B,
vol. 17, pp. 48–50, 1974.
[7] B. Chor and M. Sudan, “A geometric approach to betweenness,” SIAM J. Discrete Math.,
vol. 11, no. 4, pp. 511–523, 1998.
[8] B. P. Chowdhary, T. Raudsepp, S. R. Kata, G. Goh, L. V. Millon, V. Allan, F. Piumi,
G. Guerin, J. Swinburne, M. Binns, T. L. Lear, J. Mickelson, J. Murray, D. F. Antczak, J. E.
Womack, and L. C. Skow, “The first-generation whole-genome radiation hybrid map in the
horse identifies conserved segments in human and mouse genomes,” Genome Research, vol. 13,
no. 742-751, 2003.
[9] S. A. Cook, “The complexity of theorem-proving procedures,” in Proceedings of the Third
Annual ACM Symposium on Theory of Computing, ser. STOC ’71. New York, NY, USA:
ACM, 1971, pp. 151–158.
[10] D. Cox, M. Burmeister, E. Price, S. Kim, and R. Myers, “Radiation hybrid mapping: a somatic cell genetic method for constructing high-resolution maps of mammalian chromosomes,”
Science, vol. 250, no. 4978, pp. 245–250, 1990.

23

[11] C. Dowden, “On the maximum size of minimal definitive quartet sets,” Discrete Mathematics,
2010.
[12] P. Erdös, M. Steel, L. Székély, and T. Warnow, “A few logs suffice to build almost all trees
–II,” Theor. Comp. Sci., vol. 221, pp. 77–118, 1999.
[13] L. R. Foulds and R. L. Graham, “The Steiner problem in phylogeny is NP-complete,” Adv. in
Appl. Math., vol. 3, no. 1, pp. 43–49, 1982.
[14] M. Garey and D. Johnson, Computers and intractability. A guide to the theory of NPcompleteness. A Series of Books in the Mathematical Sciences. WH Freeman and Company,
San Francisco, Calif, 1979.
[15] J. Gramm, A. Nickelsen, and T. Tantau, “Fixed-parameter algorithms in phylogenetics,” The
Computer Journal, 2007.
[16] S. Grünewald, P. Humphries, and C. Semple, “Quartet Compatibility and the Quartet Graph,”
The Electronic Journal of Combinatorics, vol. 15, no. R103, 2008.
[17] G. Gyapay, K. Schmitt, C. Fizames, H. Jones, N. Vega-Czarny, D. Spillett, D. Muselet, J.-F.
Prud’Homme, C. Dib, C. Auffray, J. Morissette, J. Weissenbach, and P. N. Goodfellow, “A
radiation hybrid map of the human genome,” Human Molecular Genetics, vol. 5, no. 3, pp.
339–346, 1996.
[18] M. Habib and J. Stacho, “Unique perfect phylogeny is NP-hard,” November 2010, arXiv
1011.5737.
[19] D. Huson, S. Nettles, and T. Warnow, “Disk-covering, a fast-converging method for phylogenetic tree reconstruction,” Comput. Biol., vol. 6, pp. 369–386, 1999.
[20] T. Jiang, P. Kearney, and M. Li, “Some open problems in computational molecular biology,”
J. Algorithms, vol. 34, no. 1, pp. 194–201, 2000.
[21] L. Juban, “Dichotomy theorem for the generalized unique satisfiability problem,” in Proceedings of FCT 1999, ser. LNCS 1684,, 1999, pp. 327–338.
[22] J. Opatrny, “Total ordering problem,” SIAM J. of Computing, vol. 8, no. 1, pp. 111–114, 1979.
[23] C. Papadimitriou, Computational complexity.

John Wiley and Sons Ltd., 2003.

[24] S. Roch, “A short proof that phylogenetic tree reconstruction by maximum likelihood is hard,”
IEEE/ACM Transactions on Computational Biology and Bioinformatics, vol. 3, no. 1, pp. 92–
94, 2006.
[25] C. Semple and M. Steel, “A characterization for a set of partial partitions to define an X-tree,”
Discrete Mathematics, vol. 247, no. 1, pp. 169–186, 2002.
[26] ——, Phylogenetics.

Oxford University Press, 2003.

[27] M. Steel, “The complexity of reconstructing trees from qualitative characters and subtrees,”
Journal of Classification, vol. 9, pp. 91–116, 1992.

24

[28] ——, http://www.math.canterbury.ac.nz/˜m.steel/.
[29] G. Wu, J. You, and G. Lin, “A lookahead branch-and-bound algorithm for the maximum
quartet consistency problem,” in Proceedings of WABI’05, ser. LNBI 3692, 2005, pp. 65–76.
[30] T. Yato and T. Seta, “Complexity and completeness of finding another solution and its application to puzzles,” IEICE Transactions on Fundamentals of Electronics, Communications
and Computer Sciences, vol. E86-A, no. 5, pp. 1052–1060, 2003.

25

