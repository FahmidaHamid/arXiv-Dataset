arXiv:0902.2970v1 [q-bio.PE] 17 Feb 2009

Regular networks are determined by their trees
Stephen J. Willson
Department of Mathematics
Iowa State University
Ames, IA 50011 USA
swillson@iastate.edu
February 24, 2013

Abstract. A rooted acyclic digraph N with labelled leaves displays a tree T
when there exists a way to select a unique parent of each hybrid vertex resulting
in the tree T . Let T r(N ) denote the set of all trees displayed by the network N .
In general, there may be many other networks M such that T r(M ) = T r(N ).
A network is regular if it is isomorphic with its cover digraph. This paper shows
that if N is regular, there is a procedure to reconstruct N given T r(N ). Hence
if N and M are regular networks and T r(N ) = T r(M ), it follows that N = M ,
proving that a regular network is uniquely determined by its displayed trees.

1

Introduction

It has become common, for a given collection X of taxa and given a particular gene g, to use phylogenetic methods to determine a phylogenetic tree T g .
The extant taxa correspond to leaves of the trees, while internal vertices correspond to ancestral species. The arcs correspond to genetic change, typically by
mutations in the DNA such as substitutions, insertions, and deletions. Common methods for determining the trees include maximum likelihood, maximum
parsimony, and neighbor-joining, but many other methods are also utilized.
Commonly the use of a different gene h for the same collection X of taxa
results in a tree T h that differs from T g . Indeed, many different trees arise
for different genes g but the same X. For example [14] utilized 106 orthologs
common to seven species of yeast and an outgroup. The collection of 106
maximum-parsimony trees and 106 maximum-likelihood trees included more
than 20 different robustly supported topologies. While [14] concatenated the
data to try to achieve resolution, [9] employed consensus networks to display
the incompatibilities that existed among the trees.
One hypothesis to explain the deviations of such gene trees from a single
“species tree” is to assume “lineage sorting”. In this model a single species
tree is seen as a kind of pipeline containing populations with significant genetic
1

diversity; the genes actually fixate at locations that need not coincide with the
speciation events in the species tree. Hence the genes do not necessarily follow
the species tree. Coalescence methods such as [15], [7], [16] utilize this approach.
For example, [7] shows that the most likely gene tree need not coincide with
the species tree. Much of the resulting diversity, however, makes use of short
branch-lengths separating some speciation events in the species tree.
Another hypothesis to explain the deviations of such gene trees from a single “species tree” is to assume that evolution actually occurs on networks that
are not necessarily trees. Besides mutation events, these networks could include
such additional reticulation events as hybridization or lateral gene transfer. General frameworks are discussed in [1], [2], [12], and [13].
Even if the underlying species relationships are given by a network, the
evolution of an individual gene might best be described by a tree. The idea is
that, at a hybridization event, some genes would be inherited from one parent
species, and other genes from another parent species. Suppose, for example, the
underlying species network is M in Figure 1. Species 2 is hybrid with parental
species B and C. If a particular gene in 2 is inherited from B, then the correct
description of the inheritance of that gene would be tree b in Figure 2. If instead
a gene in 2 is inherited from C, then the correct description for that gene would
be tree c in Figure 2. Thus we would expect to see both trees b and c among
the various gene trees. Trees b and c are said to be displayed by the network.
On the other hand, tree d in Figure 2 is not displayed by M , so we would not
expect a gene to evolve according to d under these assumptions.

N

D
❅
❅
❘ F
❅
✠
E❍
✟
❍❍✟✟
✟✟❍❍
✙
❥❄H
❍
❄
G✟
❅
❅
❅
❅
✠
❘✠
❅
❘
❅
1
2
3

M

✠
1

A
❅
❅
✠B
❅
❘ C
❅
❅
❅
❅
❘
❅
❘✠
❅
2
3

Figure 1: Two phylogenetic networks with base-set X = {1, 2, 3}.
The assumption that the underlying description of evolutionary history is a
network rather than a tree raises the fundamental problem of reconstructing a
network from data. Suppose that a collection of gene trees for the same set X
of taxa is known. Can the underlying network be uniquely reconstructed?
If M is a network, let T r(M ) denote the set of rooted trees displayed by M .
Figure 1 shows two distinct networks M and N such that T r(M ) = T r(N ) =
{b, c}. This example represents a common situation. In general there may be
2

a

A
❅
❅
❘
❅

C
✠B
❅
❅
❄
✠
❘
❅
1
2
3
A
c
✁❅
✁ ❅
✁
❘ C
❅
✁
❅
✁
❅
☛
✁
✠
❘
❅
1
2
3

b

❆
❆

A

❆
B✠
❆
❅
❆
❅
❆❯
✠
❘
❅
1
2
3
✁❅
✁ ❅
✁
❘
❅
✁
❅
✁
❅
✁☛
✠
❘
❅
2
1
3
d

e

D
❅
❅
❘ F
❅

E✠
❅
❅
❘ H
G❄ ❅
❅
❅
❄
❄ ❅
❘
1
2
3

Figure 2: Some trees related to Figure 1. Both M and N display trees b and c
but not d.

many networks that display exactly the same trees.
One approach has been to seek a network that displays a collection of trees
and which has the fewest hybridization events. This problem was proved to be
NP-hard [4]. Various special cases with additional hypotheses on the networks
have also been studied, such as [18], [8], [10], [11].
A different approach has been to make assumptions on the properties of
an allowable phylogenetic network. It would be desirable to have a class of
phylogenetic networks which is biologically plausible and such that there is often
a uniquely determined network of this type with certain observable properties.
It is commonly assumed that the networks are rooted acyclic digraphs [17], [12],
[13]. Restrictions that appear tractable and yield interesting results include time
consistency [12], [6], roughly that the parents of a hybrid be contemporaneous.
Others include restrictions on the children of vertices, for example tree-child
networks [5] or tree-sibling networks [6]. Certain unique reconstructions for
“normal” networks are given in [19].
Baroni and Steel [3] defined the notion of a regular network. The precise
definition is given in Section 2. The basic idea is as follows: The cluster cl(v) of
a vertex v is the set of leaves which are descendents of v. In a regular network,
no two distinct vertices have the same cluster. Moreover, cl(u) ⊂ cl(v) iff there
is a directed path from v to u. In Figure 1, M is regular but N is not since in
N cl(D) = cl(E) = cl(F ) = {1, 2, 3}.
The main result of this paper is Theorem 3.1. This theorem gives a method
which, given T r(M ) for a regular network M uniquely reconstructs the network M . Corollary 3.2 asserts the consequence that if M and N are regular
networks with the same leaves and T r(M ) = T r(N ), then M = N . Thus the
entire collection of trees displayed by a regular network uniquely determines the
network.
3

Figure 1 shows that without the assumption of regularity, the network is not
uniquely determined by the set of its displayed trees. Another example is given
in Section 5.
The proof of Theorem 3.1 is constructive. A procedure MaximumProperChild is applied to the input D = T r(N ). When N is regular, the procedure
outputs the network N up to isomorphism. (In fact it outputs the cover digraph
of N, see [3].) An example is worked in section 4, illustrating the procedure.
Also in section 4, we observe that the input need not be D = T r(N ) but instead
might be an appropriate subset of T r(N ). Characterizing this subset, however,
remains an open problem.
It is not likely in a real biological problem that all the trees displayed by a
network are known. The number of such trees could easily grow exponentially
with the number of leaves. Hence the main theorem is primarily of theoretical
interest: For any two distinct regular phylogenetic networks there must exist a
tree displayed by one but not the other.
This situation contrasts with that in which the generalized clusters or tree
clusters of a network are given instead of all the displayed trees. For a network N , a generalized or tree cluster is any cluster of any tree T displayed
by N . The set of all tree clusters of N is denoted T rCl(N ). The paper [19]
presents examples of distinct regular networks (indeed normal networks) M and
N with the same leaf sets and which have precisely the same tree clusters; thus
T rCl(M ) = T rCl(N ) but M and N are not isomorphic. The author therefore finds it somewhat surprising that, as shown in the current paper, the trees
themselves do determine the network uniquely for a broad class of networks.

2

Basics

A directed graph or digraph N = (V, A) consists of a finite set V = V (N ) of
vertices and a finite set A = A(N ) of arcs, each consisting of an ordered pair
(u, v) where u ∈ V , v ∈ V , u 6= v, interpreted as an arrow from u (the parent )
to v (the child ). There are no multiple arcs and no loops. A directed path is
a sequence u0 , u1 , · · · , uk of vertices such that for i = 1, · · · , k, (ui−1 , ui ) ∈ A.
The length of the path is k and the path is trivial if k = 0. The graph is acyclic
if there is no nontrivial directed path starting and ending at the same point.
Write u ≤N v or more informally u ≤ v in N if there is a directed path starting
at u and ending at v. Write u < v if u ≤ v and u 6= v. If the graph is acyclic,
it is easy to see that ≤ is a partial order on V .
A vertex r is a root of the directed acyclic graph (V, A) if, for all v ∈ V ,
r ≤ v. The network is rooted if it has a root. Clearly there can be at most one
root.
The indegree of vertex u is the number of v ∈ V such that (v, u) ∈ A. The
outdegree of u is the number of v ∈ V such that (u, v) ∈ A. If N is rooted at
r then r is the only vertex of indegree 0. A leaf is a vertex of outdegree 0. A
normal (or tree) vertex is a vertex of indegree at most 1. A hybrid vertex (or
recombination vertex or reticulation node) is a vertex of indegree at least 2.

4

Let X be a set. The cardinality of X will be denoted |X|. In biological terms
we consider the members of X to be a specific collection of biological species. We
call X the base-set of the directed graph N = (V, A) if there is a given one-toone relationship between X and the subset L(N ) ⊆ V consisting of the leaves of
N . Thus we identify the leaves of N with the members of X. The interpretation
of X is that its members correspond to taxa on which direct measurements may
be made, while N describes a proposed evolutionary history giving rise to these
taxa. The leaves correspond to extant taxa so direct measurements are possible.
Typically one taxon is included which is an outgroup—-an extant species clearly
on a separate evolutionary track from all other taxa. Hence the root is located
as the attachment vertex of the outgroup taxon.
In this paper a (phylogenetic) network N = (V, A, r, X) is an acyclic digraph
(V, A) with root r and base-set X. Two networks N = (V, A, r, X) and M =
(V ′ , A′ , r′ , X) are isomorphic, N ∼
= M , iff there is a bijection φ : V → V ′ such
that for all x ∈ X, φ(x) = x, and (u, v) ∈ A iff (φ(u), φ(v)) ∈ A′ .
Let N = (V, A, r, X) be a phylogenetic network. Let P(X) denote the set of
all subsets of X. For v ∈ V , define the (full) cluster of v in N by cl(v, N ) = {x ∈
X : v ≤ x}. It is clear that for each v ∈ V , cl(v, N ) ∈ P(X). Define for each
phylogenetic network N with base-set X, clN : V → P(X) by clN (v) = cl(v, N ).
The following properties of the clusters are basic:
(1) For v ∈ V , clN (v) is nonempty.
(2) If u ≤N v, then clN (v) ⊆ clN (u).
(3) clN (r) = X.
(4) If x ∈ X, then clN (x) = {x}.
Note that (1) follows since a maximal path must end at a leaf and every leaf
lies in X. Morever (2) follows since ≤N is a partial order. In particular, if (u, v)
is an arc of N , then clN (v) ⊆ clN (u). Also, (3) follows since for each x ∈ X, we
have r ≤ x, and (4) follows since each x ∈ X satisfies that x is a leaf.
The clusters X and {x} for x ∈ X are called the trivial clusters since they
occur in each network. Any other clusters will be called nontrivial.
Given the network N = (V, A, r, X), we may let C(N ) = {clN (v) : v ∈ V } ⊆
P(X). The cover digraph of N is the digraph (W, E) where
(1) W = C(N ), and
(2) there is an arc (B, C) ∈ E for B and C in W iff
(2a) C ⊂ B; and
(2b) there is no D ∈ W such that C ⊂ D ⊂ B.
Note the root is X = clN (r) because for all x ∈ X, r ≤ x. Note since the
members of X are the leaves of N , it follows for each x ∈ X, clN (x) = {x} so
the leaves of the cover digraph are the singleton sets {x} for x ∈ X. Hence the
leaves may be identified with the members of X and the root r with X.
Baroni and Steel [3] defined a regular network to be a network which is
isomorphic with its cover digraph. Following is an equivalent description: The
phylogenetic network N = (V, A, r, X) is regular provided
(1) clN : V → P(X) is one-to-one; and
(2) there is an arc (u, v) ∈ A iff clN (v) ⊂ clN (u) and there is no w ∈ V such
that clN (v) ⊂ clN (w) ⊂ clN (u).
5

Let N = (V, A, r, X) be a phylogenetic network. A parent map for N is a
map p : V − {r} → V such that for each v ∈ V , v 6= r, p(v) is a parent of v, i.e.,
(p(v), v) ∈ A. Since the root r is unique, it is clear that if v ∈ V , v 6= r, then v
has a parent. Note that if v is normal and v 6= r, then v has exactly one parent
q, so all parent maps p will satisfy p(v) = q. When v is hybrid, however, there
are at least two parents of v.
Let P ar(N ) denote the collection of parent maps for the network N . Let
i(v, N ) denote the indegree of v in the
Q network N . Then the number of distinct
parent maps is clearly |P ar(N )| = [i(v, N ) : v ∈ V, v 6= r].
For any parent map p for N = (V, A, r, X) construct a new network Np =
(V, E, r, X) as follows: The vertex set, root, and base-set are the same as for
N . The arc set E consists of all arcs of the form (p(v), v) where v ∈ V , v 6= r.
Thus E ⊆ A.
Each vertex v other than r has exactly one parent in Np ; i.e., i(v, Np ) = 1.
Hence Np is a rooted tree. It is quite possible that v has outdegree 1 as well
as indegree 1, but such vertices are often suppressed in a rooted tree. We will
therefore consider two kinds of simplification to change Np into a rooted tree in
standard form.
Type 1: Suppress a vertex with outdegree 1. More specifically, if u has
outdegree 1, say via arc (u, v), then remove u; remove also each arc (w, u) and
replace it by arc (w, v).
Type 2: Suppress a vertex with no directed path to a member of X. More
specifically, suppose u is such a vertex. Then, delete u, for each arc (v, u) delete
(v, u), and for each arc (u, v), delete (u, v).
The result of performing all possible simplifications of Type 1 or Type 2 on
Np is denoted T (Np ), called the standard form of Np .
Figure 2 exhibits some rooted trees related to Figure 1. In M let the parent
map p satisfy p(2) = B (and trivially p(1) = B, p(3) = C, p(B) = A, p(C) = A).
Then the tree Mp is given in a. Since C has outdegree 1 in Fig 2a, it is suppressed
by Type 1, resulting in the standard form b, which is T (Mp ). Similarly if p′ is
the parent map with p′ (2) = C, then Fig 2c shows T (Mp′ ). The tree d is not
displayed by M since there is no parent map yielding d.
It is easy to see that N in Fig 1 also displays b and c. Consider the parent
map q for N given by q(2) = H, q(G) = E, q(H) = E. Then Nq = e in Figure
2. We simplify e by suppressing F by Type 2 and then D and G by Type
1. Hence T (Nq ) = c in Figure 2. For both the networks in figure 1, we have
T r(M ) = T r(N ) = {b, c} using the notation in Figure 2.

3

Reconstruction of regular networks from all
their trees

Suppose D is a nonempty collection of rooted trees each with the same base-set
X. In this section we present a procedure called MaximumProperChild (MPC)
which constructs a phylogenetic network MPC(D) given D. The algorithm

6

always terminates with a network.
The main theorem 3.1 asserts that if D = T r(N ) for some regular network
N , then the output of the procedure is N , so N has been reconstructed.
Theorem 3.1. Suppose N = (V, A, r, X) is a regular phylogenetic network.
Then the output of MaximumProperChild applied to D = T r(N ) is isomorphic
with N ; ie., M P C(T r(N )) ∼
= N.
An immediate consequence of Theorem 3.1 is Cor 3.2, which asserts that the
set of trees displayed by a regular network uniquely determines the network.
Corollary 3.2. Suppose M and N are regular phylogenetic networks with baseset X. If T r(M ) = T r(N ), then M ∼
= N.
Theorem 3.1 need not be true without the assumption that D includes all the
trees displayed by N . It is easy to find examples in which N is not reconstructed
if some trees are missing from D. On the other hand, it is also easy to find
examples in which D 6= T r(N ) but still M P C(D) = N . What is important is
that the “right” trees lie in D. Roughly speaking, the “right” trees are those
that arise via the use of Lemma 3.3. Further discussion of this point is in Section
5.
The number of displayed trees may be exponentially large in |X|, so the
algorithm need not be polynomial-time in |X|. It is easy to see, however, that
the procedure is polynomial-time in |X| + |D|.
Figure 1 shows that Cor 3.2 fails without the assumption of regularity.
Here is an overview of the procedure: We reconstruct the network N recursively by finding the clusters of N . Initially, we have only the root cluster,
which is X. At any given stage, given a cluster C = cl(u, N ) for some vertex u ∈ V we are able to identify the clusters of all its children in N . To
do so, by construction we will know already the clusters along a directed path
X = Pn , Pn−1 , · · · , P0 = C from X to C. The “proper trees” for C, denoted
P roperT r(C), will consist of any input trees T exhibiting all the clusters along
such a directed path already in our reconstruction. We list the clusters for the
children of C in all the proper trees for C. Among these we consider the set of
“maximal proper children,” denoted M axP roperCh(C), consisting of the clusters U for children of C in a proper tree, such that there is no other cluster
W which is a child of C in some proper tree and for which U ⊂ W ⊂ C. We
show that these maximal children are necessarily the clusters of children of C
in N , and all clusters of the children of C in N arise in this manner. Hence the
children of C are precisely the members of M axP roperCh(C). We insert the
members of M axP roperCh(C) into the set of vertices of our reconstruction,
together with arcs from C to each such vertex; then we continue recursively.
An example of the procedure will be given in Section 4.
The following is a precise more formal description:
Algorithm MaximumProperChild.
Input: D is a nonempty collection of rooted trees each with the base-set X.
7

Output: a regular phylogenetic network M with base-set X.
Procedure.We construct a sequence M0 , M1 , · · · of directed graphs where Mk =
(Vk , Ak ). Each member of Vk is a nonempty subset of X, and V0 ⊆ V1 ⊆ V2 ⊆
···.
1. Initially M0 = (V0 , A0 ) with V0 = {X} and A0 = ∅. Thus M0 has a single
vertex which is the cluster X. This vertex is not checked off.
Recursively perform the following step 2:
2. Suppose Mk = (Vk , Ak ) is known and some vertex U ∈ Vk is not checked
off.
2a. If Vk contains a singleton set C = {a} which is not checked off, then
Mk+1 = Mk except that {a} has been checked off.
2b. If Vk contains a doubleton set C = {a, b} which is not checked off, then
Vk+1 := Vk ∪ {{a}, {b}}, and Ak+1 = Ak ∪ {({a, b}, {a}), ({a, b}, {b})}. In Mk+1
check off all members of Vk that were already checked off and in addition check
off {a, b}, {a}, and {b} but nothing else. This thus adjoins the two singletons
{a} and {b}.
2c. Suppose neither 2a nor 2b applies. Suppose C ∈ Vk has not been
checked off. Let P roperT r(C) = {T ∈ D : C is a cluster of T and there
is a directed path X = Pn , Pn−1 , · · · , P1 , P0 = C in T such that for each i,
cl(Pi , T ) is a vertex of Mk and each arc (Pi , Pi−1 ) is an arc of Mk } be the set
of proper trees for C. Let P roperCh(C) = {D : for some T ∈ P roperT r(C),
D is a child of C} be the set of children of C in any proper tree for C. Let
M axP roperCh(C) = {D ∈ P roperCh(C) : there is no D′ in P roperCh(C) such
that D ⊂ D′ ⊂ C} (strict inclusions) be the set of maximal proper children of C.
For each D ∈ M axP roperCh(C), adjoin to M the vertex D (if it is not already
present) and the arc (C, D). More explicitly define Vk+1 = Vk ∪ {D : D ∈
M axP roperCh(C)}. Define Ak+1 = Ak ∪ {(D, C) : D ∈ M axP roperCh(C)}.
In Mk+1 check off all vertices checked off in Mk and also check off C but nothing
else. Note that it is possible that D is already present in Vk , but that this
construction may still introduce a new arc incoming to D.
3. The procedure terminates with Mn such that every member of Vn has
been checked off. Return Mn .
It is clear that the procedure always terminates, whether or not D = T r(N ).
This is because X is a finite set, so P(X) is finite and there can only be finitely
many vertices. At the end of 2a, 2b, or 2c an additional vertex is checked off.
Hence after finitely many steps all vertices must be checked off.
Moreover, whenever a new vertex D is added in step 2b or 2c, P roperT r(D)
is nonempty. This is trivially true if D arose as a singleton set in 2b. If D arose
in 2c, then there exists a parent C of D and T ∈ P roperT r(C). Hence T also
lies in P roperT r(D). Thus when 2c is applied to C containing at least three
members of X, it identifies a child D of C which is a nonempty proper subset
of C. It follows that when the procedure terminates, each singleton set {x} is
in Vn .
An example is given in the next section.

8

We now turn to the proof of Theorem 3.1. The first step is a lemma which
identifies a useful tree related to a given directed path in N .
Lemma 3.3. Let C be a vertex of N . Let Pn = r, Pn−1 , · · · , P1 , P0 = C be a
directed path in N from the root r to C. There exists a tree T displayed by N
in standard form such that, for i = 0, · · · , n, Pi is a vertex of T and we have
cl(Pi , T ) = cl(Pi , N ).
Proof. We find a tree T as follows: The parent map p which yields T is selected
by
(0) If W is normal, W 6= r, then p(W ) is the unique parent of W .
(1) If H is hybrid and C < H, choose a parent p(H) of H such that C ≤ p(H)
in N .
(2) Suppose n ≥ 1. If H is hybrid and P1 < H, but it is false that C < H,
choose p(H) such that P1 ≤ p(H) in N .
(3) Suppose n ≥ 2. If H is hybrid and P2 < H but it is false that P1 < H
(hence also false that C < H), then select p(H) such that P2 ≤ p(H) in N .
(k) In general, if n ≥ k, H is hybrid, and Pk < H but it is false that Pk−1 < H,
select p(H) such that Pk ≤ p(H) in N .
Since Pn = r, it follows that for each hybrid H, p(H) will be defined.
I claim that cl(C, Np ) = cl(C, N ). Clearly cl(C, Np ) ⊆ cl(C, N ). Conversely,
suppose W is a vertex of N and C ≤ W in N . I will show that C ≤ W in Np .
It suffices to show that whenever C < W in N , then there exists a parent P of
W in Np such that C ≤ P in N . The result is immediate if W has a unique
parent P in N because since C < W it follows C ≤ P . If, instead, W is hybrid,
then by assumption p(W ) is a parent of W in Np and by (1) C ≤ p(W ) in N .
This proves that C ≤ W in Np if C ≤ W in N . Now, if x ∈ cl(C, N ) the choice
W = x shows, since C ≤ x in N , that C ≤ x in Np , whence x ∈ cl(C, Np ). Thus
cl(C, Np ) = cl(C, N ).
Suppose n ≥ 1. I now claim that cl(P1 , Np ) = cl(P1 , N ). It is immediate
that cl(P1 , Np ) ⊆ cl(P1 , N ). For the converse, suppose x ∈ cl(P1 , N ). Suppose
W is a vertex of N and P1 ≤ W in N . I show that P1 ≤ W in Np . It suffices to
show that if P1 < W in N , then there exists a parent P of P1 in Np such that
P1 ≤ P in N . If C < W in N , then from above there exists a parent P of W in
Np such that C ≤ P in N , whence P1 ≤ C ≤ P in N . Hence we may assume
that C ≮ W in N . If W is normal, then its unique parent P must satisfy that
P ≤ W in Np (since arcs to normal vertices remain in Np ) whence P1 ≤ P in
N . If instead W is hybrid, then since P1 < W but C ≮ W it follows from (2)
that p(W ) satisfies P1 ≤ p(W ) in N . This proves that P1 ≤ W in Np if P1 ≤ W
in N . Now, if x ∈ cl(P1 , N ) the choice W = x shows, since P1 ≤ x in N , that
P1 ≤ x in Np , whence x ∈ cl(P1 , Np ). Thus cl(P1 , Np ) = cl(P1 , N ).
The argument can be iterated to show that for i = 0, · · · , n, cl(Pi , Np ) =
cl(Pi , N ).
Let T = T (Np ) be the standard form of Np obtained by suppressing vertices
of outdegree 1 and vertices with no directed paths to any member of X. By
regularity of N , the sets cl(Pi , N ) are distinct for i = 0, · · · , n. Hence the sets

9

cl(Pi , Np ) are distinct for i = 0, · · · , n. I claim that Pn , · · · , P0 are vertices of
T.
Note first that there exists a directed path in N of maximal length (number
of arcs) starting at P0 = C. The path must end at some leaf which consists of a
member x ∈ X since X contains all the leaves. From (0) and (1) it follows that
there is a path in Np from C to x as well; otherwise some vertex W on that
path would satisfy that C < W in N so some parent P of W satisfies C ≤ P ,
but p(W ) satisfies that C  p(W ), contradicting (0) or (1). Hence there is a
directed path in Np from C to x, whence also a directed path from each Pi to
x. It follows that no Pi is suppressed because there is no path to a member of
X.
Moreover, for i = 1, · · · , n, Pi is a vertex of T ; otherwise Pi would have outdegree 1 in Np whence cl(Pi , Np ) = cl(Pi−1 , Np ), whence cl(Pi , N ) = cl(Pi−1 , N ).
Moreover, I claim that C = P0 is a vertex of T . The claim is immediate if C is
a leaf. If C is not a leaf then C has children D1 , D2 , · · · , Dk in N , with k ≥ 2.
By regularity cl(Dj , N ) is a proper subset of cl(C, N ). If C were not a vertex
of T , it would have outdegree 1 in Np . Assume its child in Np is D1 . Then
cl(C, N ) = cl(C, Np ) = cl(D1 , Np ) ⊆ cl(D1 , N ) ⊂ cl(C, N ), a contradiction.
It follows that in T there is a directed path Pn = X, Pn−1 , · · · , P1 , P0 = C
such that for i = 0, · · · , n, cl(Pi , T ) = cl(Pi , N ).
We now prove theorem 3.1.
Proof. Let N be a regular network and D = T r(N ). Let the sequence of networks obtained from MPC be denoted M0 , M1 , · · · , Mn where Mi = (Vi , Ai )
has the set Vi of vertices and the set Ai of arcs. Initially V0 = {X} and A0 = ∅.
The proof will be by induction. The i-th inductive hypothesis Hi is that
(1) For each vertex U of Mi there exists a vertex U ′ of N such that U =
cl(U ′ , N ).
(2) For each arc (U, W ) of Mi , (U ′ , W ′ ) is an arc of N .
(3) For each vertex U of Mi that has at least one child in Mi , for every child
Y of U ′ in N , there exists a vertex W of Mi such that W is a child of U in Mi
and W ′ = Y .
H0 is trivially true since X is the only vertex of M0 and X ′ is the root of N .
Claim 1. Assume Hj and the procedure has not terminated. We show Hj+1 .
If 2a or 2b applies, then Claim 1 is immediate. Hence we assume that 2c
applies and there is a vertex C of Mj containing at least three points which has
not been checked off. Compute P roperT r(C) and M axP roperCh(C) as above.
By Hj , there exists vertex C ′ of N such that C = cl(C ′ , N ). It suffices to show
that
(a) for each child Y of C ′ in N , D := cl(Y, N ) lies in M axP roperCh(C); and
(b) each member of M axP roperCh(C) consists of a cluster D for which there
exists a child E of C ′ in N such that D = cl(E, N ).
We first prove (a):

10

Claim 1a. Let Y be a child of C ′ in N . Then D = cl(Y, N ) is a member of
M axP roperCh(C).
Since C is a vertex in Mj , there exists by Hj a directed path r = Pn , Pn−1 ,
Pn−2 , · · · , P1 , P0 = C ′ in N from r to C ′ such that for i = 0, · · · , n, cl(Pi , N )
is a vertex of M and for i = 1, · · · , n, (cl(Pi , N ), cl(Pi−1 , N )) is an arc of M .
(This is because C occurred in M as a child of some vertex, which occurred in
M as a child of some other vertex, etc.)
By Lemma 3.3, since Y is a child of C ′ in N , there exists a tree T in
T r(N ) that contains the directed path r = Qn , Qn−1 , · · · , Q0 , Q−1 for which
cl(Qi , T ) = cl(Pi , N ), cl(Q0 , T ) = cl(C ′ , N ) = C and cl(Q−1 , T ) = cl(Y, N ) =
D. By Hj , T ∈ P roperT r(C), so it follows that D = cl(Y, N ) ∈ P roperCh(C).
I claim that D ∈ M axP roperCh(C). Otherwise, there exists a tree T̂ in
P roperT r(C) with vertex Ĉ such that C = cl(Ĉ, T̂ ), Ĉ has child D̂ in T , and
D ⊂ cl(D̂, T̂ ) ⊂ C = cl(Ĉ, T̂ ). Let r = P̂m , P̂m−1 , ..., P̂0 = Ĉ be the directed
path from the root r to Ĉ in T̂ . By construction, for i = 0, · · · , m, cl(P̂i , T̂ ) is a
member of M and for i = 1, · · · , m, each arc (cl(P̂i , T̂ ), cl(P̂i−1 , T̂ )) is an arc in
Mj . By Hj , for each i, cl(P̂i , T̂ ) is a cluster of N ; i.e., there exists vertex Qi in
N such that cl(Qi , N ) = cl(P̂i , T̂ ) and (Qi , Qi−1 ) is an arc of N . In particular,
by regularity of N , Q0 = C ′ .
Let p̂ be the parent map that yields T̂ (i.e., T (Np̂ ) = T̂ ). Note for 0 ≤ i ≤ m
that P̂i is a vertex of both T̂ and Np̂ . Then cl(Qi , N ) = cl(P̂i , T̂ ) = cl(P̂i , Np̂ ) ⊆
cl(P̂i , N ). Since N is regular it follows that P̂i ≤ Qi in N . Since the arcs of Np̂
form a subset of the arcs of N , it follows from P̂i+1 ≤ P̂i in Np̂ that P̂i+1 ≤ P̂i
in N as well for i = 0, · · · , m − 1.
Since cl(P̂m , Np ) = X = cl(Qm , N ) it is clear that P̂m = Qm .
Now cl(Qm−1 , N ) = cl(P̂m−1 , Np̂ ) ⊆ cl(P̂m−1 , N ) ⊆ cl(P̂m , N ) = cl(Qm , N )
[since P̂m ≤ P̂m−1 in N ]. By regularity of N it follows that Qm ≤ P̂m−1 ≤ Qm−1
in N . The arc (Qm , Qm−1 ) of N is not redundant, so it follows that either
P̂m−1 = Qm or P̂m−1 = Qm−1 . But P̂m−1 6= P̂m = Qm , so we see that
P̂m−1 = Qm−1 .
Similarly cl(Qm−2 , N ) = cl(P̂m−2 , Np̂ ) ⊆ cl(P̂m−2 , N ) ⊆ cl(P̂m−1 , N ) =
cl(Qm−1 , N ) [since P̂m−1 ≤ P̂m−2 in N ]. By regularity of N it follows that
Qm−1 ≤ P̂m−2 ≤ Qm−2 in N . The arc (Qm−1 , Qm−2 ) of N is not redundant
since N is regular, so it follows that either P̂m−2 = Qm−1 or P̂m−2 = Qm−2 .
But P̂m−2 6= P̂m−1 = Qm−1 , so we see that P̂m−2 = Qm−2 .
In like manner we see that P̂i = Qi for i = m − 3, m − 4, · · · , 0.
It follows that Ĉ = P̂0 = Q0 = C ′ . Since Y is a child of C ′ in N we know
cl(Y, N ) = D ⊂ cl(D̂, T̂ ) = cl(D̂, Np̂ ) ⊆ cl(D̂, N ) ⊆ cl(P̂0 , N ) = cl(C ′ , N ). It
follows that C ′ ≤ D̂ ≤ Y in N . Since the arc (C ′ , Y ) is nonredundant, either
D̂ = C ′ or D̂ = Y . But D̂ 6= C ′ since D̂ is a child of Ĉ = C ′ . It follows
that D̂ = Y . Hence D = cl(Y, N ) ⊂ cl(D̂, T̂ ) ⊆ cl(D̂, N ) = cl(Y, N ), which is
impossible. This contradiction proves that D = cl(Y, N ) ∈ M axP roperCh(C).
Next we prove (b):
Claim 1b. Each member D of M axP roperCh(C) satisfies that there exists
a child E of C ′ in N such that D = cl(E, N ).
11

Let D be a member of M axP roperCh(C). Thus there exists a tree T̂ in
P roperT r(C) with vertex Ĉ such that C = cl(Ĉ, T̂ ) and Ĉ has child D̂ in T̂ such
that cl(D̂, T̂ ) = D. Let r = P̂m , P̂m−1 , · · · , P̂0 = Ĉ be the directed path from r
to Ĉ in T̂ . By construction, for i = 0, · · · , m, cl(P̂ i, T̂ ) is a vertex of Mj and for
i = 1, · · · , m, each arc (cl(P̂i , T̂ ), cl(P̂i−1 , T̂ )) is an arc in Mj . By Hj , for i such
that 0 ≤ i ≤ m, there exists a vertex Qi of N such that cl(P̂i , T̂ ) = cl(Qi , N ),
and for 1 ≤ i ≤ m, (Qi , Qi−1 ) is an arc of N . In particular, by regularity of N ,
Q0 = C ′ .
As in the proof of Claim 1a, we see that P̂i = Qi for i = m, m − 1, · · · , 0
and Ĉ = P̂0 = Q0 = C ′ . Since D̂ is a child of Ĉ in Np̂ , it follows that Ĉ ≤ D̂
in Np̂ , whence Ĉ ≤ D̂ in N . Since D̂ 6= Ĉ, there exists a child E of Ĉ = C ′ in
N such that E ≤ D̂. Hence D = cl(Ĉ, T̂ ) = cl(Ĉ, Np̂ ) ⊆ cl(E, N ). By Claim
1a, cl(E, N ) ∈ M axP roperCh(C). Hence D is not in M axP roperCh(C) unless
D = cl(E, N ), proving Claim 1b.
This completes the proof of Claim 1.
We now complete the proof of Theorem 3.1.
We saw above that the procedure terminates, say with Mn . By Claim 1,
Hn will be true. In fact, each vertex W of N has been represented in Mn in
the sense that cl(W, N ) ∈ Vn . To see this, note that there is a directed path
P0 = r, P1 , · · · , Pk = W in N since r is the root of N . Since X ′ = r, by
Claim 1a it follows that cl(P1 , N ) is a member of M axP roperCh(X), whence
by construction cl(P1 , N ) ∈ Vn , cl(P1 , N )′ = P1 , and (cl(r, N ), cl(P1 , N )) in
An . Since cl(P1 , N )′ = P1 and P2 is a child of P1 in N , by Claim 1a again it
follows that cl(P2 , N ) ∈ Vn , cl(P2 , N )′ = P2 , and (cl(P1 , N ), cl(P2 , N )) ∈ An .
Repeating the argument we ultimately obtain that cl(Pk , N ) = cl(W, N ) in Vn .
Since every arc in N lies on some directed path in N starting at r hence
occurs as some arc (Pi , Pi+1 ) using the notation above, the same argument
shows that the arc corresponds to the arc (cl(Pi , N ), cl(Pi+1 , N )) ∈ An . Thus
every vertex and arc of N has a corresponding vertex and arc in Mn .
There remains only to show that Mn has no additional vertices or arcs. By
Claim 1b every vertex which is added at any stage has the form cl(E, N ) for
some vertex E of N . Hence Mn has no additional vertices. By claim 1a, every
arc in Mn corresponds to an arc in N .
This completes the proof.

4

An example of the reconstruction

Let N be the network given in Figure 3. The base-set is X = {1, 2, 3, 4, 5, 6}.
The clusters satisfy cl(A) = X, cl(B) = {1, 2, 3, 4, 6}, cl(C) = {5, 6}, cl(D) =
{1, 2, 3, 6}, cl(E) = {2, 3}, cl(F ) = {1, 2, 6}, cl(G) = {1, 2, 3}, and cl(i) = {i}
for 1 ≤ i ≤ 6. An inspection shows that N is regular.
There are three hybrid vertices 1, 2, 6, each with indegree 2. Hence there
are 8 parent maps. Here I will list the displayed trees by telling the parent map
and the nontrivial clusters of each:
12

C✠
✠
5
❄
✠
6

A
❅
❅
❘ B
❅
❅
❅
✠D
❘ 4
❅
❅
❅
✠F
❘ G
❅
❅
❅
❅
❅
❘✠
❅
❘ E
❅
✏
1 ✏✏✏
✏
✏✏
✏
✮
✏
❄
❄
2
3

Figure 3: A regular network N with X = {1, 2, 3, 4, 5, 6} which will be reconstructed from its trees.

T1 : p(1) = G, p(2) = E, p(6) = F . Clusters {2, 3}, {1, 2, 3}, {1, 2, 3, 6},
{1, 2, 3, 4, 6}.
T2 : p(1) = G, p(2) = E, p(6) = C. Clusters {2, 3}, {1, 2, 3}, {1, 2, 3, 4}, {5, 6}.
T3 : p(1) = G, p(2) = F , p(6) = F . Clusters {1, 3}, {2, 6}, {1, 2, 3, 6}, {1, 2, 3, 4, 6}.
T4 : p(1) = G, p(2) = F , p(6) = C. Clusters {1, 3}, {1, 2, 3}, {1, 2, 3, 4}, {5, 6}.
T5 : p(1) = F , p(2) = E, p(6) = F . Clusters {2, 3}, {1, 6}, {1, 2, 3, 6}, {1, 2, 3, 4, 6}.
T6 : p(1) = F , p(2) = E, p(6) = C. Clusters {2, 3}, {1, 2, 3}, {1, 2, 3, 4}, {5, 6}.
T7 : p(1) = F , p(2) = F , p(6) = F . Clusters {1, 2, 6}, {1, 2, 3, 6}, {1, 2, 3, 4, 6}.
T8 : p(1) = F , p(2) = F , p(6) = C. Clusters {1, 2}, {1, 2, 3}, {1, 2, 3, 4}, {5, 6}.
We now perform procedure MaximumProperChild. Let Mk = (Vk , Ak ).
Initially V0 = {X}. The proper children of X are the children of X in any
proper tree. All the trees are proper trees for X. Hence P roperCh(X) =
{{1, 2, 3, 4, 6}, {5}, {1, 2, 3, 4}, {5, 6}}. The maximal proper children are the
maximal members of P roperCh(X). Hence M axP roperCh(X) = {{1, 2, 3, 4, 6},
{5, 6}}. These are adjoined to M0 as children of X. Hence M1 = (V1 , A1 ) has
V1 = {X, {1, 2, 3, 4, 6}, {5, 6}} and has arcs (X, {1, 2, 3, 4, 6}) and (X, {5, 6}).
Let C = {5, 6} in V1 . By 2b, the children will be {5} and {6}. Hence M2 has
V2 = {X, {1, 2, 3, 4, 6}, {5, 6}, {5}, {6}} and the arcs are those of M1 together
with ({5, 6}, {5}) and ({5, 6}, {6}).
Let C = {1, 2, 3, 4, 6}. The proper trees must contain both X and {1, 2, 3, 4, 6}.
Hence P roperT r(C) = {T1 , T3 , T5 , T7 }. The proper children of C are the children of C in one of the proper trees. Hence P roperCh(C) = {{1, 2, 3, 6}, {4}}.
In this case all proper children are maximal. Hence M3 has V3 = V2 ∪{{1, 2, 3, 6},
{4}} and suitable arcs are also added.
Let C = {1, 2, 3, 6}. A proper tree must contain C, some parent of C hence
{1, 2, 3, 4, 6}, and X. Thus P roperT r(C) = {T1 , T3 , T5 , T7 }. The proper chil-

13

dren are the children of C in any of these proper trees, so P roperCh(C) =
{{1, 2, 3}, {6}, {1, 3}, {2, 6}, {1, 6}, {2, 3}, {1, 2, 6}, {3}}. Then M axP roperCh(C)
= {{1, 2, 3}, {1, 2, 6}}. These are adjoined, so V4 = V3 ∪ {{1, 2, 3}, {1, 2, 6}} and
arcs are inserted so that these are the children in M4 of {1, 2, 3, 6}.
Let C = {1, 2, 3}. A proper tree must contain {1, 2, 3}, {1, 2, 3, 6}, {1, 2, 3, 4, 6},
and X. Hence P roperT r(C) = {T1 , T6 }. Then P roperCh(C) = {{1}, {2, 3}} =
M axP roperCh(C). Now V5 = V4 ∪ {{1}, {2, 3}}.
Let C = {1, 2, 6}. A proper tree must contain {1, 2, 6}, {1, 2, 3, 6}, {1, 2, 3, 4, 6},
and X. Hence P roperT r(C) = {T7 } It follows that P roperCh(C) = {{1},
{2}, {6}} = M axP roperCh(C). Now V6 = V5 ∪ {{1}, {2}, {6}}. Note that {6}
was already in V5 , but it is at this stage that we obtain the arc ({1, 2, 6}, {6}).
Let C = {2, 3}. By 2b the children will be {2} and {3}. Hence V7 =
V6 ∪ {{2}, {3}}.
The procedure terminates now with M7 . Note that V7 now consists of exactly
the sets cl(U, N ) where U is a vertex of N . Similarly the arcs of M7 consist
exactly of the arcs (cl(U, N ), cl(W, N )) such that (U, W ) is an arc of N . Thus
M7 is isomorphic with N ; indeed, it is the cover digraph of N .
It is natural to wish that the identification of the children could be simplified,
for example by merely looking at the maximal children of C in any input tree T
rather than insisting on proper trees for C. This alternative approach, however,
fails on this example. If we did not insist on proper trees, then {1} is not a
maximal child of {1, 2, 3} since T8 contains {1, 2, 3} with the child {1, 2}. Our
procedure works since T8 is not a proper tree for {1, 2, 3} because the parent of
{1, 2, 3} in T8 is {1, 2, 3, 4} which had not been identified as a cluster in N .

5

Discussion

The main result in this paper is that, if N = (V, A, r, X) is a regular network,
then the procedure MaximumProperChild will reconstruct N from the collection
T r(N ) of all trees displayed by N . The definition of regularity has two parts:
(1) clN : V → P(X) is one-to-one; and
(2) there is an arc (u, v) ∈ A iff clN (v) ⊂ clN (u) and there is no w ∈ V such
that clN (v) ⊂ clN (w) ⊂ clN (u).
The network N in Figure 1 is not regular because (1) fails, and the method
fails to reconstruct N . Both M and N in Figure 1 have the same displayed
trees. The procedure of course reconstructs M since M is regular.
Figure 4 shows two networks A and B that are not regular. Even though (1)
holds for both, (2) fails. It can be seen that they display exactly the same trees.
Indeed, using Newick notation, they both display (4, (3, (1, 2))), (4, (1, (2, 3))),
and (4, (1, 2, 3)) but not (4, (2, (1, 3))). Hence the conclusion of Cor 4.2 fails for
these networks when just the second condition of regularity fails. Curiously, one
easily checks that there is no regular network N that displays these three trees
and no others.
In the example of section 4, it is easy to see that N would be reconstructed
using procedure MaximumProperChild given the input D = {T1 , T2 , T7 }. Thus,

14

A

5
❅
❅
❅
❘ 4

✠6
❅
❅
❘ 8
❅
7 ✠
❅
❅
❅
❅
❄
✠
❘✠
❅
❅
❘
1
2
3

5
❅
❅
❘ 4
❅

6 ✠
❆
✁❅
✁ ❆❅
❆ ❅
✁
❆ ❅
✁
❆ ❅
✁
❆❯❍8 ❅
7
☛
✁
✟
✟
❅
❍❍❅
✟
✟
❍❅
❅
✟
❍
❄
✙
✟
❥
❍
❘✠
❅
❘
❅
✠
1
2
3
B

Figure 4: A and B are non-regular networks with X = {1, 2, 3, 4} that display
the same trees.

reconstruction may be possible even if D 6= T r(N ). On the other hand, in the
same example if D = {T1 , T2 , T3 }, then N is not reconstructed. It would be
interesting to characterize D ⊂ T r(N ) for which reconstruction of N is possible
using MaximumProperChild with input D.

References
[1] H.-J. Bandelt and A. Dress, 1992. Split decomposition: a new and useful
approach to phylogenetic analysis of distance data. Molecular Phylogenetics
and Evolution 1, 242-252.
[2] M. Baroni, C. Semple, and M. Steel, 2004. A framework for representing
reticulate evolution. Annals of Combinatorics 8, 391-408.
[3] M. Baroni and M.Steel, 2006. Accumulation phylogenies. Annals of Combinatorics 10, 19-30.
[4] M. Bordewich and C. Semple, 2007. Computing the minimum number of
hybridization events for a consistent evolutionary history. Discrete Applied
Mathematics 155, 914-928.
[5] G. Cardona, F. Rossalló, and G. Valiente, 2007. Comparison of tree-child
phylogenetic networks. To appear in IEEE/ACM Transactions on Computational Biology and Bioinformatics
[6] G. Cardona, L. Mercè, F. Rossalló, and G. Valiente, 2008. A distance metric for a class of tree-sibling phylogenetic networks, 2008. Bioinformatics
24(13), 1481-1488.
[7] J. Degnan and N. Rosenberg, 2006. Discordance of species trees with their
most likely gene trees. PLoS Genetics 2(5)e68, 762-768.
15

[8] D. Gusfield, S. Eddhu, and C. Langley, 2004. Optimal, efficient reconstruction of phylogenetic networks with constrained recombination. Journal of
Bioinformatics and Computational Biology 2, 173-213.
[9] B. Holland, K. Huber, V. Moulton, and P. Lockhart, 2004. Using consensus
networks to visualize contradictory evidence for species phylogeny. Molecular Biology and Evolution 21(7), 1459-1461.
[10] D. Huson, T. Klöpper, P.Lockhart, and M. Steel, 2005. Reconstruction of
reticulate networks from gene trees. In S. Miyano et al. (eds.) RECOMB
2005, LNBI 3500, 233-249.
[11] D. Huson and T. Klöpper, 2007. Beyond galled trees –decomposition and
computation of galled networks. In T. Speed and H. Huang (eds.): RECOMB 2007, LNBI 4453, 211-225.
[12] B. Moret, L. Nakhleh, T. Warnow, C. R. Linder, A. Tholse, A. Padolina,
J. Sun, and R. Timme, 2004. Phylogenetic networks: modeling, reconstructibility, and accuracy. IEEE Transactions on Computational Biology
and Bioinformatics 1, 13-23.
[13] L. Nakhleh, T. Warnow, C.R. Linder, and K.S. John, 2005. Reconstructing
reticulate evolution in species: Theory and practice. J. Comput. Biolog 12,
796-811.
[14] A. Rokas, B. Williams, N. King, and S. Carroll, 2003. Genome-scale approaches to resolving incongruence in molecular phylogenies. Nature 425,
798-804.
[15] N. A. Rosenberg, 2002. The probability of topological concordance of gene
trees and species trees. Theoretical Population Biology 61, 225-247.
[16] N. A. Rosenberg, 2007. Counting coalescent histories. Journal of Computational Biology 14(3), 360-377.
[17] K. Strimmer and V. Moulton, 2000. Likelihood analysis of phylogenetic
networks using directed graph models. Molecular Biology and Evolution
17, 875-881.
[18] L. Wang, K. Zhang, and L. Zhang, 2001. Perfect phylogenetic networks
with recombination. Journal of Computational Biology 8, 69-78.
[19] S.J. Willson, 2008. Reconstruction of certain phylogenetic networks from
the genomes at their leaves. Journal of Theoretical Biology 252, 338-349.

16

