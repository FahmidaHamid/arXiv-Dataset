arXiv:1503.02974v1 [q-bio.GN] 10 Mar 2015

Modelling Computational Resources for Next
Generation Sequencing Bioinformatics Analysis of
16S rRNA Samples
Matthew J. Wade∗, Thomas P. Curtis, and Russell J. Davenport
School of Civil Engineering and Geosciences, Newcastle University,
Newcastle-upon-Tyne, NE1 7RU, UK
March 11, 2015

Abstract
In the rapidly evolving domain of next generation sequencing and
bioinformatics analysis, data generation is one aspect that is increasing at
a concomitant rate. The burden associated with processing large amounts
of sequencing data has emphasised the need to allocate sufficient computing resources to complete analyses in the shortest possible time with
manageable and predictable costs. A novel method for predicting time to
completion for a popular bioinformatics software (QIIME), was developed
using key variables characteristic of the input data assumed to impact processing time. Multiple Linear Regression models were developed to determine run time for two denoising algorithms and a general bioinformatics
pipeline. The models were able to accurately predict clock time for denoising sequences from a naturally assembled community dataset, but not an
artificial community. Speedup and efficiency tests for AmpliconNoise also
highlighted that caution was needed when allocating resources for parallel
processing of data. Accurate modelling of computational processing time
using easily measurable predictors can assist NGS analysts in determining
resource requirements for bioinformatics software and pipelines. Whilst
demonstrated on a specific group of scripts, the methodology can be extended to encompass other packages running on multiple architectures,
either in parallel or sequentially.

Keywords— Computational performance, bioinformatics pipelines, Multiple
Linear Regression modelling
∗ Electronic

address: matthew.wade@ncl.ac.uk; Corresponding author

1

1

Introduction

Next-Generation Sequencing Analysis
The rapid increase in the utilisation of Next Generation Sequencing (NGS) technologies amongst disparate fields of research has resulted in a new set of challenges for scientific researchers. Whilst technology selection, sequencing costs
and efficacy of sample preparation are still considerable concerns, pragmatic
approaches in decision-making and implementation will result in satisfactory
sequence generation. However, potentially vast quantity of data generated by
sequencing efforts suggests that the true bottleneck is the computational analysis of the sequence data [17, 31]. Indeed, without considered planning of the
bioinformatics analysis, data processing time and costs can far exceed those
of the actual sequencing itself [3], diminishing the benefits attributed to highthroughput technologies.
Whilst the utilisation of computing resources and data analysis tools is generally accessible to the scientific and research communities, the ability to harness
their full potential is often limited to specialists. Faced with the increasing ubiquity of bioinformatics tools for post-sequencing analysis and the realisation that
decentralised research is becoming more prevalent, bioinformaticians are tasked
with creating applications that are reliable, scalable, and user-friendly.
The prevalence of bioinformatics workflows and pipelines such as Galaxy [10],
QIIME core analysis [5] and Taverna [14], and the increasing collaborative efforts
through shared infrastructures [28] suggests greater uptake by non-specialists
will be forthcoming. As NGS technology develops, the challenges faced by both
bioinformaticians and users relate specifically to the competency of the software
tools and the performance of the hardware to handle increasingly larger and
more complex datasets.
The lack of appropriate hardware infrastructure is the greatest contributing
factor to the bioinformatics bottleneck and the rise in virtual environments, parallelised code and super-computing facilities is testament to an understanding
of the need for continual development and innovation in NGS data handling
and management [30]. However, these structural and programmatic facilitators
are not without their drawbacks. For example, cloud computing facilities such
as Amazon Web Services’ Elastic Compute Cloud [1] offer flexible and scalable
environments for performing a wide range of bioinformatics, but issues around
data security and file transfer rates coupled with per hour usage costs make
resource planning an integral requirement for any data analysis project.

1.1

Understanding capacity and performance

The capacity for processing and analysing NGS data accurately is dependent
on identifying the most suitable software and hardware for the task. Incorrect selection or mismatch between data requirements and architecture will inevitably lead to suboptimal performance and, potentially, poor or erroneous
results. With a wide range of bioinformatics tools being utilised by both spe-

2

cialists and non-specialists, there is a need for greater transparency in their
deployment to facilitate effective and efficient analysis. As time and cost are
often constraining factors in research and corporate environments, the ability
to assign resources with a priori knowledge of the performance and run time is
of great benefit. For example, Cunningham was developed to provide accurate
runtime estimates for BLAST analysis of large shotgun sequence datasets [34] .
A recent study using the 16S gene for estimating bacterial diversity has
shown the quantity and size of sequence clusters affects accuracy in non-parametric
diversity calculations, whilst also determining which methods to employ [4].
Parallelisation of bioinformatics algorithms aimed at dramatically decreasing
their processing time by exploiting multiple core processors [8] or GPU capabilities [18] has alleviated some of the analysis bottleneck. Code optimisation can
also make significant performance gains in highly parallel applications [32], but
often requires expertise in coding that is not always accessible or practical for
the end-user.
Parallel speedup and efficiency are key performance metrics that can be used
to assess the most effective use of multiple CPU cores or nodes in a Cluster, Grid
or Cloud environment. Whilst it may be intuitive that splitting large computational jobs amongst a greater number of processors should lead to increasing
reductions in processing time, the presence of code that must be run serially
(ser ) in most algorithms means that only a fraction of the work benefits from
parallel (par ) speedup. Amdahl’s Law [2] describes the speedup of a process
across multiple cores (P ) given an amount of work (N ) as:
S(N, P ) =

t(N, P = 1)
t(N, P )

(1)

In ideal parallel processes, speedup is therefore equal to 1/P , but with a
fraction of code being serial, this equation becomes:
S(N, P ) =

t(N )ser + t(N )par
t(N )ser +

t(N )par
P

(2)

Knowing the speedup of parallelisation, then the efficiency may also be calculated simply by:
S(N, P )
(3)
P
For algorithms that are parallelisable, it is useful to perform these calculations to get an understanding of the scalability of the processes on any given
architecture. This will help users to more appropriately assign resources and
avoid problems with latency or parallel overheads.
E=

1.2

Computational transparency for targeted analysis

Recent advances in sequencing technology have brought about unprecedented
resolution in identification and classification of bacterial species. Sequencing of

3

the highly conserved 16S rRNA gene is popular as it allows for comparative
studies of microbial communities, their diversity and structure. The ubiquity
of this approach in amplicon-based metagenomics coupled with the dwindling
cost of high-throughput sequencing has put emphasis on development of tools
and hardware infrastructure that can handle increasingly data rich sequence
analysis.
A discretised pipeline was developed to model the relationship between sequence data size and complexity, and computational resource. An overview of
the pipeline components is shown in Fig. A1 (Appendix A), comprising several
typical processing and analysis protocols available in the QIIME software. The
performance was measured using the time taken to complete each process step
in real and CPU metrics. The clock or real time is necessary to determine actual
resource cost, but can be skewed on systems where other extraneous processes
are running, adding load to the shared resource. CPU time, characterised as
the sum of user and system time, is reflective of the actual work done by the
process being monitored.

2
2.1

Methods
System architecture

The system used for evaluation was a 64-bit 2 x 6-Core (Intel Xeon 2.66 GHz
CPU) Apple MacPro with 32GB RAM running OS X 10.8.2.
For the performance testing 16 logical cores (8 physical cores with hyperthreading) were used for the parallelisable components of the pipeline (e.g. Denoising) and single CPU otherwise. All analysis results are specific to this
architecture and configuration. All cited instances of QIIME relate to its OSX
compilation, MacQIIME Version 1.6.0.

2.2
2.2.1

Training and validation datasets
Training data

Three datasets containing 16S microbial rRNA gene fragments were used to
develop the performance models. The first training dataset (MFC ) was taken
from an acetate fed microbial fuel cell reactor inoculated with arctic soil sourced
from Arctic soil (Ny-Ålesund, Spitsbergen, Svalbard), and operated at 26.5°C
[12]. The second dataset was generated from a sample taken from a small
eutrophic lake in the English Lake District (Priest Pot) in 2008 [26]. The
third dataset (Arctic) were sequences derived from DNA extracted from Arctic
mineral soil samples collected from the Svalbard region [Unpublished].
The Priest Pot sequences were generated using standard 454 GS-FLX chemistry and targeted the V5 hyper-variable region, whilst the MFC and Arctic
samples were sequenced with the more recent GS-FLX Titanium chemistry,
which gives longer read lengths and targeted the V4-V5 regions, as at the time

4

of sequencing (2011), they provided the highest classification accuracy with lowest amplification bias.
In the case of the MFC and Arctic data, samples were originally pooled
using barcodes to provide a multiplexed dataset. However, only one sample was
selected and processed through the pipeline to avoid the effects of redundancy
when processing multiple samples as a single batch.
2.2.2

Validation data

The first validation dataset (Mix ) were sequences taken from a laboratory scale
batch reactor sample, which had been used to study anaerobic digestion of domestic wastewater at 15°C. The sample was sequenced in January 2013 using
the same method employed for the Arctic data. The second validation dataset
(Artificial ) consisted of an artificial community from 90 clones that was pyrosequenced over the V5 region of the 16S rRNA gene with a 454 GS-FLX
sequencer [26].
Table 1 summarises each of the datasets used in this analysis and includes
the number of reads, average read length, number of putative OTUs and α
diversity (equitability) of the raw, unfiltered sequences. Because of inherent
sequencing errors, the OTU and equitability values are likely to be over- and
underestimated, respectively. As can be seen, the samples sequenced with the
older 454 GS-FLX chemistry are much shorter than those sequenced with the
Titanium chemistry. After trimming to remove primer and barcode, the mean
read lengths are approximately 200 bp for GS-FLX and 400 bp for Titanium.
Table 1: Test and Validation Datasets: Number of Sequences (Seqs); Average Read Length (bp); Number of OTUs at 97% Cutoff (OTU); Equitability
Estimate [15] of Total Samples (α)
Source
MFC
Priest Pot
Arctic
Mixed sediment
Artificial

2.3

Dataset
Test
Test
Test
Validation
Validation

Seqs
72003
28361
21576
19718
46341

bp
411 ±
244 ±
426 ±
423 ±
260 ±

45
52
53
49
38

OTU
828
1146
2267
2390
177

α
0.481
0.613
0.807
0.801
0.536

Analysis steps

An initial subsampling of the test datasets was performed using the QIIME
subsample fasta.py script to randomly split the raw Fasta file into subsamples
of 5% to 95% fractions at intervals of 5%. Six repeats were generated at each
interval for the GS-FLX sequenced Artificial dataset and two repeats for the
Titanium sequenced Arctic dataset (due to the greatly increased computational

5

time required to denoise these sequences). Thus, for the denoising steps, 76
samples were used for training and 133 samples for validation.
A simple bash script was written to simplify and automate the performance
testing by looping through the subsamples, processing according to each step
in the performance pipeline (Fig. A1) and passing the Real and CPU time for
execution to a separate output file.
The subsampled Fasta files are pre-processed using the QIIME split libraries.py
script, which applies some basic quality filtering to the sequences for read length
trimming, ambiguous base checking and primer and barcode removal.
The subsamples are then ready for denoising to correct for errors generated
in the PCR and sequencing steps. QIIME Denoiser [29] is a heuristic algorithm
that uses a greedy alignment scheme before clustering flowgrams in descending
order of abundance. Erroneous reads are filtered from the cluster to produce the
final denoised sequences. Denoiser can use pre-filtered Fasta files and matches
the IDs of the remaining reads with those present in the text translation of the
raw SFF file, to avoid denoising of poor quality sequences. Chimera checking is
an optional but often important step that is performed independently from denoising using the ChimeraSlayer [11] tool via QIIME’s identify chimeric seqs.py
script.
For denoising using AmpliconNoise, the Standard Flowgram File (SFF) associated with the data was split into 19 subsamples with sizes corresponding to
the set used for QIIME denoising using SFF Workbench [13] via a Wine [35]
translation of the Windows API. The individual SFF files were then converted
to text translations using the QIIME process sff.py script. There is no need for
demultiplexing of the data as only a single sample is used in the pipeline test.
The AmpliconNoise software [26] uses Bayesian theory to generate an approximate likelihood from empirical error distribution data to infer true read identity
given sequencing error (PyroNoise) and PCR error (SeqNoise). An additional
chimera checking step using Perseus [27] is performed after error removal. The
software was run using the QIIME wrapper script ampliconnoise.py rather than
via the stand-alone package to maintain a consolidated workflow.
The denoised reads from QIIME denoiser were used for downstream analysis
using the following steps:
• De Novo OTU picking: Clustering of sequences with 97% similarity
threshold using the uclust method [7], before picking representative Operational Taxonomic Units (OTUs) from each cluster by the sequence first
assigned to a cluster.
• Assign Taxonomy: Assignment of taxonomic identities to the OTUs
using the curated Greengenes 16S rRNA gene database [21] with a naı̈ve
Bayesian classifier, RDP [33].
• Alignment: Alignment of the sequences is necessary for comparative
analysis, such as β diversity, in which phylogenetic distances are used to
understand differences in community composition from distinct samples.

6

Alignment was performed using the PyNAST method and pairwise clustering with uclust [7] against a Greengenes database template. Gap only
columns and highly variable regions within the alignment files are removed
using a filtering step that makes use of Greengenes compatible Lanemask
file for excluding these positions. Phylogenic relatedness of organisms
within a sample may also be of interest and the creation of a phylogenetic
tree using the FastTree 2.1.3 [22] method is performed after alignment.
• Diversity analysis: Diversity metrics are key outputs from the QIIME
pipeline and are used to gain an quantitative understanding of the distribution and relatedness of organisms within a sample (α diversity) or
between different samples (β diversity). α diversity uses the abundance
data stored in the OTU table generated from the OTU picking and taxonomy assignment steps to calculate a range of metrics provided by the
user, such as Chao1, Shannon and Phylogenetic Distance. Rarefaction
plots are generated for each metric based on random subsampling (using
a pseudo random number generator) of the OTU table between a given
range of sequences per sample and at a given step size. β diversity uses
both the information stored in the OTU table and a phylogenetic tree,
if the phylogenetic metrics are calculated using Unifrac. In this analysis,
both quantitative (weighted) and qualitative (unweighted) Unifrac metrics [19] were calculated and Principal Coordinate Analysis plots generated
to display the results.
Details of the parameters used for each analysis step are provided in Table A1
(Appendix A).

2.4

Performance measures

Both the wall clock and CPU (Usr + Sys) were recorded using the GNU time
command, which allows for formatting of the output in Mac OSX, and stored
as text files. Whilst the wall clock time indicates the amount of real time
between execution and completion of a process, CPU time is more indicative of
the computing effort required to run the process. However, when considering
running large datasets through a bioinformatics pipeline, time to completion is
the measure by which costs can be assessed.
File input size was determined based on the process step being analysed as
shown in Table A2 (Appendix A). The number of reads and mean read length per
Fasta file were determined using the QIIME count seqs.py script. Equitability
was calculated using the QIIME α diversity metric script on the raw input fasta
files supplied to the denoising algorithms.
The time and predictor (diversity, number of reads and read length) data
was imported into Matlab [20] and a stepwise Multiple Linear Regression (MLR)
was applied to fit a model between the explanatory variables and clock time.
The MLR model takes the following generalised form:
yi = β0 + β1 xi,1 + β2 xi,2 + ... + βp xi,p + i
7

(4)

where yi are the predictands, xi,p the predictors, βp the regression coefficients,
and i is the error term. The regression coefficients are the solution to the least
squares estimation:
β = [X T X]−1 X T yi

(5)

where X is the matrix of regressor variables. The Matlab function LinearModel,
from the Statistics Toolbox (v8.2), was used to perform the stepwise regression
using the polynomial form described in eq. 4. The starting model included the
intercept, linear terms, interactions and power terms with interactions up to
a factor of 4 for each explanatory variable. The algorithm uses forward and
backward regression with the Sum of Squared Error (SSE) to add and remove
terms from the model based on the p-values of the F-statistic with and without
a potential term. The thresholds for adding and removing terms were p < 0.05
and p > 0.1, respectively.
A conventional method for assessing goodness-of-fit for linear regression
models is to calculate the R2 value or coefficient of determination. As the complexity of the polynomial increases (by adding more variables), the R2 value
will increase, which may result in a skewed confidence in the reliability of the
model. The adjusted-R2 value is used to address this issue:
P
(yˆi −ȳ)2
P
( (y −ȳ)2 )(n − 1)
i
2
(6)
Radj
=1−
n−p−1
where yi , ȳ and yˆi are the observed data, mean of the observed data and modelled predictands, respectively, n is the number of observations and p the number
of regressors.
Parallel speedup and efficiency were calculated according to Amdahl’s Law
for AmpliconNoise based denoising of the MFC sample, as this step is observed
to be the most computationally intensive part of the pipeline and is compiled
to run in parallel. Denoising was performed using 1, 2, 4, 8, 16, 32, 64 and 128
physical cores, with 48GB RAM per node (six cores per node) on the DIAG
resource [6] for two sub-samples of the total sequences (20000 and 40000 reads).

3
3.1

Results and discussion
Model development

Performance modelling was initiated on the two test datasets using the standard QIIME pipeline tools for processing and analysis of 16S rRNA sequencing
data. The wall clock (Real) and CPU time were recorded for each pipeline step
and a model fit between these variables and input read number was made. For
the denoising algorithms (QIIME denoiser and AmpliconNoise) a Multiple Linear Regression (MLR) model was deemed necessary as visualisation of the read
number versus clock time highlighted that more than one explanatory variable
was influencing the denoising time. Community diversity within a sample, or
8

more specifically taxonomic rank-abundance, is known to influence computational effort of denoising [29].
The equitability, or evenness, defines the homogeneity of species within a
community, with higher values of the index indicating a highly even or homogeneous distribution of species. This diversity metric was used as a second
explanatory variable in the MLR model as a candidate for determining clustering speed during denoising. Despite diversity calculation being a component of
the QIIME pipeline, the parameter values used for the model were generated by
calculating equitability from the raw input fasta files, prior to quality checking
and noise removal. Although the value is not a true measure of diversity due
to the presence of errors, it is assumed the error profile across all samples is
equivalent and this will not affect the model.

3.2
3.2.1

Modelling sequence denoising strategies
Training

Denoising of high-throughput sequencing data with the most commonly used algorithms (QIIME denoiser and AmpliconNoise) is clearly the major performance
bottleneck in the analysis pipeline, but also one of the most critical in terms of
determination of more accurate OTU numbers and subsequent classification.
A MLR model was developed with two explanatory variables (number of
reads (λ) and sample equitability (α)) as predictors and wall clock time (y) as
the response variable.
By simply observing the relationship between the explanatory and response
variables, it is evident that a non-linear implementation of the MLR model is
necessary. The introduction of power terms in the model is intended to reflect
the curvlinear nature of the underlying dependencies.
Stepwise MLR models were developed using the three training datasets for
the QIIME denoiser (Eq. 7) and AmpliconNoise algorithms (Eq. 8). The models take the form given by equation 4 with non-linear power terms and crossproducts between the two predictor variables.
yqd = β1 α + β2 αλ + β3 λ2 + β4 α2 λ + β5 αλ2 + β6 λ3 + β7 α2 λ2 + β8 αλ3

(7)

The regression coefficients (β) are shown in Table 2. The results from the
QIIME denoiser model suggest a conformity between the two explanatory variables selected and the resulting predictand. Fig. 1 shows excellent prediction
(Adjusted R2 > 0.9) for all training data, which is confirmed by performing
an ANOVA on the full model (F-statistic = 7.38×103 , p-value = 2.54×10−95 )
indicating that the non-linear model is highly significant. All plots are shown
in relation to equitability for ease of visualisation, however, an example 3D
plot (embedded in the uppermost plot in Fig. 1) for the MFC data shows the
excellent fit against both explanatory variables.
For AmpliconNoise, an initial two parameter training model produced good
fits for two datasets (Arctic and MFC), but could not fit the Priest Pot data.
It was surmised that read length could be an additional factor in determining
9

Figure 1: QIIME denoiser model performance for the three training datasets;
fit plotted along the equitability axis. Two parameter fit is shown in the 3D
embedded figure
processing time during the sequencing error removal (Seqnoise) step, given the
importance of sequence size in influencing error rate distribution [9]. Including
mean read length per sample (ρ) as a third parameter in the model decreased
the Root Mean Square Error of Calibration (RMSEC) from 5750 to 129 and the
improvement can also be seen in Fig. 2. Although prediction is not as convincing
as with the QIIME denoiser data, the model, shown in equation 8, is still highly
significant (F-statistic = 1.60×103 , p-value = 2.60×10−51 ).
yan = β1 ρ + β2 λ + β3 αλ + β4 λ2 + β5 αρ + β6 ρλ + β7 ρ2
+ β8 αλ2 + β9 λ3 + β10 αλ3

3.2.2

(8)

Validation

Validation of regression based models is critical to ascertain their ability to be
used with independent data. In complex, highly parameterised models, there is
a risk that overfitting of the data may occur, in which the model tends to fit to
the training data, but lacks the predictive capacity when fitting to validation

10

Figure 2: AmpliconNoise model performance for the three training datasets; fit
plotted along the equitability axis
or real-world datasets. The models developed for both denoising algorithms
were tested with the independent validation datasets to assess their suitability
for prediction of processing time. For both denoising algorithms the models
fit the Mixed sediment dataset well, with adjusted R2 values of 0.97 and 0.72
for QIIME denoiser and AmpliconNoise, respectively. However, the models do
not predict the Artificial data (See Fig. 3), which suggests that there is some
underlying property of the artificially generated sequence communities that is
not captured during training. The dataset was constructed to represent a community with log-normal distribution analogous to true community distributions
found in the environment [26], and it is possible that this artificial construct
has presented some feature in the data that has a significant impact on denoising performance. As discussed, the Priest Pot data was acquired from the
same sequencing technology and the inclusion of the mean read length in the
AmpliconNoise model had significant impact on training performance.
A main effects plot, shown in Fig. A2 (Appendix A), was generated to look
at the contributions from each independent model variable on the clock time.
For both the two and three variable models, the number of reads was the largest
contributing factor to the output variability. It can also be seen that, although
mean read length has a small impact on the AmpliconNoise model, justifying

11

Figure 3: QIIME denoiser model prediction for the two validation datasets; fit
plotted along the equitability axis
its inclusion, it is not the critical factor in explaining the poor performance with
the Artificial dataset.

3.3

General pipeline model

The pipeline algorithms deployed sequentially without parallelism (i.e. on a single CPU core) generally contribute insignificant burden to the overall processing
time compared to the denoising step. However, based on system memory availability and CPU processor speed, scripts related to sequence alignment, OTU
picking, taxonomy assignment and diversity calculation, may become cumbersome, especially for large sequencing runs. QIIME includes several parallel
commands to handle such conditions, but in this study the test environment
and dataset sizes were such that single CPU processing was sufficient. A MLR
model was developed using the total wall clock time measured for all analysis
steps independent of denoising, as shown in Table A2. Although non-continuous,
as quality filtering occurs prior to denoising, whereas all other steps are downstream, the intention is to indicate a relationship between processing time and
predictor variables that will aid resource allocation. Additionally, it should be
noted that the predictor variables will undergo changes during the pipeline as
reads are removed, trimmed and truncated, particularly at the upstream end of
12

the pipeline. However, monitoring changes in read number and diversity is impractical, especially with automated pipelines and given the underlying aim of
assessing resource requirements a priori. It is assumed that the underlying correlation between predictors and response hold true for the agglomerated model
as the relative changes in predictor variables are expected to be uniform across
all training samples for any given pipeline.
Observation of individual pipeline step results indicated generally linear relationships between number of reads and clock time but, as with the denoising
algorithms, additional confounding factors appeared to have a role in determining response across datasets. An initial model was developed using number of
reads and equitability, which gave satisfactory training results but produced
poor fitting for the Artificial validation data (Adjusted R2 of 0.333). A three
factor model that included mean read length was investigated and greatly improved prediction of the articitial validation dataset (Adjusted R2 of 0.704),
but with a slight decrease in the model fit for the Mixed dataset (Adjusted
R2 reduced from 0.914 to 0.841). The final pipeline MLR model (F-statistic
= 1.27×103 , p-value = 5.43×10−53 ) is shown in equation 9 and the regression
coefficients in Table 2, with the fitted training and prediction curves presented
in Figs. 4 and 5, respectively.
ypipe = β0 + β1 λ + β2 α + β3 ρ + β4 αλ + β5 λ2 + β6 αρ + β7 λρ + β8 ρ2
+ β9 αλ2

3.4

(9)

Speedup and Efficiency

Due to the unfeasibly long processing time for AmpliconNoise and, to a lesser
extent, QIIME denoiser, there may be a tendency to invest heavily in highperformance computing solutions to dramatically reduce the run time. Whilst
there is some guidance on memory requirements for running the algorithms
(1GB for FLX sequences with QIIME denoiser [23], > 8GB for large datasets
when running AmpliconNoise [24]), there may be a tendency for employing as
large a resource as economically and logistically feasible. Aside from the costs
involved, acquisition of hardware for long-term use may result in redundancy
unless demand is significant. Deployment on decentralised systems may also
result in conflict if non-essential capacity is being utilised for the denoising
task.
The results of the speedup and efficiency tests performed with AmpliconNoise on the decentralised DIAG [6] resource are shown in Fig. 6. The speedup
plot shows that actual performance improvement is far from ideal when utilising more processors, reaching a threshold of approximately 7.5 times speedup
with 128 cores, which corresponds to 5% efficiency shown in the second plot.
AmpliconNoise is clearly not a massively parallel algorithm, with many serial
components contributing to the dramatic reduction in efficiency with greater
parallel resources.

13

Figure 4: General pipeline model performance for the three training datasets;
fit plotted along the read number axis
Table 2: Regression Coefficients for the MLR Models of the QIIME Denoiser
and AmpliconNoise Algorithms, and General QIIME Pipeline Steps
Regress. coeff.
β0
β1
β2
β3
β4
β5
β6
β7
β8
β9
β10

QIIME
0
1.718
-5.360
1.1×10−4
4.096
-4.6×10−4
6.2×10−10
4.7×10−4
-1.4×10−9
...
...

Ampliconnoise
0
-47.687
1.709
-7.098
2.2×10−4
127.790
0.017
-0.184
-5.2×10−4
-1.6×10−8
3.0×10−8

Pipeline
2820.200
-0.012
556.420
-19.001
0.045
2.8×10−7
-1.640
-2.1×10−5
0.032
-5.7×10−7
...

Based on the analysis and considering the tradeoff between time to completion and resource utilisation/expenditure, between 8 and 16 (shown as a vertical
bar in Fig. 6) cores appear reasonable for this architecture. Using more than
16 cores does not deliver significant increases in speedup, whilst efficiency drops
below 30%.

14

Figure 5: General pipeline model prediction for the two validation datasets; fit
plotted along the read number axis

4

Conclusion

The QIIME software package is widely employed for microbial community analysis using data derived from a range of NGS technologies. The protocols defined
by [16] offer a standard methodology for processing sequencing reads and transforming that data into interpretable information such a sample diversity and
phylogenetic distances. The benefits of using QIIME for downstream analysis of
NGS data is its ability to pipeline a range of bioinformatics steps in a consistent
and reproducible manner, several parallelised scripts for data intensive processing and its portability across a range of high-throughput and high-performance
environments such as Amazon Cloud, Virtual Box/CloVR and Grid services
such as DIAG.
When considering what resources to utilise for post-sequencing analysis, it
is important to have an understanding of computational requirements for the
tools employed. This is vital when considering deploying algorithms on resources
that provide a service at a cost related to time utilised. However, it may also
be important for users requiring rapid turnaround from sequencing to information, those wishing to optimise a pipeline or invest in additional computational
resources, and in cases where the resource is utilised by multiple analysts.
The work presented demonstrates that there exists a significant relationship
between characteristics of the input sequencing data and the computational time
required to process that data. Although the models developed are characteristic
15

Figure 6: Speedup and Efficiency metrics for subsampled MFC data (20000 and
40000 reads) across multiple cores on the DIAG resource using AmpliconNoise
of the system that they were calibrated against, the MLR modelling technique
can be applied to generate models for any architecture.
Two and three variable models developed for sequence denoising algorithms
were successful in predicting time for completion, but suffered with the Artificial
data. This was potentially due to the nature of the dataset construction, which
was not captured in the model development, which consisted entirely of samples from naturally distributed communities. However, a three variable general
pipeline model predicted total time for completion of the standard QIIME analyses with 6% and 7% error for the Mixed and Artificial datasets, respectively.
There is often a temptation when working with computationally intensive
algorithms to allocate the maximum amount of resource to the problem without
considering if this will be optimal. Parallel speedup and efficiency analysis for
the AmpliconNoise algorithm revealed that denoising with increasing number
of CPUs is far from ideal. The efficiency of the computation decreases rapidly
beyond a single core processor, whilst speedup is not significantly increased
beyond 32 cores and the analysis suggests the use of between 8 and 16 processors
is sufficient under the test architecture.
Accurate modelling of the relationship between input sequence data and time

16

to completion has shown to be a viable method for supporting data analysts in
decision-making related to resource allocation. Although restricted to a single
architecture and set of tasks, the methodology can and should be applied in
a broader context to understand if the approach is transferable across a range
of applications (e.g. read mapping, genome assembly). A standardised model
may be idealistic, but the modelling effort is minimal when contrasted with the
expected data throughput that is beginning to emerge in sequencing today. As
sequencing technology is evolving at a remarkable rate, it will be useful to look
at assessing the methodology presented here against more diverse data sets, in
terms of size and source environment. This should be coupled with attempts
to identify how generic the models are across different system architectures and
platforms.
It is suggested that by developing techniques and tools for modelling computational requirements for bioinformatics analysis, coupled with methods for
estimating sequencing effort required to generate the necessary depth of information (see [25]), then analysts can be armed with the capabilities to comprehensively plan their research efforts, assess resource requirements and funding
needs.

List of abbreviations
MFC

Microbial Fuel Cell

MLR

Multiple Linear Regression

OTU

Operational Taxonomic Unit

PCR

Polymerase Chain Reaction

RMSEC Root Mean Square Error of Calibration

References
[1] Amazon Web Services. Amazon elastic compute cloud (amazon ec2), March
2013.
[2] Gene Amdahl. Validity of the single processor approach to achieving largescale computing capabilities. In AFIPS Conference Proceedings, volume 30,
pages 483–485, 1967.
[3] Samuel V Angiuoli, James R White, Malcolm Matalka, Owen White, and
W Florian Fricke. Resources and costs for microbial sequence analysis evaluated using virtual machines and cloud computing. PLoS One, 6(10):e26624,
2011.
[4] Jorge Barriuso, Jose R Valverde, and Rafael P Mellado. Estimation of bacterial diversity using next generation sequencing of 16s rdna: a comparison
of different workflows. BMC Bioinfomatics, 12:473, 2011.
17

[5] J G Caporaso, J Kuczynski, J Stormbaugh, K Bittinger, F D Bushman, E K
Costello, and et al. Qiime allows analysis of high-throughput community
sequencing data. Nat. Methods, 7:335–336, 2010.
[6] DIAG. Data intensive academic grid, June 2013.
[7] R C Edgar. Search and clustering orders of magnitude faster than blast.
Bioinformatics, 26(19):2460–2461, 2010.
[8] S Gálvez, D Dı́az, P Hernández, F J Esteban, J A Caballero, and G Dorado.
Next-generation bioinformatics: using many-core processor architecture to
develop a web service for sequence alignment. Bioinformatics, 26(5):683–
686, 2010.
[9] A Gilles, E Meglécz, N Pech, S Ferreira, T Malausa, and J F Martin.
Accuracy and quality assessment of 454 gs-flx titanium pyrosequencing.
BMC Genomics, 12:245–255, 2011.
[10] J Goecks, A Nekrutenko, J Taylor, and The Galaxy Team. Galaxy: a comprehensive approach for supporting accessible, reproducible, and transparent computational research in the life sciences. Genome Biol., 11(8):R86,
2010.
[11] B J Haas, D Gevers, A M Earl, M Feldgarden, D V Ward, and G Giannoukos. Chimeric 16s rrna sequence formation and detection in sanger and
454-pyrosequenced pcr amplicons. Genome Res., 21:494–504, 2011.
[12] E S Heidrich. Evaluation of microbial electrolysis cells in the treatment of
domestic wastewater. PhD thesis, Newcastle University, May 2012.
[13] Heracle BioSoft S.R.L. Sff workbench, March 2012.
[14] D Hull, K Wolstencroft, R Stevens, C Goble, M Pocock, P Li, and T Oinn.
Taverna: a tool for building and running workflows of services. Nucleic
Acids Research, 34:729–732, 2006. Web Server Issue.
[15] CJ Krebs. Ecological Methodology. Harper & Row, New York, 1989.
[16] J Kuczynski, J Stombaugh, WA Walters, A González, JG Caporaso, and
R Knight. Using qiime to analyze 16s rrna gene sequences from microbial
communities. Current protocols in bioinformatics / editoral board, Andreas
D. Baxevanis ... [et al.], Chapter 10:Unit 10.7., 2011.
[17] Feng Lin, Heiko Schröder, and Bertil Schmidt. Solving the bottleneck
problem in bioinformatics computing: An architectural perspective. The
Journal of VLSI Signal Processing Systems for Signal, Image, and Video
Technology, 48(3):185–188, 2007.
[18] Y Liu, B Schmidt, and D Maskell. Cushaw: a cuda compatible short
read aligner to large genomes based on the burrows-wheeler transform.
Bioinformatics, 2012.
18

[19] C Lozupone and R Knight. Unifrac: a new phylogenetic method for comparing microbial communities. Appl. Environ. Mircobiol., 71(12):8228–
8235, 2005.
[20] MATLAB. version 8.1.0.604 (R2013a). The MathWorks Inc., Natick,
Massachusetts, 2013.
[21] D McDonald, M N Price, J Goodrich, E P Nawrocki, T Z DeSantis,
A Probst, G L Andersen, R Knight, and P Hugenholtz. An improved
greengenes taxonomy with explicit ranks for ecological and evolutionary
analyses of bacteria and archaea. ISME J., 6(3):610–618, 2012.
[22] M N Price, P S Dehal, and A P Arking. Fasttree 2-approximately
maximum-likelihood trees for large alignments. Plos One, 5(3):e9490, 2010.
[23] QIIME.
Denoising
of
454
http://qiime.org/tutorials/denoising 454 data.html.
07-17.

data
Accessed:

sets.
2013-

[24] Chrisopher Quince.
Software for pyrosequencing noise removal.
http://userweb.eng.gla.ac.uk/christopher.quince/Software/PyroNoise.html.
Accessed: 2013-07-17.
[25] Christopher Quince, Thomas P Curtis, and William T Sloan. The rational
exploration of microbial diversity. The ISME Journal, 2:997–1006, 2008.
[26] Christopher Quince, Andrew Lanzen, Thomas P Curtis, Russell J Davenport, Neil Hall, Ian M Head, Fiona L Read, and William T Sloan. Accurate
determination of microbial diversity from 454 pyrosequencing data. Nat.
Methods, 6:639–U27, 2009.
[27] Christopher Quince, Andrew Lanzen, Russell J Davenport, and Peter J
Turbaugh. Removing noise from pyrosequenced amplicons. BMC Bioinformatics, 12:38, 2011.
[28] Benjamin Ragan-Kelley, William A Walters, Daniel McDonald, Justin Riley, Brian B Granger, Antonio Gonzalez, Rob Knight, Fernando Perez,
and J Gregory Caporaso. Collaborative cloud-enabled tools allow rapid,
reproducible biological insights. The ISME Journal, 7:461–464, 2013.
[29] J Reeder and R Knight. Rapidly denoising pyrosequencing amplicon reads
by exploiting rank-abundance distributions. Nat. Methods, 7:668–669, 2010.
[30] Michael C Schatz, Ben Langmead, and Steven L Salzberg. Cloud computing
and the dna data race. Nat. Biotechnol., 28(7):691–693, 2010.
[31] Matthew B. Scholz, Chien-Chi Lo, and Patrick SG Chain. Next generation
sequencing and bioinformatic bottlenecks: the current state of metagenomic
data analysis. Current Opinion in Biotechnology, 23(1):9–15, 2012.

19

[32] G Tan, L Xu, S Feng, and N Sun. An experimental study of optimizing
bioinformatics applications. Proceedings of IEEE International Parallel &
Distributed Processing Symposium (HiCOMB), pages 25–29, 2006.
[33] Q Wang, G M Garrity, J M Tiedje, and J R Cole. Naive bayesian classifier
for rapid assignment of rrna sequences into the new bacterial taxonomy.
Appl. Environ. Microb., 73(16):5261–5267, 2007.
[34] James Robert White, Malcolm Matalka, W Florian Fricke, and Samuel V
Angiuoli. Cunningham: a blast runtime estimator. Nature Precedings,
January 2011.
[35] Wine. Wine [version 1.5.25]. http://www.winehq.org, March 2013.

20

Appendix A

Supplemental Material

Figure A1: The general analysis pipeline utilised within QIIME for modelling
performance

21

Table A1: Pipeline Parameters for Relevant Analysis Steps
Script
Split libraries
AmpliconNoise
Pick OTUs
Representative
set
Taxonomy
assignment
Alignment

Identify chimeras
Filter alignment
Make phylo.
tree

Parameters
min seq length
max seq length

Flag
-l
-L

seqnoise resol.

-s

method
similarity
method
sorting
method
confidence
method
pairwise method
min percent ID
min length
method
fragments
taxonomy depth
allowed gap frac.
threshold

-m
-s
-m
-s
-m
-c
-m
-a
-p
-e
-m
-n
-d
-g
-t

Value
150
1000
25 (Titanium)
30 (FLX)
uclust
0.97
first (clust. seed)
otu
rdp
0.8
pynast
uclust
75
150
chimera slayer
3
4
0.999999
3

method

-t

fasttree

Table A2: Pipeline Script Inputs According to Type. Representative Sequences
are Equivalent to OTUs After Clustering
Script
Quality filtering
Denoising
OTU picking
Taxonomy assignment
Alignment
Chimera removal
Phylogeny
OTU table
Diversity

Input type
Raw sequences
Trimmed sequences
Denoised sequences
Representative sequences
Representative sequences
Representative sequences
Chimera free OTUs
OTUs & taxonomy assignments
OTU table & phylogenetic tree

22

Figure A2: Main effects plots for the three models

23

