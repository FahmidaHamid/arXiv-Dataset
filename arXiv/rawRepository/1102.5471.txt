arXiv:1102.5471v1 [cs.CC] 27 Feb 2011

An Implicit Cover Problem in Wild Population
Study∗
Mary V. Ashley†

Tanya Y. Berger-Wolf‡

Wanpracha Chaovalitwongse§
Ashfaq Khokhar‡

Bhaskar DasGupta‡¶
Saad Sheikh‡

March 1, 2011

Abstract
In an implicit combinatorial optimization problem, the constraints are
not enumerated explicitly but rather stated implicitly through equations,
other constraints or auxiliary algorithms. An important subclass of such
problems is the implicit set cover (or, equivalently, hitting set) problem
in which the sets are not given explicitly but rather defined implicitly
For example, the well-known minimum feedback arc set problem is such
a problem. In this paper, we consider such a cover problem that arises
in the study of wild populations in biology in which the sets are defined
implicitly via the Mendelian constraints and prove approximability results
for this problem.

Keywords: Implicit set cover, Computational Biology, Inapproximbility

1

Introduction

In an implicit combinatorial optimization problem, the constraints are not enumerated explicitly but rather stated implicitly through equations, other constraints or auxiliary algorithms. Well-known examples of such optimization
problems include convex optimization problems where the constraints are not
∗ A preliminary version of these results appeared in the 5th International Conference on
Algorithmic Aspects in Information and Management, A. Goldberg and Y. Zhou (Eds.), LNCS
5564, 43-54, June 15-17, 2009.
† Department of Biological Sciences University of Illinois at Chicago, 840 West Taylor
Street, Chicago, IL 60607. Email: ashley@eeb.uic.edu.
‡ Department of Computer Science, University of Illinois at Chicago, 851 South Morgan
Street, Chicago, IL 60607. Email: {dasgupta,ssheikh,tanyabw,ashfaq}@cs.uic.edu. Supported by NSF grant IIS-0612044.
§ Department of Industrial Engineering, Rutgers University, PO Box 909, Piscataway, NJ
08855. Email: wchaoval@rci.rutgers.edu.
¶ Supported by NSF grants DBI-0543365 and IIS-0346973.

1

given explicitly but rather can be queried implicitly through a separation oracle or given by an auxiliary algorithm. For example, the ellipsoid method can
be used to solve in polynomial time a linear programming problem with possibly exponentially many constraints provided we have a separation oracle that,
given a tentative solution, in polynomial time either verifies that the solution is
a feasible solution or provides a hyperplane separating the solution point from
the feasible region. This paper concerns the implicit set cover problems which
are defined as follows. In the standard (unweighted) version of the set cover
problem, we are given a collection of subsets S over an universe of elements U
and the goal is to find a sub-collection of sets from S of minimum cardinality
such that the union of these sets is precisely U. A combinatorially equivalent
version of the set cover problem is the so-called hitting set problem where one
needs to pick instead a subset of the universe U of minimum cardinality which
contains at least one element from every set. Set cover and hitting set problems
are fundamental problems in combinatorial optimization whose computational
complexities have been throughly investigated and well understood [11]. More
general version of the problem could include generalizing the objective function
to be minimized, namely the number of sets picked, by say having weighted
sets and minimizing the sum of weights of the selected sets, or by defining a
monotone objective function on the set system.
Implicit set cover (or hitting set) problems have the same standard setting,
but the sets are not given explicitly but rather implicitly through some implicit combinatorial constraints. For example, the minimum feedback vertex
set or the minimum feedback arc set problems are examples of such implicit
hitting set problems. Such implicit set cover or hitting set problems can be
characterized by not giving the collection of sets S explicitly but via an efficient
(polynomial-time) oracle O that will supply members of S satisfying certain
conditions. For example, the recent work of Richard Karp and Erick Moreno
Centeno1 considers some implicit hitting set problems with applications to multiple genome alignments in computational biology in which the oracle O provides
a minimum-cardinality set (or a good approximation to it) from the collection
S that is disjoint from a given set Q. In addition to standard polynomial-time
approximation guarantees, one could also invoke other measures of efficiencies,
such as number of access to the oracle O to obtain an optimal or near-optimal
solution to the hitting set problem as used by Karp and Centeno.
In this paper, we consider an implicit (unweighted) set cover problem, which
we call the MIN-PARENT problem, that arises in the study of wild population.
Our problem in the setting described above is roughly as follows. Our oracle O
returns, given a sub-collection of elements U ′ ⊆ U, if there is a set that includes
U ′ . Our specific objective function is motivated by the biological application
and is a monotone function, namely including a new element in our collection
does not decrease it. More precise formulations of our problems appear in the
next section and will easily convince the reader that our problem is not captured
by previous works or the recent work by Karp and Centeno.
1 Richard

Karp, UC Berkeley, personal communication.

2

2

Motivations

For wild populations, the growing development and application of molecular
markers provides new possibilities for the investigation of many fundamental
biological phenomena, including mating systems, selection and adaptation, kin
selection, and dispersal patterns. In our motivation we are concerned with full
sibling relationships from single generation sample of microsatellite markers.
Several methods for sibling reconstruction from microsatellite data have been
proposed (e.g., see [6, 10, 12]). Combinatorial approaches to sibling reconstruction using suitable parsimony assumptions have been studied in [2–5]. These
approaches use the Mendelian inheritance rules to impose constraints on the
genetic content possibilities of a sibling group. A formulation of the inferred
combinatorial constraints in constructing a collection of groups of individuals
that satisfy these constraints under the parsimony assumption of a minimum
number of parents leads to the MIN-PARENT problems discussed in the paper.

3

Precise Formulations of MIN-PARENT Problems

An element (individual) u is an ordered sequence (u1 , u2 , . . . , uℓ ) where each
uj is a genetic trait (locus) and is represented by a multi-set {uj,0 , uj,1 } of
two (possibly equal) numbers (alleles) inherited from its parents. Biologically,
each element corresponds to an individual in the sample of the wild population
from the same generation. We have a universe U consisting of n such elements.
Certain sets of individuals in U can be full siblings, i.e. having the same pair
of parents under the Mendelian inheritance rule. These sets are specified in
an implicit manner in the following way. The Mendelian inheritance rule states
that an individual u = (u1 , u2 , . . . , uℓ ) ∈ U can be a child of a pair of individuals
(parents), say v = (v1 , v2 , . . . , vℓ ) and w = (w1 , w2 , . . . , wℓ ), if and only if for
each locus j ∈ {1, . . . , ℓ} one allele of uj is from vj and the other element of
uj is from wj . Finally, a subset U ′ ⊆ U is a (full) sibling group if and only if
there exists a pair of parents v and w such that every member of U ′ is a child
of v and w. Note that any pair of individuals is a full sibling group by the
Mendelian constraints. As an illustration, the four individuals (with ℓ = 2 loci)
({1, 2}, {1, 1}), ({4, 3}, {6, 6}) and ({1, 2}, {1, 6}) form a full sibling group since
they can be the children of the two parents ({1, 3}, {1, 6}) and ({2, 4}, {1, 6}).
Given these Mendelian constraints, our goal is to cover the universe U by a set
of full-sibling groups under the parsimonious assumption of a minimum number
of parents. Formally, the MIN-PARENTn,ℓ problem is defined as follows.
Problem name: MIN-PARENTn,ℓ
Input: Our input is an universe U of n individuals each with ℓ loci.
Valid Solutions: a cover A of U such that each set S ∈ A in the cover is a
sibling group.
3

Notation: B(A) denote a set of individuals (parents) such that every set S
(sibling group) in the cover has its two parents from B(A).
Objective for minimization: minimize |B(U)| = minA |B(A)|
In the setting of the implicit set cover problems described before, our cover
problem is as follows:
• Our sets (sibling groups) are defined implicitly by the Mendelian constraints; note that the number of such sets is possibly exponential and
thus we cannot always enumerate them in polynomial time.
• Our polynomial time oracle O answers queries of the following type: given
a given subset U ′ ⊆ U of the universe, does U ′ form a valid (sibling) set
following the Mendelian constraints2 ? It is easy to show a polynomial-time
implementation of the oracle (e.g., see [4]).
Finally, note that our objective function is obviously monotone since U ′ ⊂ U
implies |B(U ′ )| ≤ |B(U)|. A natural parameter of interest in covering problems the maximum size (number of elements) a in any set. For our problem,
the parameter a corresponds to maximum number of individuals of any sibling
group.
We first show that the MIN-PARENT problem is MAX-SNP-hard even if
a = 3. This leads us to the question about the computational complexity of
the problem for arbitrary a. We will show that, for arbitrary a, it is very hard
to even find an approximation to a minimum set of parents for a given sibling
partition of the universe with given a candidate set of parents that includes
an optimal set of parents. Formally, the FIND-MIN-PARENTn,ℓ is defined as
follows.
Problem name: FIND-MIN-PARENTn,ℓ .
Input: a partition A of a set U of n elements, each with ℓ loci, such that each
set S in the partition A is a sibling set, and a set of elements (possible
parents) P.
Valid Solutions: any B(A) provided that B(A) ⊆ P.
Notation: B(A) denote a set of individuals (parents) such that every set S
(sibling group) in the cover has its two parents from B(A).
Objective for minimization: minimize |B(U)| = minB(A)⊆P |B(A)|.
2 Note that if U ′ is not a valid set, the oracle O does not provide any hint about other
possible valid sets.

4

3.1

Standard Terminologies

Recall that a (1 + ε)-approximate solution (or simply an (1 + ε)-approximation)
of a minimization (resp. maximization) problem is a solution with an objective
value no larger (resp. no smaller) than 1 + ε times (resp. (1 + ε)−1 times) the
value of the optimum, and an algorithm achieving such a solution is said to have
an approximation ratio of at most 1 + ε. A problem is r-inapproximable under a
certain complexity-theoretic assumption means that the problem does not have
a r-approximation unless the complexity-theoretic assumption is false.
L-reductions are a special kind of approximation-preserving reduction that
can be used to show MAX-SNP-hardness of an optimization problem. Given two
optimization problems Π and Π′ , Π L-reduces to Π′ if there are three polynomialtime procedures T1 ,T2 , T3 and two constants a and b > 0 such that the following
two conditions are satisfied:
(1) For any instance I of Π, algorithm T1 produces an instance I ′ = f (I) of Π′
generated from T1 such that the optima of I and I ′ , OP T (I) and OP T (I ′ ),
respectively, satisfy OP T (I ′ ) ≤ a · OP T (I).
(2) For any solution of I ′ with cost c′ , algorithm T2 produces another solution
with cost c′′ that is no worse than c′ , and algorithm T3 produces a solution
of I of Π with cost c (possibly from the solution produced by T2 ) satisfying
|c − OP T (I)| ≤ b · |c′′ − OP T (I ′ )|.
An optimization problem is MAX-SNP-hard if another MAX-SNP-hard problem L-reduces to that problem. Arora et al. [1] show that, assuming P6=NP, every MAX-SNP-hard problem is (1 + ε)-inapproximable for some constant ε > 0
unless P=NP.

3.2

Our Results

For MIN-PARENTn,ℓ , we show in Section 4 that the problem is MAX-SNPhard even if a = 3 and observe in Section 5 that for
√ any a and any integer constant c > 0 the problem admits an easy ac + ln c n-approximation. We show
ε
in Section 6 that, for arbitrary a, FIND-MIN-PARENTn,ℓ admits no 2log n poly log(n)
approximation, for every constant 0 < ε < 1, unless NP⊆DTIME(n
).

4

Inapproximability of MIN-PARENT for a = 3

Lemma 1 MIN-PARENTn,ℓ is MAX-SNP-hard even if a = 3.
Proof. For notational simplification, when an individual has the multiset
{x, x} in a locus, we will refer to it by saying that the individual has a “label”
of value x in that locus. Our construction will ensure that all individuals have
only one label at every locus. It is then easy to check that a set of individuals
can be a sibling set if and only if at each locus they have labels with no more

5

than two distinct values. In the sequel, we will use the terminologies “label x”
and “locus {x, x}” interchangeably.
The (vertex-disjoint) triangle-packing (TP) problem is defined as follows.
We are given an undirected connected graph G. A triangle is a cycle of 3 nodes.
The goal is to find (pack) a maximum number of node-disjoint triangles in G.
TP is known to be MAX-SNP-hard even if every vertex of G has degree at most
4 [7]. Moreover, the proof in [7] show that the MAX-SNP-hard instances of TP
in their reduction produces an instance of TP with n nodes in which an optimal
solution has αn triangles for some constant 0 < α < 1.
We will provide an approximation preserving reduction from an instance
graph G of n nodes of TP with nodes of G having a maximum degree of 4 as obtained in [7] to MIN-PARENTn,ℓ . We introduce an individual u for every node
u of the graph G and provide ordered label sequences for each node (individual)
such that:
(1) Three individuals corresponding to a triangle of G have at most two values
in every locus and thus can be a sibling set.
(2) Three individuals that do not correspond to a triangle of G have at least
three values in some locus and thus cannot be a sibling set.
(3) Consider any maximal set of vertex disjoint triangles in G and the corresponding sibling sets (each of size 3). Partition the remaining vertices of
G not covered by these triangles arbitrarily into pairs (groups of size 2)
and consider the corresponding full sibling sets (each of size 2). Then,
each sibling set in the above collection requires two new parents.
Note that since we have a maximal set of triangles, no three vertices in
the set of pairs can form a triangle. Conversely, given any solution of
MIN-PARENTn,ℓ , we preprocess the solution to get a canonical solution
to ensure that no three individuals in the union of pairs can be a sibling
set; this preprocessing does not increase the number of sibling sets.
Note that, since any pair of individuals can be a full sibling set, the above
properties imply that TP has a solution with t triangles if and only if the MIN= n − t parents.
PARENT problem can be solved with 2t + 2 · n−3t
2
The MAX-SNP-hardness now follows easily since an optimum solution of TP
on G has αn triangles for some constant 0 < α < 1. More precisely, let I and
I ′ be the instance of TP and the corresponding instance of MIN-PARENTn,ℓ ,
respectively, and let OPT(I) and OPT(I ′ ) denote the number of triangles and
the number of parents in an optimal solution of I and I ′ , respectively. Then,
the following two statements hold.

1−α
(a) Since OPT(I) = αn we have OPT(I ′ ) = n − αn = 1−α
OPT(I)
α αn =
α
is
a
positive
constant.
where 1−α
α
(b) Since OPT(I ′ ) = n − αn we must have c′ ≥ n − αn. Thus, if c′ = n − αn + x
(for some x) is the number of parents in a solution of the instance I ′ after

6

preprocessing then number of triangles in the solution of the instance I of
TP is given by c = n−c′ = αn−x and thus |c − OP T (I)| = |c′ − OP T (I ′ )|.
Now, we describe the reduction.
Our first set of loci are as follows. The index of a locus, which we call the
“coordinate”, is defined by an “origin” node u. Thus, we will have |V | such loci,
one for every node u. The respective label of an individual v at this coordinate
is the distance (number of edges in a shortest path) from u to v.
Our second set of loci are as follows. We have such a locus for every set
of three vertices {u, v, w} that does not form a triangle. Thus, we will have
O(|V |3 ) such loci. Since the three vertices do not form a triangle, at least one
pair of them, say u and v, are not connected by an edge. As a result, the set
of vertices {u, v, x} do not form a triangle for any other vertex x 6∈ {u, v}. Our
goal is to ensure that the vertices u, v and w cannot be a sibling group while
not disallowing any other sibling groups that can be formed by a triangle in the
graph. This is easy to do. Put the label 1 in this locus for the individual u,
label 2 for individual v and label 3 for all other individuals.
First we need to check that Property (1) holds. The following is true with
respect to the first set of loci. Consider a triangle {u, v, w}, any locus (coordinate) ℓ and assume that u has the minimum label value of L, i.e., it is nearest
to the origin node that defined ℓ. Then labels of v and w are at least L and at
most L + 1, hence u, v and w have at most two labels at ℓ. The second set of
loci never disallows a sibling group corresponding to a triangle, so the property
is not violated by them either.
The construction of the second set of loci implies that Property (2) is true.
Finally, we need to verify Property (3). There are three cases to verify.
First, consider the case when we have two sibling groups correspond to two
triangles T1 = {u, v, w} and T2 = {p, q, r} in G. Note that since nodes in G
have a maximum degree of 4, any node of one triangle can be connected to at
most two nodes in the other triangle.
The locus ℓ defined by the origin node u has a label 0 for u and a label 1
for v and w. Thus, the sibling set {u, v, w} can be generated only by a pair of
parents, say A and B, each of which has the alleles {0, 1} in locus ℓ.
Since u is connected to at most two nodes in T2 , it is not connected to a
node in T2 , say r. Then, r must have a label x ≥ 2 in locus ℓ. Thus, neither A
nor B can be a parent of the sibling group {p, q, r} since x 6∈ {0, 1}.
Second, consider the case when the we have two sibling groups corresponding
to a triangle T = {u, v, w} and a pair P = {p, q}. Consider the locus defined
by the origin node u. We have a label 0 for u and a label 1 for v and w in this
locus. Thus, the sibling set {u, v, w} can be generated only by a pair of parents,
say A and B, each of which has the alleles {0, 1} in this locus. If node u is not
connected to both nodes p and q then one of the nodes which is not connected
to u, say p, must have a label x ≥ 2 in this locus. Thus, neither A nor B can
be a parent of the sibling group {p, q} since x 6∈ {0, 1}. Otherwise, it must be
the case that u is connected to both p and q.

7

Repeating the same argument with q as the origin node and then r as the
origin node shows that the only case that remains to be considered is when each
of u, v and w is connected to both the nodes p and q. But, then the induced
subgraph of G with vertices u, v, w, p and q is a 5-clique. Since every node
in G has a degree of no more than 4, this implies that G has more than one
connected component, contradicting the fact that G was a connected graph.
Finally, consider the case when we have two sibling groups corresponding
to two pairs P1 = {u, v} and P2 = {p, q}. Since we have preprocessed the
solution of MIN-PARENTn,ℓ or equivalently have a maximal set of triangles for
the solution of TP, node u is not connected to at least one node in P2 , say p.
The locus defined by the origin node u has a label 0 for u and a label 1 for v,
but has a label x ≥ 2 for p. Thus, the sibling set {u, v} can be generated only
by a pair of parents, say A and B, each of which has the alleles {0, 1} in the
corresponding locus, but neither A nor B can be a parent of the sibling group
{p, q} since x 6∈ {0, 1}.
❑

5

A Simple Approximation Algorithm for MINPARENTn,ℓ

Note that we do not need to know the value of a in the theorem below.
Observation 2 Let a be the maximum size of any sibling
for any in a set.Then,
√
n-approximation
teger constant c > 0, MIN-PARENT admits an easy
+ ln c
c
with polynomially many access to the oracle O (and, thus in polynomial time).
Proof. Our proof is similar to the analysis of a standard greedy algorithm for
set cover problems [11].
Suppose that we have a subset U ′ ⊂ U of the universe that is still not covered.
We can enumerate all subsets of U ′ of size at most c in O(nc ) time and for each
subset query the oracle O to find if any of these subsets of individuals are full
siblings for the MIN-PARENTn,ℓ problem. Thus we can assume that for every
instance of the problem, either the maximum sibling set size is below c and we
can find such a group of maximum size, or we can find a sibling set of size c.
Our algorithm simply selects such a set, removes the corresponding elements
from U ′ and continues until all elements of U are covered.
Obviously, all subsets of a sibling set are valid sibling sets too. Let OPT
be the minimum number of parents in an optimal solution of MIN-PARENTn,ℓ .
Consider an optimum solution, make it disjoint by arbitrarily shrinking each fullsibling set and let α be the number of sets in this partition. Obviously, α ≤ n/2.
Since no two full-sibling sets are produced by the same pair of parents (because
√

of minimality), OPT
≥ α which implies OPT> 2α. We distribute the cost
2
of our solution among the sets of the optimum. When a set with b elements
is selected, we remove each of its element and charge the sets of the optimum
1/b for each removal. It is easy to see that a set with a elements will get the
8

sequence of charges with values at most (1/c, . . . , 1/c, 1/(c − 1), 1/(c − 2), . . . , 1)
|
{z
}
a−c times
Pc
Pc
and these chargesadd to ac − 1 + i=1 1i = ac + i=2 1i < ac + ln c. Thus, we use
a
at most c + ln c α sibling groups. Each sibling group can be generated by at
most two new parents. Thus, the total number
 √ of parents necessary
 √ to generated
❑
these sibling groups is at most ac + ln c 2α OPT< ac + ln c n OPT.

6

Inapproximability of FIND-MIN-PARENT

Lemma 3 For every constant 0 < ε < 1, FIND-MIN-PARENTn,ℓ admits no
ε
2log n -approximation unless NP⊆DTIME(npoly log(n) ).
Proof. We first need the MINREP problem which is defined as follows. We
are given a bipartite graph G = (A, B, E). We are also given a partition of
A into |A|/α equal-size subsets A1 , A2 , . . . , Aα and a partition of B into |B|/β
equal-size subsets B1 , B2 , . . . , Bβ . These partitions define a natural “bipartite
super-graph” H in the following manner. H has a “super-vertex” for every
Ai (the left partition) and a “super-vertex” for every Bj (the right partition).
There exists an “super-edge” between the super-vertex Ai and the super-vertex
Bj if and only if there exists u ∈ Ai and v ∈ Bj such that {u, v} is an edge of G.
A pair of vertices u and v “witnesses” a super-edge {Ai , Bj } provided a ∈ Ai ,
b ∈ Bj and the edge {a, b} exists in G. A set of vertices S of G witnesses a
super-edge if there exists at least one pair of vertices in S that witnesses the
super-edge. The goal of the MINREP problem is to find A′ ⊆ A and B ′ ⊆ B
such that A ∪ B witnesses every super-edge of H and the size of the solution,
namely |A′ | + |B ′ |, is minimum.
For notation simplicity, let n = |A| + |B|. The following result is a consequence of Raz’s parallel repetition theorem [8, 9]. Let L ∈ N P and 0 < ε < 1 be
any fixed constant. Then, there exists a reduction running in quasi-polynomial
time, namely in time npoly log(n) , that given an instance x of L produces an
instance of MINREP such that if x ∈ L then MINREP has a solution of
size at most at most α + β, but if x 6∈ L then MINREP has a solution of
ε
size at least (α + β) · 2log n . Thus, the above theorem shows that MINε
REP has no 2log n -approximation under the complexity-theoretic assumption
of NP6⊆DTIME(npoly log(n) ).
Let L be any language in NP. Use the above theorem to translate an instance
x of L to an instance of MINREP as described above. Now, we describe a translation of this instance of MINREP to an instance of FIND-MIN-PARENTP,n,ℓ .
We have a parent pv in P corresponding to every element v ∈ A ∪ B. We
have an individual sa,b in U for every edge {a, b} in G. Thus, the number
of possible parents in P is n and the number of individuals in U is O(n2 ).
ε
It therefore suffices to prove a 2log |P| -inapproximability since that implies as
ε
2log |U | -inapproximability.
Before describing our reduction, we need a generic construction of the following nature to simplify our description. We are given two elements pu , pv ∈ P
9

and an element sa,b ∈ U. We want to add a new locus with appropriate allele
values to ensure that sa,b cannot be a child of pu and pv , but no other parentchild relationship is forbidden. This is easy to do. Put the alleles {a, b} in this
locus for pu and pv and put the alleles {a, c} in this locus for every individual
(including sa,b ) in (P ∪ U) \ {pu , pv }. It follows that sa,b cannot be a child of
pu and pv since c 6∈ {a, b}, but no other child-parent combination is forbidden
since {a, c} can be produced by the Mendelian rule either from {a, b} and {a, c}
or from {a, c} and {a, c}.
Now, we add additional loci to the individuals in U ∪ P in the following
manner following the two rules:
Rule (⋆): For every edge {u, v} of G with u ∈ Ai and v ∈ Bj and for every pair
of vertices {a, b} such that {a, b} ∈ E\{ {y, z} | y ∈ Ai , z ∈ Bj , {y, z} ∈ E }
we add an additional locus using the generic construction to ensure that
sa,b cannot be a child of pu and pv .
Rule (⋆⋆): For every pair of vertices u and v of G such that {u, v} 6∈ E and for
every pair of vertices a and b of G such that {a, b} ∈ E, we add an additional locus using the generic construction to ensure that the individual
sa,b ∈ U cannot be a child of the parents pu and pv in P.
We build each individual in U ∪ P locus-by-locus in the above manner. Our
partition A of U to sibling groups is defined as follows: we have a sibling group
Ai,j = {{sa,b } | {a, b} witnesses the super-edge {Ai , Bj } } for every super-edge
{Ai , Bj }.
First, we need to verify that each of our sibling set is indeed a sibling set.
Consider the sibling set Ai,j . Pick any u ∈ Ai and v ∈ Bj such that {u, v} ∈ E,
i.e., {u, v} witnesses the super-edge {Ai , Bj }. We claim that pu and pv are the
parents for all individuals in Ai,j . Indeed, the two rules allow this.
Suppose that MINREP has a solution of size γ. This generates a set of γ
parents for FIND-MIN-PARENT in an obvious manner: for every vertex v in
the solution of MINREP we pick the individual pv in the solution of FINDMIN-PARENT. If the super-edge {Ai , Bj } is witnessed by the edge {u, v} in
the solution of MINREP, then the sibling set Ai,j is generated by the parents
pu and pv .
Conversely, suppose that FIND-MIN-PARENT has a solution with γ parents. We associate each parent pu to the corresponding vertex u of G in our
solution of MINREP. Consider a super-edge {Ai , Bj } and the associated sibling
set Ai,j . Suppose that pu and pv are the parents of this group. By Rule (⋆⋆),
{u, v} ∈ E. By Rule (⋆), one of pu and pv , say pu , must be from Ai and the
other one pv from Bj . Thus, the edge {u, v} witnesses this super-edge.
❑
Remark 1 The above reduction works even if one does not specify the set A of
sibling partition explicitly as part of input but allows all feasible partitions.
Acknowledgements. We thank Richard Karp for his talk at ICS-2009 that
motivated us to think about our problem as an implicit cover problem.
10

References
[1] S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. Proof verification and hardness of approximation problems, Journal of the ACM, 45 (3),
501-555, 1998.
[2] M. V. Ashley, I. C. Caballero, W. Chaovalitwongse, B. DasGupta, P. Govindan, S. Sheikh and T. Y. Berger-Wolf. KINALYZER, A Computer Program for Reconstructing Sibling Groups, Molecular Ecology Resources, 9
(4), 1127-1131, 2009.
[3] M. Ashley, T. Berger-Wolf, P. Berman, W. Chaovalitwongse, B. DasGupta
and M.-Y. Kao. On Approximating Four Covering and Packing Problems,
Journal of Computer & System Sciences. 75 (5), 287-302, 2009.
[4] T. Y. Berger-Wolf, B. DasGupta, W. Chaovalitwongse, and M. V. Ashley. Combinatorial reconstruction of sibling relationships, Proceedings of
the 6th International Symposium on Computational Biology and Genome
Informatics, 1252-1255, 2005.
[5] T. Y. Berger-Wolf, S. Sheikh, B. DasGupta, M. V. Ashley, I. Caballero, W.
Chaovalitwongse and S. L. Putrevu. Reconstructing Sibling Relationships
in Wild Populations, Bioinformatics, 23 (13), i49-i56, 2007.
[6] J. Beyer and B. May. A graph-theoretic approach to the partition of individuals into full-sib families, Molecular Ecology, 12, 2243-2250, 2003.
[7] A. Caprara and R. Rizzi. Packing Triangles in Bounded Degree Graphs,
Information Processing Letters, 84 (4), 175-180, 2002.
[8] G. Kortsarz, R. Krauthgamer and J. R. Lee. Hardness of Approximating
Vertex-Connectivity Network Design Problems, SIAM J. of Computing, 33
(3), 704-720, 2004.
[9] R. Raz. A parallel repetition theorem, SIAM J. of Computing, 27 (3), 763803, 1998.
[10] B. R. Smith, C. M. Herbinger and H. R. Merry. Accurate partition of individuals into full-sib families from genetic data without parental information,
Genetics, 158, 1329-1338, 2001.
[11] V. Vazirani. Approximation Algorithms, Springer-Verlag, 2001.
[12] J. Wang. Sibship reconstruction from genetic data with typing errors, Genetics, 166, 1968-1979, 2004.

11

