Generic construction of scale-invariantly coarse grained memory
Karthik H. Shankar1

arXiv:1406.3185v2 [q-bio.NC] 2 Jan 2015

1 Center

for Memory and Brain, Boston University

Encoding temporal information from the recent past as spatially distributed activations is essential in order for the entire recent past to be simultaneously accessible.
Any biological or synthetic agent that relies on the past to predict/plan the future,
would be endowed with such a spatially distributed temporal memory. Simplistically, we would expect that resource limitations would demand the memory system
to store only the most useful information for future prediction. For natural signals
in real world which show scale free temporal fluctuations, the predictive information
encoded in memory is maximal if the past information is scale invariantly coarse
grained. Here we examine the general mechanism to construct a scale invariantly
coarse grained memory system. Remarkably, the generic construction is equivalent
to encoding the linear combinations of Laplace transform of the past information and
their approximated inverses. This reveals a fundamental construction constraint on
memory networks that attempt to maximize predictive information storage relevant
to the natural world.

2
I.

INTRODUCTION

Representing the information from the recent past as transient activity distributed over a
network has been actively researched in biophysical as well as purely computational domains
[1, 2]. It is understood that recurrent connections in the network can keep the information
from distant past alive so that it can be recovered from the current state. The memory
capacity of these networks are generally measured in terms of the accuracy of recovery
of the past information [2–4]. Although the memory capacity strongly depends on the
network’s topology and sparsity [5–8], it can be significantly increased by exploiting any
prior knowledge of the underlying structure of the encoded signal [9, 10].
Our approach to encoding memory stems from a focus on its utility for future prediction,
rather than on the accuracy of recovering the past. In particular we are interested in encoding
time varying signals from the natural world into memory so as to optimize future prediction.
It is well known that most natural signals exhibit scale free long range correlations [11–13].
By exploiting this intrinsic structure underlying natural signals, prior work has shown that
the predictive information contained in a finite sized memory system can be maximized if the
past is encoded in a scale-invariantly coarse grained fashion [14]. Each node in such a memory
system would represent a coarse grained average around a specific past moment, and the
time window of coarse graining linearly scales with the past timescale. Clearly the accuracy
of information recovery in such a memory system degrades more for more distant past. In
effect, the memory system sacrifices accuracy in order to represent information from very
distant past, scaling exponentially with the network size [14]. The predictive advantage of
such a memory system comes from washing out non-predictive fluctuations from the distant
past, whose accurate representation would have served very little in predicting the future.
Arguably, in the natural world filled with scale-free time varying signals, animals would have
evolved to adopt such a memory system conducive for future predictions. This is indeed
evident from animal and human behavioral studies that show that our memory for time
involves scale invariant errors which linearly scale with the target timescale [15, 16].
Our focus here is not to further emphasize the predictive advantage offered by a scale
invariantly coarse grained memory system, rather we simply assume the utility of such a
memory system and focus on the generic mechanism to construct it. One way to mechanistically construct such a memory system is to gradually encode information over real time as
a Laplace transform of the past and approximately invert it [17]. The central result in this
paper is that any mechanistic construction of such a memory system is simply equivalent to
encoding linear combinations of Laplace transformed past and their approximate inverses.
This result should lay strong constraints on the connectivity structure of memory networks
exhibiting the scale invariance property.
We start with the basic requirement that different nodes in the memory system represents
coarse grained averages about different past moments. Irrespective of the connectivity, the
nodes can be linearly arranged to reflect their monotonic relationship to the past time.
Rather than considering a network with a finite set of nodes, for analysis benefit, we consider
a continuum limit where the information from the past time is smoothly projected on a
spatial axis. The construction can later be discretized and implemented in a network with
finite nodes to represent past information from timescales that exponentially scale with the
network size.

3

Present

Past time

Spatial axis s1

s2

FIG. 1. Coarse grained averages around different past instants are projected on to different points
on the spatial axis.
II.

SCALE INVARIANT COARSE GRAINING

Consider a real valued function f(τ ) observed over time τ . The aim is to encode this timevarying function into a spatially distributed representation in one dimension parametrized
by s, such that at any moment τ the entire past from −∞ to τ is represented in a coarse
grained fashion as T(τ, s)
Z τ
f(τ 0 )W(τ − τ 0 , s) dτ 0 .
(1)
T(τ, s) =
−∞

This is now a convolution memory model. The Rkernel W(τ − τ 0 , s) is the coarse graining
τ
window function with normalized area for all s, −∞ W(τ − τ 0 , s)dτ 0 = 1. Different points
on the spatial axis uniquely and monotonically represents coarse grained averages about
different instants in the past, as illustrated in figure 1.
We require that coarse graining about any past instant linearly scales with the past
timescale. So, for any pair of points s1 and s2 , there exists a scaling constant α12 such
that W(τ − τ 0 , s1 ) = α12 W(α12 (τ − τ 0 ), s2 ). For the window function to satisfy this scaleinvariance property, there should exist a monotonic mapping s(α) from a scaling variable α
to the spatial axis so that
W(τ − τ 0 , s(α)) = αW(α(τ − τ 0 ), s(1)).

(2)

Without loss of generality we shall pick s(α) = α because it can be retransformed to any
other monotonic s(α) mapping after the analysis. Hence with 0 < s < ∞,
W(τ − τ 0 , s) = sW(s(τ − τ 0 ), 1).
III.

(3)

SPACE-TIME LOCAL MECHANISM

Equation 1 expresses the encoded memory as an integral over the entire past. However,
the encoding mechanism can only have access to the instantaneous functional value of f
and its derivatives. The spatial pattern should self sufficiently evolve in real time to encode

4
eq. 1. This is a basic requirement to mechanistically construct T(τ, s) in real time using
any network architecture. Since the spatial axis is organized monotonically to correspond
to different past moments, only the local neighborhood of any point would affect its time
evolution. So we postulate that the most general encoding mechanism that can yield eq. 1 is a
space-time local mechanism given by some differential equation for T(τ, s). To analyze this,
let us first express the general space-time derivative of T(τ, s) by repeatedly differentiating
eq. 1 w.r.t τ and s.
[n]

T(m) (τ, s) =

n−1
X

[j]

f [n−j−1] (τ )W(m) (0, s)

j=0
τ

Z
+

−∞

[n]

f(τ 0 )W(m) (τ − τ 0 , s) dτ 0 .

(4)

Here n and m are positive integers. For brevity, we denote the order of time derivative within
a square bracket in the superscript and the order of space derivative within a parenthesis in
the subscript.
Since f(τ ) is an arbitrary input, T(τ, s) should satisfy a time-independent differential
equation which can depend on instantaneous time derivatives of f(τ ). The first term in
the r.h.s of eq. 4 is time-local, while the second term involves an integral over the entire
past. In order for the second term to be time-local, it must be expressible in terms of lower
[n]
derivatives of T(τ, s). Since the equation must hold for any f(τ ), W(m) (τ − τ 0 , s) should
satisfy a linear equation.
X
[n]
(5)
Cnm (s)W(m) (τ − τ 0 , s) = 0.
n,m

The aim here is not to derive the time-local differential equation satisfied by T(τ, s), but
just to impose its existence, which is achieved by imposing eq. 5 for some set of functions
[n]
Cnm (s). To impose this condition, let us first evaluate W(m) (τ − τ 0 , s) by exploiting the
functional form of the window function given by eq. 3. Defining z ≡ s(τ − τ 0 ) and the
function G(z) ≡ W(z, 1), eq. 3 can be repeatedly differentiated to obtain
[n]

W(m) (τ − τ 0 , s) =

m
X

(n + 1)!m!

r=ro

sn+1−m+r
(τ − τ 0 )r G[n+r] (z),
r!(m − r)!2

where ro = max[0, m − n − 1] and the superscript on G(z) represents the order of the
derivative w.r.t z. Now eq. 5 takes the form
X
n,m

Cnm (s)sn+1−m

m
X
(n + 1)!m! r [n+r]
z G
(z) = 0
2
r!(m
−
r)!
r=r

(6)

o

The above equation is not necessarily solvable for an arbitrary choice of Cnm (s). However,
when it is is solvable, the separability of the variables s and z implies that the above equation
will be separable into a set of linear differential equations for G(z) with coefficients given by
integer powers of z. The general solution for G(z) is then given by
X
G(z) =
aik z k e−bi z ,
(7)
i,k

5
where i and k are non negative integers. The coefficients aik and bi , and the functions Cnm (s)
cannot be independently chosen as they are constrained through eq. 6. Once a set of Cnm (s)
is chosen consistently with the coefficients aik and bi , the differential equation satisfied by
[n]
T(τ, s) can be obtained by iteratively substituting W(m) (τ − τ 0 , s) (in the second term of
the r.h.s of eq. 4) in terms of its lower derivatives and replacing the integral in terms of
derivatives of T(τ, s).
Here we shall neither focus on the choice of Cnm (s) nor on the differential equation for
T(τ, s) it yields. We shall only focus on the set of possible window functions that can be
constructed by a space-time local mechanism. Hence it suffices to note from the above
derivation that the general form of such a window function is given by eq. 7. Since by
definition the window function at each s coarse grains the input about some past moment,
we expect it to be non-oscillatory and hence restrict our focus to real values of bi . Further,
the requirement of the window function to have normalized area at all s restricts bi to be
positive.

IV.

TWO STEP PROCESS

Let us consider the simplest window function, where only one of the coefficients in the
set of aik and bi in eq. 7 are non-zero, namely bi = b and aik = b(k+1) /k!. We shall denote
the corresponding window function as W{k,b} to highlight its dependence on specific k and
b. The most general window function is then simply a linear combination of various W{k,b}
for different values of k and b. From eq. 7, W{k,b} takes the form
W{k,b} (τ − τ 0 , s) =

(bs)k+1
0
(τ − τ 0 )k e−bs(τ −τ ) .
k!

(8)

It turns out that the differential equation satisfied by T(τ, s) that generates this window
function is simply first order in both space and time given by
[1]

[0]

T(1) (τ, s) + bsT(1) (τ, s) −

(k + 1) [1]
T(0) (τ, s) = 0,
s

(9)

with a boundary condition T(τ, ∞) = f(τ ). This equation can hence be evolved in real time
by only relying on the instantaneous input f(τ ) at each moment τ .
For more complex window functions that are linear combinations of W{k,b} for various
k and b, the order of the space and time derivatives of T(τ, s) involved in the differential
equation are not necessarily bounded when the parameters k and b involved in the linear
combinations of W{k,b} are bounded. So, it is not straight forward to derive the mechanistic
construction as a differential equation for T(τ, s). Hence the question now is, what is the
mechanism to construct a memory system with any window function?
Interestingly, there exists an alternative derivation of eq. 9 where the time derivative and
space derivative can be sequentially employed in a two step process [17]. The first step is
equivalent to encoding the Laplace transform of the input f(τ ) as F(τ, s). The second step
is equivalent to approximately inverting the Laplace transformed input to construct T(τ, s).
f(τ ) Laplace F(τ, s) Inverse Laplace T(τ, s)
−−−−−−−→
−−−−−−−−−−−−−→

6
F[1] (τ, s) = −bsF(τ, s) + f(τ ),
b
T(τ, s) = sk+1 F(k) (τ, s).
k!

(10)
(11)

Taking f(τ ) to be a function
and F(−∞, s) = 0, eq. 10 can be
R τof bounded variation
0
integrated to see that F(τ, s) = −∞ f(τ 0 )e−bs(τ −τ ) dτ 0 . Thus F(τ, s) is the Laplace transform
of the past input computed over real time. Eq. 11 is an approximation to inverse Laplace
transform operation [18]. So T(τ, s) essentially attempts to reconstruct the past input, such
that at any s, T(τ, s) ' f(τ − k/bs). This reconstruction grows more accurate as k → ∞,
and the input from each past moment is reliably represented at specific spatial location. For
finite k however, the reconstruction is fuzzy and each spatial location represents a coarse
grained average of inputs from past moments, as characterized by the window function
W{k,b} . For further details, refer to [17].
Since any window function is a linear combination of various W{k,b} for different values
of k and b, its construction is essentially equivalent to linear combinations of the two step
process given by equations 10 and 11.
4
Window Function

1

Combinations of W{k,b}
1
2

W{100,2}
0.32W{65,1.3} + 0.27W{75,1.8}
+0.32W{75,1.26} + 0.09W{100,1.62}
3
W{8,0.16}
4
0.5W{35,1} + 0.5W{70,1}

2
3

4

0
-2.5

-2

-1.5
-1
Past time

-0.5

FIG. 2. For different combinations of W{k,b} , the window functions are plotted as a function of
past time at the spatial point s = 50.

The choice of the combinations of W{k,b} has strong implications on the shape of the
resulting window function. At any given s, W{k,b} is a unimodal function with a peak at
τ − τ 0 = k/bs (see eq. 8). Arbitrary combinations of W{k,b} could result in a spatial location
representing the coarse grained average about disjoint past moments, leading to undesirable
shapes of the window function. Hence the values of k and b should be carefully tuned.
Figure 2 shows the window functions constructed from four combinations of b and k. The
combinations are chosen such that at the point s = 50, the window function coarse grains
around a past time of τ 0 − τ ' −1. The scale invariance property guarantees that its
shape remains identical at any other value of s with a linear shift in the coarse graining
timescale. Comparing combinations 1 and 3, note that the window function is narrower for
larger k(=100) than for a smaller k(=8). Combination 2 has been chosen to illustrate a
plateau shaped window function whose sides can be made arbitrarily vertical by fine tuning
the combinations. Combination 4 (dotted curve in fig. 2) illustrates that combining different
values of k for the same b will generally lead to a multimodal window function which would
be an undesirable feature.

7
V.

DISCRETIZED SPATIAL AXIS

s1

1

s2
0
-10

-8

-6
-4
Past time

Discretized Window Function

A memory system represented on a continuous spatial axis is not practical, so the spatial
axis should be discretized to finite points (nodes). The two step process given by equations 10
and 11 is optimal for discretization particularly when the nodes are picked from a geometric
progression in the values of s [14]. Eq. 10 implies that the activity of each node evolves
independently of the others to construct F(τ, s) with real time input f(τ ). This is achieved
with each node recurrently connected on to itself with an appropriate decay constant of
bs. Eq. 11 involves taking the spatial derivative of order k which can be approximated by
the discretized derivative requiring linear combinations of activities from k neighbors on
either sides of any node. For further details on implementation of the two step process on
discretized spatial axis, refer to [14].

-2

FIG. 3. Window function W{8,1} at two points s1 = 6.72 and s2 = 2.59 computed on a discretized
spatial axis with c = 0.1. The dotted curves correspond to the window functions computed on the
continuous spatial axis (c → 0).

By choosing the nodes along the s-axis from a geometric progression, the error from
the discretized spatial derivative will be uniformly spread over all timescales, hence such a
discretization is ideal to preserve scale-invariance. Let us choose the s-values of successive
nodes to have a ratio (1 + c), where c < 1. Figure 3 shows the window function W{k,b} with
k = 8 and b = 1 constructed from the discretized axis with c = 0.1. The window functions
at two spatial points s1 = 6.72 and s2 = 2.59 are plotted to illustrate that scale invariance
is preserved after discretization. As a comparison, the dotted curves are plotted to show
the corresponding window function constructed in the continuous s-axis (limit c → 0). The
window function computed on the discretized axis is artificially scaled up so that the solid and
dotted curves in figure 3 are visually discernible. Note that the discretized window function
peaks farther in the past time and is wider than the window function on the continuous
spatial axis. As c → 0, the discretized window function converges on to the window function
constructed on the continuous axis, while for larger values of c the discrepancy grows larger.
Nevertheless, for any value of c, the discretized window function always stays scale-invariant,
as can be seen by visually comparing the shapes of the window functions at s1 and s2 in
figure 3. Now, it is straight forward to construct scale-invariant window functions of different
shapes by taking linear combinations of discretized W{k,b} , analogous to the construction in
figure 2.

8
Implementing this construction on a discretized spatial axis as a neural network has
a tremendous resource conserving advantage. Since at each s, the window function W{k,b}
coarse grains the input around a past time of k/bs, the maximum past timesscale represented
by the memory system is inversely related to minimum value of s. The geometric distribution
of the s values on the discretized axis implies that if there are N nodes spanning the spatial
axis for T(τ, s), it can represent the coarse grained past from timescales proportional to
(1 + c)N . Hence exponentially distant past can be represented in a coarse grained fashion
with linearly increasing resources.

VI.

DISCUSSION AND CONCLUSION

The formulation presented here starts from a convolution memory model (eq. 1) and
derives the form of the scale-invariant window functions (or the kernels) that can be constructed from a space-time local mechanism. Interestingly, by simply postulating a kernel
of the form of eq. 7, Tank and Hopfield have demonstrated the utility of such a memory
system in temporal pattern classification [19]. In general, a convolution memory model can
adopt an arbitrary kernel, but it cannot be mechanistically constructed from a space-time
local differential equation, which means a neural network implementation need not exist.
However, the Gamma-memory model [20] shows that linear combinations of Gamma kernels, functionally similar to eq. 7, can indeed be mechanistically constructed from a set of
differential equations.
The construction presented here takes a complementary approach to the Gamma-memory
model by requiring scale invariance of the window function in the forefront and then imposing
a space-time local differential equation to derive it. This sheds light on the connectivity
between neighboring spatial units of the network that is required to generate a scale invariant
window function, as described by the second part of the two step process (eq. 11). Moreover,
the linearity of the two step process and its equivalence to the Laplace and Inverse Laplace
transforms makes the memory representation analytically tractable.
Theoretically, the utility of a scale invariantly coarse grained memory hinges on the
existence of scale free temporal fluctuations in the signals being encoded [14]. Although
detailed empirical analysis of natural signals is needed to confirm this utility, preliminary
analysis of time series from sunspots and global temperature show that such a memory
system indeed has a higher predictive power than a conventional shift register [14]. The
predictive advantage of this memory system can be understood as arising from its intrinsic
ability to wash out non-predictive stochastic fluctuations in the input signal from distant past
and just represent the predictively relevant information in a condensed form. Finally, the
most noteworthy feature is that a memory system with N nodes can represent information
from exponentially past times proportional to (1 + c)N . In comparison to a shift register
with N nodes which can accurately represent a maximum past time scale proportional to
N , this memory system is exponentially resource conserving.

9
ACKNOWLDEGEMENTS :

The work was partly funded by NSF BCS-1058937 and AFOSR FA9550-12-1-0369.

[1] W. Maass, T. Natschläger, and H. Markram, Neural Computation 14, 2531 (2002).
[2] H. Jaeger, The echo state approach to analyzing and training recurrent networks, GMD-Report
148 (GMD - German National Research Institute for Information Technology, 2001).
[3] O. L. White, D. D. Lee, and H. Sompolinsky, Physical Review Letters 92, 148102 (2004).
[4] M. Hermans and B. Schrauwen, Neural Networks 23, 341 (2010).
[5] S. Ganguli, D. Huh, and H. Sompolinsky, Proceedings of the National Academy of Sciences
of the United States of America 105, 18970 (2008).
[6] T. Strauss, W. Wustlich, and R. Labahn, Neural Computation 24, 3246 (2012).
[7] R. Legenstein and W. Maass, Neural Networks 20, 323 (2007).
[8] E. Wallace, H. R. Maei, and P. E. Latham, Neural Computation 25, 1408 (2013).
[9] S. Ganguli and H. Sompolinsky, Annual Review of Neuroscience 35, 485 (2012).
[10] A. S. Charles, H. L. Yap, and C. J. Rozell, Neural Computation 26, 1198 (2014).
[11] B. Mandelbrot, The Fractal Geometry of Nature (W. H. Freeman, San Fransisco, CA, 1982).
[12] R. F. Voss and J. Clarke, Nature 258, 317 (1975).
[13] B. J. West and M. F. Shlesinger, American Scientist 78, 40 (1990).
[14] K. H. Shankar and M. W. Howard, Journal of Machine Learning Research 14, 3785 (2013).
[15] J. Gibbon, Psychological Review 84, 279 (1977).
[16] B. C. Rakitin, J. Gibbon, T. B. Penny, C. Malapani, S. C. Hinton, and W. H. Meck, Journal
of Experimental Psychololgy: Animal Behavior Processes 24, 15 (1998).
[17] K. H. Shankar and M. W. Howard, Neural Computation 24, 134 (2012).
[18] E. Post, Transactions of the American Mathematical Society 32, 723 (1930).
[19] D. Tank and J. Hopfield, Proceedings of the National Academy of Sciences 84, 1896 (1987).
[20] B. d. Vries and J. C. Principe, Neural Networks 5, 565 (1992).

